<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Installation</h1>
<h3 id="Compatibility-Note"><a href="#Compatibility-Note" class="headerlink"
        title="Compatibility Note"></a>Compatibility Note</h3>
<p>Vue does <strong>not</strong> support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in
    IE8. However it supports all <a target="_blank" rel="noopener" href="https://caniuse.com/#feat=es5">ECMAScript 5
        compliant browsers</a>.</p>
<h3 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic
    Versioning</h3>
<p>Vue follows <a target="_blank" rel="noopener" href="https://semver.org/">Semantic Versioning</a> in all its official
    projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described
    in <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/releases">release notes</a>.</p>
<h3 id="Release-Notes"><a href="#Release-Notes" class="headerlink" title="Release Notes"></a>Release Notes</h3>
<p>Latest stable version: 2.7.14</p>
<p>Detailed release notes for each version are available on <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue/releases">GitHub</a>.</p>
<h2 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools" data-scroll="">Vue Devtools</a>
</h2>
<p>When using Vue, we recommend also installing the <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-devtools#vue-devtools">Vue Devtools</a> in your browser, allowing you to
    inspect and debug your Vue applications in a more user-friendly interface.</p>
<h2 id="Direct-lt-script-gt-Include"><a href="#Direct-lt-script-gt-Include" class="headerlink"
        title="Direct <script> Include" data-scroll="">Direct <code>&lt;script&gt;</code> Include</a></h2>
<p>Simply download and include with a script tag. <code>Vue</code> will be registered as a global variable.</p>
<p class="tip">Don’t use the minified version during development. You will miss out on all the nice warnings for common
    mistakes!</p>
<div id="downloads"><br> <a class="button" href="/js/vue.js" download="">Development Version</a><span
        class="light info">With full warnings and debug mode</span><br><br> <a class="button" href="/js/vue.min.js"
        download="">Production Version</a><span class="light info">Warnings stripped, 37.51KB min+gzip</span><br></div>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN" data-scroll="">CDN</a></h3>
<p>For prototyping or learning purposes, you can use the latest version with:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer
    versions:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.7.14"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you are using native ES Modules, there is also an ES Modules compatible build:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.esm.browser.js'</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can browse the source of the NPM package at <a target="_blank" rel="noopener"
        href="https://cdn.jsdelivr.net/npm/vue/">cdn.jsdelivr.net/npm/vue</a>.</p>
<p>Vue is also available on <a target="_blank" rel="noopener" href="https://unpkg.com/vue@2.7.14/dist/vue.js">unpkg</a>
    and <a target="_blank" rel="noopener" href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.7.14/vue.js">cdnjs</a>
    (cdnjs takes some time to sync so the latest release may not be available yet).</p>
<p>Make sure to read about <a href="#Explanation-of-Different-Builds">the different builds of Vue</a> and use the
    <strong>production<br> version</strong> in your published site, replacing <code>vue.js</code> with
    <code>vue.min.js</code>. This is a smaller build optimized for speed instead of development experience.</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM" data-scroll="">NPM</a></h2>
<p>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with
    module bundlers such as <a target="_blank" rel="noopener" href="https://webpack.js.org/">Webpack</a> or <a
        target="_blank" rel="noopener" href="http://browserify.org/">Browserify</a>. Vue also provides accompanying
    tools for authoring <a href="single-file-components.html">Single File Components</a>.</p>
<figure class="highlight bash">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs bash"><span class="hljs-comment"># latest stable</span><br>$ npm install vue@^2<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI" data-scroll="">CLI</a></h2>
<p>Vue provides an <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli">official CLI</a> for
    quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern
    frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and
    production-ready builds. See <a target="_blank" rel="noopener" href="https://cli.vuejs.org">the Vue CLI docs</a> for
    more details.</p>
<p class="tip">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or
    front-end build tools, we strongly suggest going through <a href="./">the guide</a> without any build tools before
    using the CLI.</p>
<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/real-world-vue-js/vue-cli" target="_blank"
        rel="sponsored noopener" title="Vue CLI">Watch a video explanation on Vue Mastery</a></div>
<h2 id="Explanation-of-Different-Builds"><a href="#Explanation-of-Different-Builds" class="headerlink"
        title="Explanation of Different Builds" data-scroll="">Explanation of Different Builds</a></h2>
<p>In the <a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/"><code>dist/</code>
        directory of the NPM package</a> you will find many different builds of Vue.js. Here’s an overview of the
    difference between them:</p>
<table>
    <thead>
        <tr>
            <th></th>
            <th>UMD</th>
            <th>CommonJS</th>
            <th>ES Module (for bundlers)</th>
            <th>ES Module (for browsers)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Full</strong></td>
            <td>vue.js</td>
            <td>vue.common.js</td>
            <td>vue.esm.js</td>
            <td>vue.esm.browser.js</td>
        </tr>
        <tr>
            <td><strong>Runtime-only</strong></td>
            <td>vue.runtime.js</td>
            <td>vue.runtime.common.js</td>
            <td>vue.runtime.esm.js</td>
            <td>-</td>
        </tr>
        <tr>
            <td><strong>Full (production)</strong></td>
            <td>vue.min.js</td>
            <td>-</td>
            <td>-</td>
            <td>vue.esm.browser.min.js</td>
        </tr>
        <tr>
            <td><strong>Runtime-only (production)</strong></td>
            <td>vue.runtime.min.js</td>
            <td>-</td>
            <td>-</td>
            <td>-</td>
        </tr>
    </tbody>
</table>
<h3 id="Terms"><a href="#Terms" class="headerlink" title="Terms" data-scroll="">Terms</a></h3>
<ul>
    <li>
        <p><strong>Full</strong>: builds that contain both the compiler and the runtime.</p>
    </li>
    <li>
        <p><strong>Compiler</strong>: code that is responsible for compiling template strings into JavaScript render
            functions.</p>
    </li>
    <li>
        <p><strong>Runtime</strong>: code that is responsible for creating Vue instances, rendering and patching virtual
            DOM, etc. Basically everything minus the compiler.</p>
    </li>
    <li>
        <p><strong><a target="_blank" rel="noopener" href="https://github.com/umdjs/umd">UMD</a></strong>: UMD builds
            can be used directly in the browser via a <code>&lt;script&gt;</code> tag. The default file from jsDelivr
            CDN at <a target="_blank" rel="noopener"
                href="https://cdn.jsdelivr.net/npm/vue@2.7.14">https://cdn.jsdelivr.net/npm/vue@2.7.14</a> is the
            Runtime + Compiler UMD build (<code>vue.js</code>).</p>
    </li>
    <li>
        <p><strong><a target="_blank" rel="noopener"
                    href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a></strong>: CommonJS builds are intended
            for use with older bundlers like <a target="_blank" rel="noopener"
                href="http://browserify.org/">browserify</a> or <a target="_blank" rel="noopener"
                href="https://webpack.github.io">webpack 1</a>. The default file for these bundlers
            (<code>pkg.main</code>) is the Runtime only CommonJS build (<code>vue.runtime.common.js</code>).</p>
    </li>
    <li>
        <p><strong><a target="_blank" rel="noopener" href="http://exploringjs.com/es6/ch_modules.html">ES
                    Module</a></strong>: starting in 2.6 Vue provides two ES Modules (ESM) builds:</p>
        <ul>
            <li>
                <p>ESM for bundlers: intended for use with modern bundlers like <a target="_blank" rel="noopener"
                        href="https://webpack.js.org">webpack 2</a> or <a target="_blank" rel="noopener"
                        href="https://rollupjs.org/">Rollup</a>. ESM format is designed to be statically analyzable so
                    the bundlers can take advantage of that to perform “tree-shaking” and eliminate unused code from
                    your final bundle. The default file for these bundlers (<code>pkg.module</code>) is the Runtime only
                    ES Module build (<code>vue.runtime.esm.js</code>).</p>
            </li>
            <li>
                <p>ESM for browsers (2.6+ only): intended for direct imports in modern browsers via
                    <code>&lt;script type="module"&gt;</code>.</p>
            </li>
        </ul>
    </li>
</ul>
<h3 id="Runtime-Compiler-vs-Runtime-only"><a href="#Runtime-Compiler-vs-Runtime-only" class="headerlink"
        title="Runtime + Compiler vs. Runtime-only" data-scroll="">Runtime + Compiler vs. Runtime-only</a></h3>
<p>If you need to compile templates on the client (e.g. passing a string to the <code>template</code> option, or
    mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// this requires the compiler</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{ hi }}&lt;/div&gt;'</span><br>})<br><br><span class="hljs-comment">// this does not</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> render (h) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">hi</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When using <code>vue-loader</code> or <code>vueify</code>, templates inside <code>*.vue</code> files are pre-compiled
    into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the
    runtime-only build.</p>
<p>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it
    whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:
</p>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">resolve</span>: {<br> <span class="hljs-attr">alias</span>: {<br> <span class="hljs-string">'vue$'</span>: <span class="hljs-string">'vue/dist/vue.esm.js'</span> <span class="hljs-comment">// 'vue/dist/vue.common.js' for webpack 1</span><br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> alias = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rollup-plugin-alias'</span>)<br><br><span class="hljs-title function_">rollup</span>({<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">plugins</span>: [<br> <span class="hljs-title function_">alias</span>({<br> <span class="hljs-string">'vue'</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'vue/dist/vue.esm.js'</span>)<br> })<br> ]<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h4>
<p>Add to your project’s <code>package.json</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-string">"browser"</span>: {<br> <span class="hljs-string">"vue"</span>: <span class="hljs-string">"vue/dist/vue.common.js"</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4>
<p>Add to your project’s <code>package.json</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-string">"alias"</span>: {<br> <span class="hljs-string">"vue"</span> : <span class="hljs-string">"./node_modules/vue/dist/vue.common.js"</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Development-vs-Production-Mode"><a href="#Development-vs-Production-Mode" class="headerlink"
        title="Development vs. Production Mode" data-scroll="">Development vs. Production Mode</a></h3>
<p>Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the
    minified files are for production.</p>
<p>CommonJS and ES Module builds are intended for bundlers, therefore we don’t provide minified versions for them. You
    will be responsible for minifying the final bundle yourself.</p>
<p>CommonJS and ES Module builds also preserve raw checks for <code>process.env.NODE_ENV</code> to determine the mode
    they should run in. You should use appropriate bundler configurations to replace these environment variables in
    order to control which mode Vue will run in. Replacing <code>process.env.NODE_ENV</code> with string literals also
    allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.</p>
<h4 id="Webpack-1"><a href="#Webpack-1" class="headerlink" title="Webpack"></a>Webpack</h4>
<p>In Webpack 4+, you can use the <code>mode</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br> <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>But in Webpack 3 and earlier, you’ll need to use <a target="_blank" rel="noopener"
        href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">plugins</span>: [<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>({<br> <span class="hljs-string">'process.env'</span>: {<br> <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">'production'</span>)<br> }<br> })<br> ]<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Rollup-1"><a href="#Rollup-1" class="headerlink" title="Rollup"></a>Rollup</h4>
<p>Use <a target="_blank" rel="noopener"
        href="https://github.com/rollup/rollup-plugin-replace">rollup-plugin-replace</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> replace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rollup-plugin-replace'</span>)<br><br><span class="hljs-title function_">rollup</span>({<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">plugins</span>: [<br> <span class="hljs-title function_">replace</span>({<br> <span class="hljs-string">'process.env.NODE_ENV'</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">'production'</span>)<br> })<br> ]<br>}).<span class="hljs-title function_">then</span>(...)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Browserify-1"><a href="#Browserify-1" class="headerlink" title="Browserify"></a>Browserify</h4>
<p>Apply a global <a target="_blank" rel="noopener" href="https://github.com/hughsk/envify">envify</a> transform to your
    bundle.</p>
<figure class="highlight bash">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs bash">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Also see <a href="deployment.html">Production Deployment Tips</a>.</p>
<h3 id="CSP-environments"><a href="#CSP-environments" class="headerlink" title="CSP environments" data-scroll="">CSP
        environments</a></h3>
<p>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of
    <code>new Function()</code> for evaluating expressions. The full build depends on this feature to compile templates,
    so is unusable in these environments.</p>
<p>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with <a
        target="_blank" rel="noopener" href="https://github.com/vuejs-templates/webpack-simple">Webpack + vue-loader</a>
    or <a target="_blank" rel="noopener" href="https://github.com/vuejs-templates/browserify-simple">Browserify +
        vueify</a>, your templates will be precompiled into <code>render</code> functions which work perfectly in CSP
    environments.</p>
<h2 id="Dev-Build"><a href="#Dev-Build" class="headerlink" title="Dev Build" data-scroll="">Dev Build</a></h2>
<p><strong>Important</strong>: the built files in GitHub’s <code>/dist</code> folder are only checked-in during
    releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!</p>
<figure class="highlight bash">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/vuejs/vue.git node_modules/vue<br><span class="hljs-built_in">cd</span> node_modules/vue<br>npm install<br>npm run build<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Bower"><a href="#Bower" class="headerlink" title="Bower" data-scroll="">Bower</a></h2>
<p>Only UMD builds are available from Bower.</p>
<figure class="highlight bash">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs bash"><span class="hljs-comment"># latest stable</span><br>$ bower install vue<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="AMD-Module-Loaders"><a href="#AMD-Module-Loaders" class="headerlink" title="AMD Module Loaders"
        data-scroll="">AMD Module Loaders</a></h2>
<p>All UMD builds can be used directly as an AMD module.</p>
<div class="guide-links"> <span style="float: right"><a href="/v2/guide/index.html">Introduction</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Introduction</h1>
<h2 id="What-is-Vue-js"><a href="#What-is-Vue-js" class="headerlink" title="What is Vue.js?" data-scroll="">What is
        Vue.js?</a></h2>
<p>Vue (pronounced /vjuː/, like <strong>view</strong>) is a <strong>progressive framework</strong> for building user
    interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable.
    The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or
    existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page
    Applications when used in combination with <a href="single-file-components.html">modern tooling</a> and <a
        target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#components--libraries">supporting
        libraries</a>.</p>
<p>If you’d like to learn more about Vue before diving in, we <a id="modal-player" href="#">created a video</a> walking
    through the core principles and a sample project.</p>
<p>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check
    out the <a href="comparison.html">Comparison with Other Frameworks</a>.</p>
<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Course">Watch a free video course on Vue Mastery</a></div>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started" data-scroll="">Getting
        Started</a></h2>
<p><a class="button" href="installation.html">Installation</a></p>
<p class="tip">The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally
    new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp
    the basics then come back! Prior experience with other frameworks helps, but is not required.</p>
<p>The easiest way to try out Vue.js is using the <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-hello-world">Hello
        World example</a>. Feel free to open it in another tab and follow along as we go through some basic examples.
    Or, you can <a
        href="https://github.com/vuejs/v2.vuejs.org/blob/master/src/v2/examples/vue-20-hello-world/index.html"
        target="_blank" download="index.html" rel="noopener noreferrer">create an <code>index.html</code> file</a> and
    include Vue with:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- development version, includes helpful console warnings --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>or:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- production version, optimized for size and speed --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The <a href="installation.html">Installation</a> page provides more options of installing Vue. Note: We <strong>do
        not</strong> recommend that beginners start with <code>vue-cli</code>, especially if you are not yet familiar
    with Node.js-based build tools.</p>
<p>If you prefer something more interactive, you can also check out <a target="_blank" rel="noopener"
        href="https://scrimba.com/g/gvuedocs">this tutorial series on Scrimba</a>, which gives you a mix of screencast
    and code playground that you can pause and play around with anytime.</p>
<h2 id="Declarative-Rendering"><a href="#Declarative-Rendering" class="headerlink" title="Declarative Rendering"
        data-scroll="">Declarative Rendering</a></h2>
<div class="scrimba"><a href="https://scrimba.com/p/pXKqta/cQ3QVcr" target="_blank" rel="noopener noreferrer">Try this
        lesson on Scrimba</a></div>
<p>At the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward
    template syntax:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br> {{ message }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue!'</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app" class="demo"> Hello Vue! </div>
<script> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } })</script>
<p>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has
    done a lot of work under the hood. The data and the DOM are now linked, and everything is now
    <strong>reactive</strong>. How do we know? Open your browser’s JavaScript console (right now, on this page) and set
    <code>app.message</code> to a different value. You should see the rendered example above update accordingly.</p>
<p>Note that we no longer have to interact with the HTML directly. A Vue app attaches itself to a single DOM element
    (<code>#app</code> in our case) then fully controls it. The HTML is our entry point, but everything else happens
    within the newly created Vue instance.</p>
<p>In addition to text interpolation, we can also bind element attributes like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-2"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"message"</span>&gt;</span><br> Hover your mouse over me for a few seconds<br> to see my dynamically bound title!<br> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-2'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'You loaded this page on '</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>()<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-2" class="demo"><span title="You loaded this page on 29/3/2023 18:21:51"> Hover your mouse over me for a
        few seconds to see my dynamically bound title! </span></div>
<script> var app2 = new Vue({ el: '#app-2', data: { message: 'You loaded this page on ' + new Date().toLocaleString() } })</script>
<p>Here we are encountering something new. The <code>v-bind</code> attribute you are seeing is called a
    <strong>directive</strong>. Directives are prefixed with <code>v-</code> to indicate that they are special
    attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM.
    Here, it is basically saying “keep this element’s <code>title</code> attribute up-to-date with the
    <code>message</code> property on the Vue instance.”</p>
<p>If you open up your JavaScript console again and enter <code>app2.message = 'some new message'</code>, you’ll once
    again see that the bound HTML - in this case the <code>title</code> attribute - has been updated.</p>
<h2 id="Conditionals-and-Loops"><a href="#Conditionals-and-Loops" class="headerlink" title="Conditionals and Loops"
        data-scroll="">Conditionals and Loops</a></h2>
<div class="scrimba"><a href="https://scrimba.com/p/pXKqta/cEQe4SJ" target="_blank" rel="noopener noreferrer">Try this
        lesson on Scrimba</a></div>
<p>It’s easy to toggle the presence of an element, too:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-3"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"seen"</span>&gt;</span>Now you see me<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-3'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">seen</span>: <span class="hljs-literal">true</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-3" class="demo"><span>Now you see me</span></div>
<script> var app3 = new Vue({ el: '#app-3', data: { seen: true } })</script>
<p>Go ahead and enter <code>app3.seen = false</code> in the console. You should see the message disappear.</p>
<p>This example demonstrates that we can bind data to not only text and attributes, but also the
    <strong>structure</strong> of the DOM. Moreover, Vue also provides a powerful transition effect system that can
    automatically apply <a href="transitions.html">transition effects</a> when elements are inserted/updated/removed by
    Vue.</p>
<p>There are quite a few other directives, each with its own special functionality. For example, the <code>v-for</code>
    directive can be used for displaying a list of items using the data from an Array:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-4"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in todos"</span>&gt;</span><br> {{ todo.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-4'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">todos</span>: [<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'Learn JavaScript'</span> },<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'Learn Vue'</span> },<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'Build something awesome'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-4" class="demo">
    <ol>
        <li> Learn JavaScript </li>
        <li> Learn Vue </li>
        <li> Build something awesome </li>
    </ol>
</div>
<script> var app4 = new Vue({ el: '#app-4', data: { todos: [{ text: 'Learn JavaScript' }, { text: 'Learn Vue' }, { text: 'Build something awesome' }] } })</script>
<p>In the console, enter <code>app4.todos.push({ text: 'New item' })</code>. You should see a new item appended to the
    list.</p>
<h2 id="Handling-User-Input"><a href="#Handling-User-Input" class="headerlink" title="Handling User Input"
        data-scroll="">Handling User Input</a></h2>
<div class="scrimba"><a href="https://scrimba.com/p/pXKqta/czPNaUr" target="_blank" rel="noopener noreferrer">Try this
        lesson on Scrimba</a></div>
<p>To let users interact with your app, we can use the <code>v-on</code> directive to attach event listeners that invoke
    methods on our Vue instances:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-5"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"reverseMessage"</span>&gt;</span>Reverse Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-5'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue.js!'</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-5" class="demo">
    <p>Hello Vue.js!</p> <button>Reverse Message</button>
</div>
<script> var app5 = new Vue({ el: '#app-5', data: { message: 'Hello Vue.js!' }, methods: { reverseMessage: function () { this.message = this.message.split('').reverse().join('') } } })</script>
<p>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled
    by Vue, and the code you write is focused on the underlying logic.</p>
<p>Vue also provides the <code>v-model</code> directive that makes two-way binding between form input and app state a
    breeze:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-6"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> app6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-6'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue!'</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-6" class="demo">
    <p>Hello Vue!</p> <input>
</div>
<script> var app6 = new Vue({ el: '#app-6', data: { message: 'Hello Vue!' } })</script>
<h2 id="Composing-with-Components"><a href="#Composing-with-Components" class="headerlink"
        title="Composing with Components" data-scroll="">Composing with Components</a></h2>
<div class="scrimba"><a href="https://scrimba.com/p/pXKqta/cEQVkA3" target="_blank" rel="noopener noreferrer">Try this
        lesson on Scrimba</a></div>
<p>The component system is another important concept in Vue, because it’s an abstraction that allows us to build
    large-scale applications composed of small, self-contained, and often reusable components. If we think about it,
    almost any type of application interface can be abstracted into a tree of components:</p>
<p><img src="/images/components.png" alt="Component Tree"></p>
<p>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is
    straightforward:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Define a new component called todo-item</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'todo-item'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;li&gt;This is a todo&lt;/li&gt;'</span><br>})<br><br><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(...)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now you can compose it in another component’s template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- Create an instance of the todo-item component --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">todo-item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>But this would render the same text for every todo, which is not super interesting. We should be able to pass data
    from the parent scope into child components. Let’s modify the component definition to make it accept a <a
        href="components.html#Props">prop</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'todo-item'</span>, {<br> <span class="hljs-comment">// The todo-item component now accepts a</span><br> <span class="hljs-comment">// "prop", which is like a custom attribute.</span><br> <span class="hljs-comment">// This prop is called todo.</span><br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'todo'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now we can pass the todo into each repeated component using <code>v-bind</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-7"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> Now we provide each todo-item with the todo object</span><br><span class="hljs-comment"> it's representing, so that its content can be dynamic.</span><br><span class="hljs-comment"> We also need to provide each component with a "key",</span><br><span class="hljs-comment"> which will be explained later.</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">todo-item</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in groceryList"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">"item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span></span><br><span class="hljs-tag"> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'todo-item'</span>, {<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'todo'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;li&gt;{{ todo.text }}&lt;/li&gt;'</span><br>})<br><br><span class="hljs-keyword">var</span> app7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app-7'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">groceryList</span>: [<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'Vegetables'</span> },<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'Cheese'</span> },<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'Whatever else humans are supposed to eat'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="app-7" class="demo">
    <ol>
        <li>Vegetables</li>
        <li>Cheese</li>
        <li>Whatever else humans are supposed to eat</li>
    </ol>
</div>
<script> Vue.component('todo-item', { props: ['todo'], template: '<li>{{ todo.text }}</li>' }) var app7 = new Vue({ el: '#app-7', data: { groceryList: [{ id: 0, text: 'Vegetables' }, { id: 1, text: 'Cheese' }, { id: 2, text: 'Whatever else humans are supposed to eat' }] } })</script>
<p>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is
    reasonably well-decoupled from the parent via the props interface. We can now further improve our
    <code>&lt;todo-item&gt;</code> component with more complex template and logic without affecting the parent app.</p>
<p>In a large application, it is necessary to divide the whole app into components to make development manageable. We
    will talk a lot more about components <a href="components.html">later in the guide</a>, but here’s an (imaginary)
    example of what an app’s template might look like with components:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">app-nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-nav</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">app-view</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">app-sidebar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-sidebar</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">app-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-content</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">app-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Relation-to-Custom-Elements"><a href="#Relation-to-Custom-Elements" class="headerlink"
        title="Relation to Custom Elements" data-scroll="">Relation to Custom Elements</a></h3>
<p>You may have noticed that Vue components are very similar to <strong>Custom Elements</strong>, which are part of the
    <a target="_blank" rel="noopener" href="https://www.w3.org/wiki/WebComponents/">Web Components Spec</a>. That’s
    because Vue’s component syntax is loosely modeled after the spec. For example, Vue components implement the <a
        target="_blank" rel="noopener"
        href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Slot API</a> and the
    <code>is</code> special attribute. However, there are a few key differences:</p>
<ol>
    <li>
        <p>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+,
            Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don’t require any
            polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can
            also be wrapped inside a native custom element.</p>
    </li>
    <li>
        <p>Vue components provide important features that are not available in plain custom elements, most notably
            cross-component data flow, custom event communication and build tool integrations.</p>
    </li>
</ol>
<p>Although Vue doesn’t use custom elements internally, it has <a target="_blank" rel="noopener"
        href="https://custom-elements-everywhere.com/#vue">great interoperability</a> when it comes to consuming or
    distributing as custom elements. Vue CLI also supports building Vue components that register themselves as native
    custom elements.</p>
<h2 id="Ready-for-More"><a href="#Ready-for-More" class="headerlink" title="Ready for More?" data-scroll="">Ready for
        More?</a></h2>
<p>We’ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other
    advanced features with much finer details, so make sure to read through it all!</p>
<div id="video-modal" class="modal">
    <div class="video-space" style="padding: 56.25% 0 0 0; position: relative;"><iframe
            src="https://player.vimeo.com/video/247494684?dnt=1"
            style="height: 100%; left: 0; position: absolute; top: 0; width: 100%; margin: 0" webkitallowfullscreen=""
            mozallowfullscreen="" allowfullscreen="" data-ready="true" frameborder="0"></iframe></div>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <p class="modal-text">Video by <a href="https://www.vuemastery.com" target="_blank" rel="sponsored noopener"
            title="Vue.js Courses on Vue Mastery">Vue Mastery</a>. Watch Vue Mastery’s free <a
            href="https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/" target="_blank"
            rel="sponsored noopener" title="Vue.js Courses on Vue Mastery">Intro to Vue course</a>.</p>
</div>
<div class="guide-links"> <span>← <a href="/v2/guide/installation.html">Installation</a></span> <span
        style="float: right"><a href="/v2/guide/instance.html">The Vue Instance</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>The Vue Instance</h1>
<script> const __pageRedirects = { '#Data-and-Methods': '/guide/essentials/reactivity-fundamentals.html', '#Instance-Lifecycle-Hooks': '/guide/essentials/lifecycle.html', '#Lifecycle-Diagram': '/guide/essentials/lifecycle.html#lifecycle-diagram' }</script>
<h2 id="Creating-a-Vue-Instance"><a href="#Creating-a-Vue-Instance" class="headerlink" title="Creating a Vue Instance"
        data-scroll="">Creating a Vue Instance</a></h2>
<p>Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-comment">// options</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Although not strictly associated with the <a target="_blank" rel="noopener"
        href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM pattern</a>, Vue’s design was partly inspired by
    it. As a convention, we often use the variable <code>vm</code> (short for ViewModel) to refer to our Vue instance.
</p>
<p>When you create a Vue instance, you pass in an <strong>options object</strong>. The majority of this guide describes
    how you can use these options to create your desired behavior. For reference, you can also browse the full list of
    options in the <a href="../api/#Options-Data">API reference</a>.</p>
<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally
    organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:
</p>
<figure class="highlight plaintext">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs plaintext">Root Instance<br>└─ TodoList<br> ├─ TodoItem<br> │ ├─ TodoButtonDelete<br> │ └─ TodoButtonEdit<br> └─ TodoListFooter<br> ├─ TodosButtonClear<br> └─ TodoListStatistics<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>We’ll talk about <a href="components.html">the component system</a> in detail later. For now, just know that all Vue
    components are also Vue instances, and so accept the same options object (except for a few root-specific options).
</p>
<h2 id="Data-and-Methods"><a href="#Data-and-Methods" class="headerlink" title="Data and Methods" data-scroll="">Data
        and Methods</a></h2>
<p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue’s
    <strong>reactivity system</strong>. When the values of those properties change, the view will “react”, updating to
    match the new values.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Our data object</span><br><span class="hljs-keyword">var</span> data = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }<br><br><span class="hljs-comment">// The object is added to a Vue instance</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: data<br>})<br><br><span class="hljs-comment">// Getting the property on the instance</span><br><span class="hljs-comment">// returns the one from the original data</span><br>vm.<span class="hljs-property">a</span> == data.<span class="hljs-property">a</span> <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// Setting the property on the instance</span><br><span class="hljs-comment">// also affects the original data</span><br>vm.<span class="hljs-property">a</span> = <span class="hljs-number">2</span><br>data.<span class="hljs-property">a</span> <span class="hljs-comment">// =&gt; 2</span><br><br><span class="hljs-comment">// ... and vice-versa</span><br>data.<span class="hljs-property">a</span> = <span class="hljs-number">3</span><br>vm.<span class="hljs-property">a</span> <span class="hljs-comment">// =&gt; 3</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When this data changes, the view will re-render. It should be noted that properties in <code>data</code> are only
    <strong>reactive</strong> if they existed when the instance was created. That means if you add a new property, like:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">vm.<span class="hljs-property">b</span> = <span class="hljs-string">'hi'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then changes to <code>b</code> will not trigger any view updates. If you know you’ll need a property later, but it
    starts out empty or non-existent, you’ll need to set some initial value. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">newTodoText</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">visitCount</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">hideCompletedTodos</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">todos</span>: [],<br> <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The only exception to this being the use of <code>Object.freeze()</code>, which prevents existing properties from
    being changed, which also means the reactivity system can’t <em>track</em> changes.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = {<br> <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span><br>}<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">data</span>: obj<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ foo }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- this will no longer update `foo`! --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"foo = 'baz'"</span>&gt;</span>Change it<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are
    prefixed with <code>$</code> to differentiate them from user-defined properties. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> data = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example'</span>,<br> <span class="hljs-attr">data</span>: data<br>})<br><br>vm.<span class="hljs-property">$data</span> === data <span class="hljs-comment">// =&gt; true</span><br>vm.<span class="hljs-property">$el</span> === <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'example'</span>) <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// $watch is an instance method</span><br>vm.$watch(<span class="hljs-string">'a'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) {<br> <span class="hljs-comment">// This callback will be called when `vm.a` changes</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the future, you can consult the <a href="../api/#Instance-Properties">API reference</a> for a full list of
    instance properties and methods.</p>
<h2 id="Instance-Lifecycle-Hooks"><a href="#Instance-Lifecycle-Hooks" class="headerlink"
        title="Instance Lifecycle Hooks" data-scroll="">Instance Lifecycle Hooks</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs"
        target="_blank" rel="sponsored noopener" title="Free Vue.js Lifecycle Hooks Lesson">Watch a free lesson on Vue
        School</a></div>
<p>Each Vue instance goes through a series of initialization steps when it’s created - for example, it needs to set up
    data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along
    the way, it also runs functions called <strong>lifecycle hooks</strong>, giving users the opportunity to add their
    own code at specific stages.</p>
<p>For example, the <a href="../api/#created"><code>created</code></a> hook can be used to run code after an instance is
    created:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br> },<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// `this` points to the vm instance</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a is: '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br> }<br>})<br><span class="hljs-comment">// =&gt; "a is: 1"</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>There are also other hooks which will be called at different stages of the instance’s lifecycle, such as <a
        href="../api/#mounted"><code>mounted</code></a>, <a href="../api/#updated"><code>updated</code></a>, and <a
        href="../api/#destroyed"><code>destroyed</code></a>. All lifecycle hooks are called with their <code>this</code>
    context pointing to the Vue instance invoking it.</p>
<p class="tip">Don’t use <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow
        functions</a> on an options property or callback, such as <code>created: () =&gt; console.log(this.a)</code> or
    <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>. Since an arrow function doesn’t have a
    <code>this</code>, <code>this</code> will be treated as any other variable and lexically looked up through parent
    scopes until found, often resulting in errors such as
    <code>Uncaught TypeError: Cannot read property of undefined</code> or
    <code>Uncaught TypeError: this.myMethod is not a function</code>.</p>
<h2 id="Lifecycle-Diagram"><a href="#Lifecycle-Diagram" class="headerlink" title="Lifecycle Diagram"
        data-scroll="">Lifecycle Diagram</a></h2>
<p>Below is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but
    as you learn and build more, it will be a useful reference.</p>
<p><img src="/images/lifecycle.png" alt="The Vue Instance Lifecycle"></p>
<div class="guide-links"> <span>← <a href="/v2/guide/index.html">Introduction</a></span> <span style="float: right"><a
            href="/v2/guide/syntax.html">Template Syntax</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Template Syntax</h1>
<p>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying
    Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML
    parsers.</p>
<p>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system,
    Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount
    of DOM manipulations when the app state changes.</p>
<p>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also <a
        href="render-function.html">directly write render functions</a> instead of templates, with optional JSX support.
</p>
<h2 id="Interpolations"><a href="#Interpolations" class="headerlink" title="Interpolations"
        data-scroll="">Interpolations</a></h2>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text" data-scroll="">Text</a></h3>
<p>The most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: {{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The mustache tag will be replaced with the value of the <code>msg</code> property on the corresponding data object.
    It will also be updated whenever the data object’s <code>msg</code> property changes.</p>
<p>You can also perform one-time interpolations that do not update on data change by using the <a
        href="../api/#v-once">v-once directive</a>, but keep in mind this will also affect any other bindings on the
    same node:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>This will never change: {{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Raw-HTML"><a href="#Raw-HTML" class="headerlink" title="Raw HTML" data-scroll="">Raw HTML</a></h3>
<p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use
    the <a href="../api/#v-html"><code>v-html</code> directive</a>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: {{ rawHtml }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"rawHtml"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example1" class="demo">
    <p>Using mustaches: &lt;span style="color: red"&gt;This should be red.&lt;/span&gt;</p>
    <p>Using v-html directive: <span><span style="color: red">This should be red.</span></span></p>
</div>
<script> new Vue({ el: '#example1', data: function () { return { rawHtml: '<span style="color: red">This should be red.</span>' } } })</script>
<p>The contents of the <code>span</code> will be replaced with the value of the <code>rawHtml</code> property,
    interpreted as plain HTML - data bindings are ignored. Note that you cannot use <code>v-html</code> to compose
    template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the
    fundamental unit for UI reuse and composition.</p>
<p class="tip">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to
    <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS vulnerabilities</a>.
    Only use HTML interpolation on trusted content and <strong>never</strong> on user-provided content.</p>
<h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes" data-scroll="">Attributes</a></h3>
<p>Mustaches cannot be used inside HTML attributes. Instead, use a <a href="../api/#v-bind"><code>v-bind</code>
        directive</a>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"dynamicId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the case of boolean attributes, where their mere existence implies <code>true</code>, <code>v-bind</code> works a
    little differently. In this example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">"isButtonDisabled"</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If <code>isButtonDisabled</code> has the value of <code>null</code>, <code>undefined</code>, or <code>false</code>,
    the <code>disabled</code> attribute will not even be included in the rendered <code>&lt;button&gt;</code> element.
</p>
<h3 id="Using-JavaScript-Expressions"><a href="#Using-JavaScript-Expressions" class="headerlink"
        title="Using JavaScript Expressions" data-scroll="">Using JavaScript Expressions</a></h3>
<p>So far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power
    of JavaScript expressions inside all data bindings:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html">{{ number + 1 }}<br><br>{{ ok ? 'YES' : 'NO' }}<br><br>{{ message.split('').reverse().join('') }}<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"'list-' + id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is
    that each binding can only contain <strong>one single expression</strong>, so the following will
    <strong>NOT</strong> work:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- this is a statement, not an expression: --&gt;</span><br>{{ var a = 1 }}<br><br><span class="hljs-comment">&lt;!-- flow control won't work either, use ternary expressions --&gt;</span><br>{{ if (ok) { return message } }}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Template expressions are sandboxed and only have access to a <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">whitelist of globals</a> such as
    <code>Math</code> and <code>Date</code>. You should not attempt to access user-defined globals in template
    expressions.</p>
<h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives" data-scroll="">Directives</a></h2>
<p>Directives are special attributes with the <code>v-</code> prefix. Directive attribute values are expected to be
    <strong>a single JavaScript expression</strong> (with the exception of <code>v-for</code>, which will be discussed
    later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes.
    Let’s review the example we saw in the introduction:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"seen"</span>&gt;</span>Now you see me<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here, the <code>v-if</code> directive would remove/insert the <code>&lt;p&gt;</code> element based on the truthiness
    of the value of the expression <code>seen</code>.</p>
<h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments" data-scroll="">Arguments</a></h3>
<p>Some directives can take an “argument”, denoted by a colon after the directive name. For example, the
    <code>v-bind</code> directive is used to reactively update an HTML attribute:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here <code>href</code> is the argument, which tells the <code>v-bind</code> directive to bind the element’s
    <code>href</code> attribute to the value of the expression <code>url</code>.</p>
<p>Another example is the <code>v-on</code> directive, which listens to DOM events:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p>
<h3 id="Dynamic-Arguments"><a href="#Dynamic-Arguments" class="headerlink" title="Dynamic Arguments"
        data-scroll="">Dynamic Arguments</a></h3>
<blockquote>
    <p>New in 2.6.0+</p>
</blockquote>
<p>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it
    with square brackets:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">Note that there are some constraints to the argument expression, as explained</span><br><span class="hljs-comment">in the "Dynamic Argument Expression Constraints" section below.</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here <code>attributeName</code> will be dynamically evaluated as a JavaScript expression, and its evaluated value
    will be used as the final value for the argument. For example, if your Vue instance has a data property,
    <code>attributeName</code>, whose value is <code>"href"</code>, then this binding will be equivalent to
    <code>v-bind:href</code>.</p>
<p>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">eventName</span>]=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In this example, when <code>eventName</code>‘s value is <code>"focus"</code>, <code>v-on:[eventName]</code> will be
    equivalent to <code>v-on:focus</code>.</p>
<h4 id="Dynamic-Argument-Value-Constraints"><a href="#Dynamic-Argument-Value-Constraints" class="headerlink"
        title="Dynamic Argument Value Constraints"></a>Dynamic Argument Value Constraints</h4>
<p>Dynamic arguments are expected to evaluate to a string, with the exception of <code>null</code>. The special value
    <code>null</code> can be used to explicitly remove the binding. Any other non-string value will trigger a warning.
</p>
<h4 id="Dynamic-Argument-Expression-Constraints"><a href="#Dynamic-Argument-Expression-Constraints" class="headerlink"
        title="Dynamic Argument Expression Constraints"></a>Dynamic Argument Expression Constraints</h4>
<p>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are
    invalid inside HTML attribute names. For example, the following is invalid:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- This will trigger a compiler warning. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>['<span class="hljs-attr">foo</span>' + <span class="hljs-attr">bar</span>]=<span class="hljs-string">"value"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a
    computed property.</p>
<p>When using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys
    with uppercase characters, as browsers will coerce attribute names into lowercase:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">This will be converted to v-bind:[someattr] in in-DOM templates.</span><br><span class="hljs-comment">Unless you have a "someattr" property in your instance, your code won't work.</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">someAttr</span>]=<span class="hljs-string">"value"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers" data-scroll="">Modifiers</a></h3>
<p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special
    way. For example, the <code>.prevent</code> modifier tells the <code>v-on</code> directive to call
    <code>event.preventDefault()</code> on the triggered event:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">"onSubmit"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You’ll see other examples of modifiers later, <a href="events.html#Event-Modifiers">for <code>v-on</code></a> and <a
        href="forms.html#Modifiers">for <code>v-model</code></a>, when we explore those features.</p>
<h2 id="Shorthands"><a href="#Shorthands" class="headerlink" title="Shorthands" data-scroll="">Shorthands</a></h2>
<p>The <code>v-</code> prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is
    useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some
    frequently used directives. At the same time, the need for the <code>v-</code> prefix becomes less important when
    you are building a <a target="_blank" rel="noopener"
        href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a>, where Vue manages every template.
    Therefore, Vue provides special shorthands for two of the most often used directives, <code>v-bind</code> and
    <code>v-on</code>:</p>
<h3 id="v-bind-Shorthand"><a href="#v-bind-Shorthand" class="headerlink" title="v-bind Shorthand"
        data-scroll=""><code>v-bind</code> Shorthand</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- full syntax --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- shorthand --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="v-on-Shorthand"><a href="#v-on-Shorthand" class="headerlink" title="v-on Shorthand"
        data-scroll=""><code>v-on</code> Shorthand</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- full syntax --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- shorthand --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>They may look a bit different from normal HTML, but <code>:</code> and <code>@</code> are valid characters for
    attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final
    rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more
    about its usage later.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/instance.html">The Vue Instance</a></span> <span
        style="float: right"><a href="/v2/guide/computed.html">Computed Properties and Watchers</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Computed Properties and Watchers</h1>
<script> const __pageRedirects = { '#Watchers': '/guide/essentials/watchers.html' }</script>
<h2 id="Computed-Properties"><a href="#Computed-Properties" class="headerlink" title="Computed Properties"
        data-scroll="">Computed Properties</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how computed properties work with Vue School">Learn how computed
        properties work with a free lesson on Vue School</a></div>
<p>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your
    templates can make them bloated and hard to maintain. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span><br> {{ message.split('').reverse().join('') }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing
    that it displays <code>message</code> in reverse. The problem is made worse when you want to include the reversed
    message in your template more than once.</p>
<p>That’s why for any complex logic, you should use a <strong>computed property</strong>.</p>
<h3 id="Basic-Example"><a href="#Basic-Example" class="headerlink" title="Basic Example" data-scroll="">Basic
        Example</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: "{{ message }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: "{{ reversedMessage }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello'</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-comment">// a computed getter</span><br> <span class="hljs-attr">reversedMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// `this` points to the vm instance</span><br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="example" class="demo">
    <p>Original message: "Hello"</p>
    <p>Computed reversed message: "olleH"</p>
</div>
<script> var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } })</script>
<p>Here we have declared a computed property <code>reversedMessage</code>. The function we provided will be used as the
    getter function for the property <code>vm.reversedMessage</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">reversedMessage</span>) <span class="hljs-comment">// =&gt; 'olleH'</span><br>vm.<span class="hljs-property">message</span> = <span class="hljs-string">'Goodbye'</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">reversedMessage</span>) <span class="hljs-comment">// =&gt; 'eybdooG'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can open the console and play with the example vm yourself. The value of <code>vm.reversedMessage</code> is
    always dependent on the value of <code>vm.message</code>.</p>
<p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that
    <code>vm.reversedMessage</code> depends on <code>vm.message</code>, so it will update any bindings that depend on
    <code>vm.reversedMessage</code> when <code>vm.message</code> changes. And the best part is that we’ve created this
    dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to
    test and understand.</p>
<h3 id="Computed-Caching-vs-Methods"><a href="#Computed-Caching-vs-Methods" class="headerlink"
        title="Computed Caching vs Methods" data-scroll="">Computed Caching vs Methods</a></h3>
<p>You may have noticed we can achieve the same result by invoking a method in the expression:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Reversed message: "{{ reverseMessage() }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// in component</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches
    are indeed exactly the same. However, the difference is that <strong>computed properties are cached based on their
        reactive dependencies.</strong> A computed property will only re-evaluate when some of its reactive dependencies
    have changed. This means as long as <code>message</code> has not changed, multiple access to the
    <code>reversedMessage</code> computed property will immediately return the previously computed result without having
    to run the function again.</p>
<p>This also means the following computed property will never update, because <code>Date.now()</code> is not a reactive
    dependency:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">now</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In comparison, a method invocation will <strong>always</strong> run the function whenever a re-render happens.</p>
<p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping
    through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend
    on <strong>A</strong>. Without caching, we would be executing <strong>A</strong>’s getter many more times than
    necessary! In cases where you do not want caching, use a method instead.</p>
<h3 id="Computed-vs-Watched-Property"><a href="#Computed-vs-Watched-Property" class="headerlink"
        title="Computed vs Watched Property" data-scroll="">Computed vs Watched Property</a></h3>
<p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch
        properties</strong>. When you have some data that needs to change based on some other data, it is tempting to
    overuse <code>watch</code> - especially if you are coming from an AngularJS background. However, it is often a
    better idea to use a computed property rather than an imperative <code>watch</code> callback. Consider this example:
</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>&gt;</span>{{ fullName }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Foo'</span>,<br> <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bar'</span>,<br> <span class="hljs-attr">fullName</span>: <span class="hljs-string">'Foo Bar'</span><br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = val + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> },<br> <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + val<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above code is imperative and repetitive. Compare it with a computed property version:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Foo'</span>,<br> <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bar'</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Much better, isn’t it?</p>
<h3 id="Computed-Setter"><a href="#Computed-Setter" class="headerlink" title="Computed Setter" data-scroll="">Computed
        Setter</a></h3>
<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">fullName</span>: {<br> <span class="hljs-comment">// getter</span><br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> },<br> <span class="hljs-comment">// setter</span><br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) {<br> <span class="hljs-keyword">var</span> names = newValue.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = names[<span class="hljs-number">0</span>]<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = names[names.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br> }<br> }<br>}<br><span class="hljs-comment">// ...</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now when you run <code>vm.fullName = 'John Doe'</code>, the setter will be invoked and <code>vm.firstName</code> and
    <code>vm.lastName</code> will be updated accordingly.</p>
<h2 id="Watchers"><a href="#Watchers" class="headerlink" title="Watchers" data-scroll="">Watchers</a></h2>
<p>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary.
    That’s why Vue provides a more generic way to react to data changes through the <code>watch</code> option. This is
    most useful when you want to perform asynchronous or expensive operations in response to changing data.</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"watch-example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br> Ask a yes/no question:<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"question"</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ answer }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;</span><br><span class="hljs-comment">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span><br><span class="hljs-comment">&lt;!-- is able to remain small by not reinventing them. This also --&gt;</span><br><span class="hljs-comment">&lt;!-- gives you the freedom to use what you're familiar with. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({</span><br><span class="language-javascript"> <span class="hljs-attr">el</span>: <span class="hljs-string">'#watch-example'</span>,</span><br><span class="language-javascript"> <span class="hljs-attr">data</span>: {</span><br><span class="language-javascript"> <span class="hljs-attr">question</span>: <span class="hljs-string">''</span>,</span><br><span class="language-javascript"> <span class="hljs-attr">answer</span>: <span class="hljs-string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">watch</span>: {</span><br><span class="language-javascript"> <span class="hljs-comment">// whenever question changes, this function will run</span></span><br><span class="language-javascript"> <span class="hljs-attr">question</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) {</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Waiting for you to stop typing...'</span></span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">debouncedGetAnswer</span>()</span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span><br><span class="language-javascript"> <span class="hljs-comment">// _.debounce is a function provided by lodash to limit how</span></span><br><span class="language-javascript"> <span class="hljs-comment">// often a particularly expensive operation can be run.</span></span><br><span class="language-javascript"> <span class="hljs-comment">// In this case, we want to limit how often we access</span></span><br><span class="language-javascript"> <span class="hljs-comment">// yesno.wtf/api, waiting until the user has completely</span></span><br><span class="language-javascript"> <span class="hljs-comment">// finished typing before making the ajax request. To learn</span></span><br><span class="language-javascript"> <span class="hljs-comment">// more about the _.debounce function (and its cousin</span></span><br><span class="language-javascript"> <span class="hljs-comment">// _.throttle), visit: https://lodash.com/docs#debounce</span></span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">debouncedGetAnswer</span> = _.<span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getAnswer</span>, <span class="hljs-number">500</span>)</span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">methods</span>: {</span><br><span class="language-javascript"> <span class="hljs-attr">getAnswer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span><br><span class="language-javascript"> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">question</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'?'</span>) === -<span class="hljs-number">1</span>) {</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="language-javascript"> <span class="hljs-keyword">return</span></span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Thinking...'</span></span><br><span class="language-javascript"> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span></span><br><span class="language-javascript"> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'https://yesno.wtf/api'</span>)</span><br><span class="language-javascript"> .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) {</span><br><span class="language-javascript"> vm.<span class="hljs-property">answer</span> = _.<span class="hljs-title function_">capitalize</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">answer</span>)</span><br><span class="language-javascript"> })</span><br><span class="language-javascript"> .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {</span><br><span class="language-javascript"> vm.<span class="hljs-property">answer</span> = <span class="hljs-string">'Error! Could not reach the API. '</span> + error</span><br><span class="language-javascript"> })</span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> }</span><br><span class="language-javascript">})</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="watch-example" class="demo">
    <p> Ask a yes/no question: <input></p>
    <p>I cannot give you an answer until you ask a question!</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script> var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() } }, created: function () { this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)' return } this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api').then(function (response) { vm.answer = _.capitalize(response.data.answer) }).catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } } })</script>
<p>In this case, using the <code>watch</code> option allows us to perform an asynchronous operation (accessing an API),
    limit how often we perform that operation, and set intermediary states until we get a final answer. None of that
    would be possible with a computed property.</p>
<p>In addition to the <code>watch</code> option, you can also use the imperative <a href="../api/#vm-watch">vm.$watch
        API</a>.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/syntax.html">Template Syntax</a></span> <span
        style="float: right"><a href="/v2/guide/class-and-style.html">Class and Style Bindings</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Computed Properties and Watchers</h1>
<script> const __pageRedirects = { '#Watchers': '/guide/essentials/watchers.html' }</script>
<h2 id="Computed-Properties"><a href="#Computed-Properties" class="headerlink" title="Computed Properties"
        data-scroll="">Computed Properties</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how computed properties work with Vue School">Learn how computed
        properties work with a free lesson on Vue School</a></div>
<p>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your
    templates can make them bloated and hard to maintain. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span><br> {{ message.split('').reverse().join('') }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing
    that it displays <code>message</code> in reverse. The problem is made worse when you want to include the reversed
    message in your template more than once.</p>
<p>That’s why for any complex logic, you should use a <strong>computed property</strong>.</p>
<h3 id="Basic-Example"><a href="#Basic-Example" class="headerlink" title="Basic Example" data-scroll="">Basic
        Example</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: "{{ message }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: "{{ reversedMessage }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello'</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-comment">// a computed getter</span><br> <span class="hljs-attr">reversedMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// `this` points to the vm instance</span><br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="example" class="demo">
    <p>Original message: "Hello"</p>
    <p>Computed reversed message: "olleH"</p>
</div>
<script> var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } })</script>
<p>Here we have declared a computed property <code>reversedMessage</code>. The function we provided will be used as the
    getter function for the property <code>vm.reversedMessage</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">reversedMessage</span>) <span class="hljs-comment">// =&gt; 'olleH'</span><br>vm.<span class="hljs-property">message</span> = <span class="hljs-string">'Goodbye'</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">reversedMessage</span>) <span class="hljs-comment">// =&gt; 'eybdooG'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can open the console and play with the example vm yourself. The value of <code>vm.reversedMessage</code> is
    always dependent on the value of <code>vm.message</code>.</p>
<p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that
    <code>vm.reversedMessage</code> depends on <code>vm.message</code>, so it will update any bindings that depend on
    <code>vm.reversedMessage</code> when <code>vm.message</code> changes. And the best part is that we’ve created this
    dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to
    test and understand.</p>
<h3 id="Computed-Caching-vs-Methods"><a href="#Computed-Caching-vs-Methods" class="headerlink"
        title="Computed Caching vs Methods" data-scroll="">Computed Caching vs Methods</a></h3>
<p>You may have noticed we can achieve the same result by invoking a method in the expression:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Reversed message: "{{ reverseMessage() }}"<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// in component</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">''</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches
    are indeed exactly the same. However, the difference is that <strong>computed properties are cached based on their
        reactive dependencies.</strong> A computed property will only re-evaluate when some of its reactive dependencies
    have changed. This means as long as <code>message</code> has not changed, multiple access to the
    <code>reversedMessage</code> computed property will immediately return the previously computed result without having
    to run the function again.</p>
<p>This also means the following computed property will never update, because <code>Date.now()</code> is not a reactive
    dependency:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">now</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In comparison, a method invocation will <strong>always</strong> run the function whenever a re-render happens.</p>
<p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping
    through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend
    on <strong>A</strong>. Without caching, we would be executing <strong>A</strong>’s getter many more times than
    necessary! In cases where you do not want caching, use a method instead.</p>
<h3 id="Computed-vs-Watched-Property"><a href="#Computed-vs-Watched-Property" class="headerlink"
        title="Computed vs Watched Property" data-scroll="">Computed vs Watched Property</a></h3>
<p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch
        properties</strong>. When you have some data that needs to change based on some other data, it is tempting to
    overuse <code>watch</code> - especially if you are coming from an AngularJS background. However, it is often a
    better idea to use a computed property rather than an imperative <code>watch</code> callback. Consider this example:
</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>&gt;</span>{{ fullName }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Foo'</span>,<br> <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bar'</span>,<br> <span class="hljs-attr">fullName</span>: <span class="hljs-string">'Foo Bar'</span><br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = val + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> },<br> <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + val<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above code is imperative and repetitive. Compare it with a computed property version:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Foo'</span>,<br> <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bar'</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Much better, isn’t it?</p>
<h3 id="Computed-Setter"><a href="#Computed-Setter" class="headerlink" title="Computed Setter" data-scroll="">Computed
        Setter</a></h3>
<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">fullName</span>: {<br> <span class="hljs-comment">// getter</span><br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br> },<br> <span class="hljs-comment">// setter</span><br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) {<br> <span class="hljs-keyword">var</span> names = newValue.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = names[<span class="hljs-number">0</span>]<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = names[names.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br> }<br> }<br>}<br><span class="hljs-comment">// ...</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now when you run <code>vm.fullName = 'John Doe'</code>, the setter will be invoked and <code>vm.firstName</code> and
    <code>vm.lastName</code> will be updated accordingly.</p>
<h2 id="Watchers"><a href="#Watchers" class="headerlink" title="Watchers" data-scroll="">Watchers</a></h2>
<p>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary.
    That’s why Vue provides a more generic way to react to data changes through the <code>watch</code> option. This is
    most useful when you want to perform asynchronous or expensive operations in response to changing data.</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"watch-example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br> Ask a yes/no question:<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"question"</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ answer }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;</span><br><span class="hljs-comment">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span><br><span class="hljs-comment">&lt;!-- is able to remain small by not reinventing them. This also --&gt;</span><br><span class="hljs-comment">&lt;!-- gives you the freedom to use what you're familiar with. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({</span><br><span class="language-javascript"> <span class="hljs-attr">el</span>: <span class="hljs-string">'#watch-example'</span>,</span><br><span class="language-javascript"> <span class="hljs-attr">data</span>: {</span><br><span class="language-javascript"> <span class="hljs-attr">question</span>: <span class="hljs-string">''</span>,</span><br><span class="language-javascript"> <span class="hljs-attr">answer</span>: <span class="hljs-string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">watch</span>: {</span><br><span class="language-javascript"> <span class="hljs-comment">// whenever question changes, this function will run</span></span><br><span class="language-javascript"> <span class="hljs-attr">question</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) {</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Waiting for you to stop typing...'</span></span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">debouncedGetAnswer</span>()</span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span><br><span class="language-javascript"> <span class="hljs-comment">// _.debounce is a function provided by lodash to limit how</span></span><br><span class="language-javascript"> <span class="hljs-comment">// often a particularly expensive operation can be run.</span></span><br><span class="language-javascript"> <span class="hljs-comment">// In this case, we want to limit how often we access</span></span><br><span class="language-javascript"> <span class="hljs-comment">// yesno.wtf/api, waiting until the user has completely</span></span><br><span class="language-javascript"> <span class="hljs-comment">// finished typing before making the ajax request. To learn</span></span><br><span class="language-javascript"> <span class="hljs-comment">// more about the _.debounce function (and its cousin</span></span><br><span class="language-javascript"> <span class="hljs-comment">// _.throttle), visit: https://lodash.com/docs#debounce</span></span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">debouncedGetAnswer</span> = _.<span class="hljs-title function_">debounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getAnswer</span>, <span class="hljs-number">500</span>)</span><br><span class="language-javascript"> },</span><br><span class="language-javascript"> <span class="hljs-attr">methods</span>: {</span><br><span class="language-javascript"> <span class="hljs-attr">getAnswer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span><br><span class="language-javascript"> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">question</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'?'</span>) === -<span class="hljs-number">1</span>) {</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="language-javascript"> <span class="hljs-keyword">return</span></span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">'Thinking...'</span></span><br><span class="language-javascript"> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span></span><br><span class="language-javascript"> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'https://yesno.wtf/api'</span>)</span><br><span class="language-javascript"> .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) {</span><br><span class="language-javascript"> vm.<span class="hljs-property">answer</span> = _.<span class="hljs-title function_">capitalize</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">answer</span>)</span><br><span class="language-javascript"> })</span><br><span class="language-javascript"> .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {</span><br><span class="language-javascript"> vm.<span class="hljs-property">answer</span> = <span class="hljs-string">'Error! Could not reach the API. '</span> + error</span><br><span class="language-javascript"> })</span><br><span class="language-javascript"> }</span><br><span class="language-javascript"> }</span><br><span class="language-javascript">})</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="watch-example" class="demo">
    <p> Ask a yes/no question: <input></p>
    <p>I cannot give you an answer until you ask a question!</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script> var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() } }, created: function () { this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)' return } this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api').then(function (response) { vm.answer = _.capitalize(response.data.answer) }).catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } } })</script>
<p>In this case, using the <code>watch</code> option allows us to perform an asynchronous operation (accessing an API),
    limit how often we perform that operation, and set intermediary states until we get a final answer. None of that
    would be possible with a computed property.</p>
<p>In addition to the <code>watch</code> option, you can also use the imperative <a href="../api/#vm-watch">vm.$watch
        API</a>.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/syntax.html">Template Syntax</a></span> <span
        style="float: right"><a href="/v2/guide/class-and-style.html">Class and Style Bindings</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Class and Style Bindings</h1>
<p>A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both
    attributes, we can use <code>v-bind</code> to handle them: we only need to calculate a final string with our
    expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides
    special enhancements when <code>v-bind</code> is used with <code>class</code> and <code>style</code>. In addition to
    strings, the expressions can also evaluate to objects or arrays.</p>
<h2 id="Binding-HTML-Classes"><a href="#Binding-HTML-Classes" class="headerlink" title="Binding HTML Classes"
        data-scroll="">Binding HTML Classes</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Dynamic Classes Lesson">Watch a free video lesson on Vue School</a>
</div>
<h3 id="Object-Syntax"><a href="#Object-Syntax" class="headerlink" title="Object Syntax" data-scroll="">Object
        Syntax</a></h3>
<p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"{ active: isActive }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a target="_blank"
        rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthiness</a> of the data
    property <code>isActive</code>.</p>
<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code>
    directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"static"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"{ active: isActive, 'text-danger': hasError }"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And the following data:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It will render:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"static active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When <code>isActive</code> or <code>hasError</code> changes, the class list will be updated accordingly. For example,
    if <code>hasError</code> becomes <code>true</code>, the class list will become
    <code>"static active text-danger"</code>.</p>
<p>The bound object doesn’t have to be inline:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"classObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">classObject</span>: {<br> <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-string">'text-danger'</span>: <span class="hljs-literal">false</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This will render the same result. We can also bind to a <a href="computed.html">computed property</a> that returns an
    object. This is a common and powerful pattern:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"classObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span><br>},<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">classObject</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">active</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span>,<br> <span class="hljs-string">'text-danger'</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span>.<span class="hljs-property">type</span> === <span class="hljs-string">'fatal'</span><br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Array-Syntax"><a href="#Array-Syntax" class="headerlink" title="Array Syntax" data-scroll="">Array Syntax</a>
</h3>
<p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"[activeClass, errorClass]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">activeClass</span>: <span class="hljs-string">'active'</span>,<br> <span class="hljs-attr">errorClass</span>: <span class="hljs-string">'text-danger'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Which will render:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active text-danger"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when
    <code>isActive</code> is truthy.</p>
<p>However, this can be a bit verbose if you have multiple conditional classes. That’s why it’s also possible to use the
    object syntax inside array syntax:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"[{ active: isActive }, errorClass]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="With-Components"><a href="#With-Components" class="headerlink" title="With Components" data-scroll="">With
        Components</a></h3>
<blockquote>
    <p>This section assumes knowledge of <a href="components.html">Vue Components</a>. Feel free to skip it and come
        back later.</p>
</blockquote>
<p>When you use the <code>class</code> attribute on a custom component, those classes will be added to the component’s
    root element. Existing classes on this element will not be overwritten.</p>
<p>For example, if you declare this component:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then add some classes when using it:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"baz boo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The rendered HTML will be:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"foo bar baz boo"</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The same is true for class bindings:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"{ active: isActive }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When <code>isActive</code> is truthy, the rendered HTML will be:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"foo bar active"</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Binding-Inline-Styles"><a href="#Binding-Inline-Styles" class="headerlink" title="Binding Inline Styles"
        data-scroll="">Binding Inline Styles</a></h2>
<h3 id="Object-Syntax-1"><a href="#Object-Syntax-1" class="headerlink" title="Object Syntax" data-scroll="">Object
        Syntax</a></h3>
<p>The object syntax for <code>v-bind:style</code> is pretty straightforward - it looks almost like CSS, except it’s a
    JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property
    names:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"{ color: activeColor, fontSize: fontSize + 'px' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">activeColor</span>: <span class="hljs-string">'red'</span>,<br> <span class="hljs-attr">fontSize</span>: <span class="hljs-number">30</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is often a good idea to bind to a style object directly so that the template is cleaner:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"styleObject"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">styleObject</span>: {<br> <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,<br> <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'13px'</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Again, the object syntax is often used in conjunction with computed properties that return objects.</p>
<h3 id="Array-Syntax-1"><a href="#Array-Syntax-1" class="headerlink" title="Array Syntax" data-scroll="">Array
        Syntax</a></h3>
<p>The array syntax for <code>v-bind:style</code> allows you to apply multiple style objects to the same element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Auto-prefixing"><a href="#Auto-prefixing" class="headerlink" title="Auto-prefixing"
        data-scroll="">Auto-prefixing</a></h3>
<p>When you use a CSS property that requires <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">vendor prefixes</a> in
    <code>v-bind:style</code>, for example <code>transform</code>, Vue will automatically detect and add appropriate
    prefixes to the applied styles.</p>
<h3 id="Multiple-Values"><a href="#Multiple-Values" class="headerlink" title="Multiple Values" data-scroll="">Multiple
        Values</a></h3>
<blockquote>
    <p>2.3.0+</p>
</blockquote>
<p>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This will only render the last value in the array which the browser supports. In this example, it will render
    <code>display: flex</code> for browsers that support the unprefixed version of flexbox.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/computed.html">Computed Properties and Watchers</a></span> <span
        style="float: right"><a href="/v2/guide/conditional.html">Conditional Rendering</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Conditional Rendering</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how conditional rendering works with Vue School">Learn how conditional
        rendering works with a free lesson on Vue School</a></div>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if" data-scroll=""><code>v-if</code></a></h2>
<p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the
    directive’s expression returns a truthy value.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is also possible to add an “else block” with <code>v-else</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Conditional-Groups-with-v-if-on-lt-template-gt"><a href="#Conditional-Groups-with-v-if-on-lt-template-gt"
        class="headerlink" title="Conditional Groups with v-if on <template>" data-scroll="">Conditional Groups with
        <code>v-if</code> on <code>&lt;template&gt;</code></a></h3>
<p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle
    more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which
    serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code>
    element.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ok"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else" data-scroll=""><code>v-else</code></a></h3>
<p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span><br> Now you see me<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Now you don't<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element -
    otherwise it will not be recognized.</p>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if" data-scroll=""><code>v-else-if</code></a>
</h3>
<blockquote>
    <p>New in 2.1.0+</p>
</blockquote>
<p>The <code>v-else-if</code>, as the name suggests, serves as an “else if block” for <code>v-if</code>. It can also be
    chained multiple times:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type === 'A'"</span>&gt;</span><br> A<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'B'"</span>&gt;</span><br> B<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'C'"</span>&gt;</span><br> C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Not A/B/C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a
    <code>v-else-if</code> element.</p>
<h3 id="Controlling-Reusable-Elements-with-key"><a href="#Controlling-Reusable-Elements-with-key" class="headerlink"
        title="Controlling Reusable Elements with key" data-scroll="">Controlling Reusable Elements with
        <code>key</code></a></h3>
<p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch.
    Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle
    between multiple login types:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since
    both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its
    <code>placeholder</code>.</p>
<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>
<div id="no-key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#no-key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate -
    don’t re-use them.” Add a <code>key</code> attribute with unique values:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"username-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"email-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>
<div id="key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don’t have
    <code>key</code> attributes.</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show" data-scroll=""><code>v-show</code></a></h2>
<p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the
    same:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM;
    <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>
<p class="tip">Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> element, nor does it work
    with <code>v-else</code>.</p>
<h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"
        data-scroll=""><code>v-if</code> vs <code>v-show</code></a></h2>
<p><code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside
    the conditional block are properly destroyed and re-created during toggles.</p>
<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything
    - the conditional block won’t be rendered until the condition becomes true for the first time.</p>
<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition,
    with CSS-based toggling.</p>
<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render
    costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the
    condition is unlikely to change at runtime.</p>
<h2 id="v-if-with-v-for"><a href="#v-if-with-v-for" class="headerlink" title="v-if with v-for"
        data-scroll=""><code>v-if</code> with <code>v-for</code></a></h2>
<p class="tip">Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a
        href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for further information.</p>
<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the
    <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/class-and-style.html">Class and Style Bindings</a></span> <span
        style="float: right"><a href="/v2/guide/list.html">List Rendering</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Conditional Rendering</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how conditional rendering works with Vue School">Learn how conditional
        rendering works with a free lesson on Vue School</a></div>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if" data-scroll=""><code>v-if</code></a></h2>
<p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the
    directive’s expression returns a truthy value.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is also possible to add an “else block” with <code>v-else</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Conditional-Groups-with-v-if-on-lt-template-gt"><a href="#Conditional-Groups-with-v-if-on-lt-template-gt"
        class="headerlink" title="Conditional Groups with v-if on <template>" data-scroll="">Conditional Groups with
        <code>v-if</code> on <code>&lt;template&gt;</code></a></h3>
<p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle
    more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which
    serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code>
    element.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ok"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else" data-scroll=""><code>v-else</code></a></h3>
<p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span><br> Now you see me<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Now you don't<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element -
    otherwise it will not be recognized.</p>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if" data-scroll=""><code>v-else-if</code></a>
</h3>
<blockquote>
    <p>New in 2.1.0+</p>
</blockquote>
<p>The <code>v-else-if</code>, as the name suggests, serves as an “else if block” for <code>v-if</code>. It can also be
    chained multiple times:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type === 'A'"</span>&gt;</span><br> A<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'B'"</span>&gt;</span><br> B<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'C'"</span>&gt;</span><br> C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Not A/B/C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a
    <code>v-else-if</code> element.</p>
<h3 id="Controlling-Reusable-Elements-with-key"><a href="#Controlling-Reusable-Elements-with-key" class="headerlink"
        title="Controlling Reusable Elements with key" data-scroll="">Controlling Reusable Elements with
        <code>key</code></a></h3>
<p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch.
    Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle
    between multiple login types:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since
    both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its
    <code>placeholder</code>.</p>
<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>
<div id="no-key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#no-key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate -
    don’t re-use them.” Add a <code>key</code> attribute with unique values:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"username-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"email-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>
<div id="key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don’t have
    <code>key</code> attributes.</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show" data-scroll=""><code>v-show</code></a></h2>
<p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the
    same:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM;
    <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>
<p class="tip">Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> element, nor does it work
    with <code>v-else</code>.</p>
<h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"
        data-scroll=""><code>v-if</code> vs <code>v-show</code></a></h2>
<p><code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside
    the conditional block are properly destroyed and re-created during toggles.</p>
<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything
    - the conditional block won’t be rendered until the condition becomes true for the first time.</p>
<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition,
    with CSS-based toggling.</p>
<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render
    costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the
    condition is unlikely to change at runtime.</p>
<h2 id="v-if-with-v-for"><a href="#v-if-with-v-for" class="headerlink" title="v-if with v-for"
        data-scroll=""><code>v-if</code> with <code>v-for</code></a></h2>
<p class="tip">Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a
        href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for further information.</p>
<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the
    <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/class-and-style.html">Class and Style Bindings</a></span> <span
        style="float: right"><a href="/v2/guide/list.html">List Rendering</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Conditional Rendering</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how conditional rendering works with Vue School">Learn how conditional
        rendering works with a free lesson on Vue School</a></div>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if" data-scroll=""><code>v-if</code></a></h2>
<p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the
    directive’s expression returns a truthy value.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is also possible to add an “else block” with <code>v-else</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"awesome"</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Conditional-Groups-with-v-if-on-lt-template-gt"><a href="#Conditional-Groups-with-v-if-on-lt-template-gt"
        class="headerlink" title="Conditional Groups with v-if on <template>" data-scroll="">Conditional Groups with
        <code>v-if</code> on <code>&lt;template&gt;</code></a></h3>
<p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle
    more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which
    serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code>
    element.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"ok"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else" data-scroll=""><code>v-else</code></a></h3>
<p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"Math.random() &gt; 0.5"</span>&gt;</span><br> Now you see me<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Now you don't<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element -
    otherwise it will not be recognized.</p>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if" data-scroll=""><code>v-else-if</code></a>
</h3>
<blockquote>
    <p>New in 2.1.0+</p>
</blockquote>
<p>The <code>v-else-if</code>, as the name suggests, serves as an “else if block” for <code>v-if</code>. It can also be
    chained multiple times:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type === 'A'"</span>&gt;</span><br> A<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'B'"</span>&gt;</span><br> B<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type === 'C'"</span>&gt;</span><br> C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br> Not A/B/C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a
    <code>v-else-if</code> element.</p>
<h3 id="Controlling-Reusable-Elements-with-key"><a href="#Controlling-Reusable-Elements-with-key" class="headerlink"
        title="Controlling Reusable Elements with key" data-scroll="">Controlling Reusable Elements with
        <code>key</code></a></h3>
<p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch.
    Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle
    between multiple login types:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since
    both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its
    <code>placeholder</code>.</p>
<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>
<div id="no-key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#no-key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate -
    don’t re-use them.” Add a <code>key</code> attribute with unique values:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"loginType === 'username'"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"username-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your email address"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"email-input"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>
<div id="key-example" class="demo">
    <div><label>Username</label> <input placeholder="Enter your username"></div> <button>Toggle login type</button>
</div>
<script> new Vue({ el: '#key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } })</script>
<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don’t have
    <code>key</code> attributes.</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show" data-scroll=""><code>v-show</code></a></h2>
<p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the
    same:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"ok"</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM;
    <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>
<p class="tip">Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> element, nor does it work
    with <code>v-else</code>.</p>
<h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"
        data-scroll=""><code>v-if</code> vs <code>v-show</code></a></h2>
<p><code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside
    the conditional block are properly destroyed and re-created during toggles.</p>
<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything
    - the conditional block won’t be rendered until the condition becomes true for the first time.</p>
<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition,
    with CSS-based toggling.</p>
<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render
    costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the
    condition is unlikely to change at runtime.</p>
<h2 id="v-if-with-v-for"><a href="#v-if-with-v-for" class="headerlink" title="v-if with v-for"
        data-scroll=""><code>v-if</code> with <code>v-for</code></a></h2>
<p class="tip">Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a
        href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for further information.</p>
<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the
    <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/class-and-style.html">Class and Style Bindings</a></span> <span
        style="float: right"><a href="/v2/guide/list.html">List Rendering</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>List Rendering</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-loops?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how to render lists on Vue School">Learn how to render list with a free
        Vue School lesson</a></div>
<h2 id="Mapping-an-Array-to-Elements-with-v-for"><a href="#Mapping-an-Array-to-Elements-with-v-for" class="headerlink"
        title="Mapping an Array to Elements with v-for" data-scroll="">Mapping an Array to Elements with
        <code>v-for</code></a></h2>
<p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code>
    directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the
    source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-1"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.message"</span>&gt;</span><br> {{ item.message }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-1'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Foo'</span> },<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Bar'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="example-1" class="demo">
    <li> Foo </li>
    <li> Bar </li>
</ul>
<script> var example1 = new Vue({ el: '#example-1', data: { items: [{ message: 'Foo' }, { message: 'Bar' }] } })</script>
<p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an
    optional second argument for the index of the current item.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-2"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span><br> {{ parentMessage }} - {{ index }} - {{ item.message }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-2'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">parentMessage</span>: <span class="hljs-string">'Parent'</span>,<br> <span class="hljs-attr">items</span>: [<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Foo'</span> },<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Bar'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="example-2" class="demo">
    <li> Parent - 0 - Foo </li>
    <li> Parent - 1 - Bar </li>
</ul>
<script> var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [{ message: 'Foo' }, { message: 'Bar' }] } })</script>
<p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript’s
    syntax for iterators:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item of items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-an-Object"><a href="#v-for-with-an-Object" class="headerlink" title="v-for with an Object"
        data-scroll=""><code>v-for</code> with an Object</a></h2>
<p>You can also use <code>v-for</code> to iterate through the properties of an object.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"v-for-object"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"value in object"</span>&gt;</span><br> {{ value }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#v-for-object'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">object</span>: {<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'How to do lists in Vue'</span>,<br> <span class="hljs-attr">author</span>: <span class="hljs-string">'Jane Doe'</span>,<br> <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">'2016-04-10'</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="v-for-object" class="demo">
    <li> How to do lists in Vue </li>
    <li> Jane Doe </li>
    <li> 2016-04-10 </li>
</ul>
<script> new Vue({ el: '#v-for-object', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p>You can also provide a second argument for the property’s name (a.k.a. key):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, name) in object"</span>&gt;</span><br> {{ name }}: {{ value }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="v-for-object-value-name" class="demo">
    <div> title: How to do lists in Vue </div>
    <div> author: Jane Doe </div>
    <div> publishedAt: 2016-04-10 </div>
</div>
<script> new Vue({ el: '#v-for-object-value-name', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p>And another for the index:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, name, index) in object"</span>&gt;</span><br> {{ index }}. {{ name }}: {{ value }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="v-for-object-value-name-index" class="demo">
    <div> 0. title: How to do lists in Vue </div>
    <div> 1. author: Jane Doe </div>
    <div> 2. publishedAt: 2016-04-10 </div>
</div>
<script> new Vue({ el: '#v-for-object-value-name-index', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p class="tip">When iterating over an object, the order is based on the enumeration order of <code>Object.keys()</code>,
    which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.</p>
<h2 id="Maintaining-State"><a href="#Maintaining-State" class="headerlink" title="Maintaining State"
        data-scroll="">Maintaining State</a></h2>
<p>When Vue is updating a list of elements rendered with <code>v-for</code>, by default it uses an “in-place patch”
    strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the
    items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular
    index. This is similar to the behavior of <code>track-by="$index"</code> in Vue 1.x.</p>
<p>This default mode is efficient, but <strong>only suitable when your list render output does not rely on child
        component state or temporary DOM state (e.g. form input values)</strong>.</p>
<p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need
    to provide a unique <code>key</code> attribute for each item:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- content --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the
    iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p>
<p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not
    specifically tied to <code>v-for</code>, as we will see later in the guide.</p>
<p class="tip">Don’t use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric
    values instead.</p>
<p>For detailed usage of the <code>key</code> attribute, please see the <a href="/v2/api/#key"><code>key</code> API
        documentation</a>.</p>
<h2 id="Array-Change-Detection"><a href="#Array-Change-Detection" class="headerlink" title="Array Change Detection"
        data-scroll="">Array Change Detection</a></h2>
<h3 id="Mutation-Methods"><a href="#Mutation-Methods" class="headerlink" title="Mutation Methods"
        data-scroll="">Mutation Methods</a></h3>
<p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p>
<ul>
    <li><code>push()</code></li>
    <li><code>pop()</code></li>
    <li><code>shift()</code></li>
    <li><code>unshift()</code></li>
    <li><code>splice()</code></li>
    <li><code>sort()</code></li>
    <li><code>reverse()</code></li>
</ul>
<p>You can open the console and play with the previous examples’ <code>items</code> array by calling their mutation
    methods. For example: <code>example1.items.push({ message: 'Baz' })</code>.</p>
<h3 id="Replacing-an-Array"><a href="#Replacing-an-Array" class="headerlink" title="Replacing an Array"
        data-scroll="">Replacing an Array</a></h3>
<p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also
    non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not
    mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods,
    you can replace the old array with the new one:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">example1.<span class="hljs-property">items</span> = example1.<span class="hljs-property">items</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {<br> <span class="hljs-keyword">return</span> item.<span class="hljs-property">message</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Foo/</span>)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is
    not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another
    array containing overlapping objects is a very efficient operation.</p>
<h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats" data-scroll="">Caveats</a></h3>
<p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong> with arrays and
    objects. These are discussed in the <a href="reactivity.html#Change-Detection-Caveats">reactivity</a> section.</p>
<h2 id="Displaying-Filtered-Sorted-Results"><a href="#Displaying-Filtered-Sorted-Results" class="headerlink"
        title="Displaying Filtered/Sorted Results" data-scroll="">Displaying Filtered/Sorted Results</a></h2>
<p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the
    original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in evenNumbers"</span>&gt;</span>{{ n }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">numbers</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>},<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">evenNumbers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) {<br> <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can use a
    method:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"set in sets"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in even(set)"</span>&gt;</span>{{ n }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">sets</span>: [[ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]<br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">even</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) {<br> <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) {<br> <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-a-Range"><a href="#v-for-with-a-Range" class="headerlink" title="v-for with a Range"
        data-scroll=""><code>v-for</code> with a Range</a></h2>
<p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in 10"</span>&gt;</span>{{ n }} <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="range" class="demo"><span>1 </span><span>2 </span><span>3 </span><span>4 </span><span>5 </span><span>6
    </span><span>7 </span><span>8 </span><span>9 </span><span>10 </span></div>
<script> new Vue({ el: '#range' })</script>
<h2 id="v-for-on-a-lt-template-gt"><a href="#v-for-on-a-lt-template-gt" class="headerlink" title="v-for on a <template>"
        data-scroll=""><code>v-for</code> on a <code>&lt;template&gt;</code></a></h2>
<p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code>
    to render a block of multiple elements. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{{ item.msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"divider"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"presentation"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"
        data-scroll=""><code>v-for</code> with <code>v-if</code></a></h2>
<p class="tip">Note that it’s <strong>not</strong> recommended to use <code>v-if</code> and <code>v-for</code> together.
    Refer to <a href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for details.</p>
<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the
    <code>v-if</code> will be run on each iteration of the loop separately. This can be useful when you want to render
    nodes for only <em>some</em> items, like below:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in todos"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!todo.isComplete"</span>&gt;</span><br> {{ todo }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above only renders the todos that are not complete.</p>
<p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a
    wrapper element (or <a
        href="conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt"><code>&lt;template&gt;</code></a>). For
    example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todos.length"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in todos"</span>&gt;</span><br> {{ todo }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No todos left!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-a-Component"><a href="#v-for-with-a-Component" class="headerlink" title="v-for with a Component"
        data-scroll=""><code>v-for</code> with a Component</a></h2>
<blockquote>
    <p>This section assumes knowledge of <a href="components.html">Components</a>. Feel free to skip it and come back
        later.</p>
</blockquote>
<p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<blockquote>
    <p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href="list.html#key"><code>key</code></a> is now
        required.</p>
</blockquote>
<p>However, this won’t automatically pass any data to the component, because components have isolated scopes of their
    own. In order to pass the iterated data into the component, we should also use props:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component
    tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component
    reusable in other situations.</p>
<p>Here’s a complete example of a simple todo list:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todo-list-example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">"addNewTodo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"new-todo"</span>&gt;</span>Add a todo<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"newTodoText"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">id</span>=<span class="hljs-string">"new-todo"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"E.g. Feed the cat"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag"> <span class="hljs-attr">is</span>=<span class="hljs-string">"todo-item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(todo, index) in todos"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"todo.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"todo.title"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:remove</span>=<span class="hljs-string">"todos.splice(index, 1)"</span></span><br><span class="hljs-tag"> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Note the <code>is="todo-item"</code> attribute. This is necessary in DOM templates, because only an
    <code>&lt;li&gt;</code> element is valid inside a <code>&lt;ul&gt;</code>. It does the same thing as
    <code>&lt;todo-item&gt;</code>, but works around a potential browser parsing error. See <a
        href="components.html#DOM-Template-Parsing-Caveats">DOM Template Parsing Caveats</a> to learn more.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'todo-item'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'\</span><br><span class="hljs-string"> &lt;li&gt;\</span><br><span class="hljs-string"> {{ title }}\</span><br><span class="hljs-string"> &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span><br><span class="hljs-string"> &lt;/li&gt;\</span><br><span class="hljs-string"> '</span>,<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>]<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#todo-list-example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">newTodoText</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">todos</span>: [<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Do the dishes'</span>,<br> },<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Take out the trash'</span>,<br> },<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Mow the lawn'</span><br> }<br> ],<br> <span class="hljs-attr">nextTodoId</span>: <span class="hljs-number">4</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">addNewTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>({<br> <span class="hljs-attr">id</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextTodoId</span>++,<br> <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span><br> })<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span> = <span class="hljs-string">''</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="todo-list-example" class="demo">
    <form><label for="new-todo">Add a todo</label> <input id="new-todo" placeholder="E.g. Feed the cat">
        <button>Add</button></form>
    <ul>
        <li> Do the dishes <button>Remove</button></li>
        <li> Take out the trash <button>Remove</button></li>
        <li> Mow the lawn <button>Remove</button></li>
    </ul>
</div>
<script> Vue.component('todo-item', { template: '\ <li>\ {{ title }}\ <button v-on:click="$emit(\'remove\')">Remove</button>\ </li>\ ', props: ['title'] }) new Vue({ el: '#todo-list-example', data: { newTodoText: '', todos: [{ id: 1, title: 'Do the dishes', }, { id: 2, title: 'Take out the trash', }, { id: 3, title: 'Mow the lawn' }], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = '' } } })</script>
<div class="guide-links"> <span>← <a href="/v2/guide/conditional.html">Conditional Rendering</a></span> <span
        style="float: right"><a href="/v2/guide/events.html">Event Handling</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>List Rendering</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-loops?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how to render lists on Vue School">Learn how to render list with a free
        Vue School lesson</a></div>
<h2 id="Mapping-an-Array-to-Elements-with-v-for"><a href="#Mapping-an-Array-to-Elements-with-v-for" class="headerlink"
        title="Mapping an Array to Elements with v-for" data-scroll="">Mapping an Array to Elements with
        <code>v-for</code></a></h2>
<p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code>
    directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the
    source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-1"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.message"</span>&gt;</span><br> {{ item.message }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-1'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Foo'</span> },<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Bar'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="example-1" class="demo">
    <li> Foo </li>
    <li> Bar </li>
</ul>
<script> var example1 = new Vue({ el: '#example-1', data: { items: [{ message: 'Foo' }, { message: 'Bar' }] } })</script>
<p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an
    optional second argument for the index of the current item.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-2"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span><br> {{ parentMessage }} - {{ index }} - {{ item.message }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-2'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">parentMessage</span>: <span class="hljs-string">'Parent'</span>,<br> <span class="hljs-attr">items</span>: [<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Foo'</span> },<br> { <span class="hljs-attr">message</span>: <span class="hljs-string">'Bar'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="example-2" class="demo">
    <li> Parent - 0 - Foo </li>
    <li> Parent - 1 - Bar </li>
</ul>
<script> var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [{ message: 'Foo' }, { message: 'Bar' }] } })</script>
<p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript’s
    syntax for iterators:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item of items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-an-Object"><a href="#v-for-with-an-Object" class="headerlink" title="v-for with an Object"
        data-scroll=""><code>v-for</code> with an Object</a></h2>
<p>You can also use <code>v-for</code> to iterate through the properties of an object.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"v-for-object"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"value in object"</span>&gt;</span><br> {{ value }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#v-for-object'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">object</span>: {<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'How to do lists in Vue'</span>,<br> <span class="hljs-attr">author</span>: <span class="hljs-string">'Jane Doe'</span>,<br> <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">'2016-04-10'</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<ul id="v-for-object" class="demo">
    <li> How to do lists in Vue </li>
    <li> Jane Doe </li>
    <li> 2016-04-10 </li>
</ul>
<script> new Vue({ el: '#v-for-object', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p>You can also provide a second argument for the property’s name (a.k.a. key):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, name) in object"</span>&gt;</span><br> {{ name }}: {{ value }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="v-for-object-value-name" class="demo">
    <div> title: How to do lists in Vue </div>
    <div> author: Jane Doe </div>
    <div> publishedAt: 2016-04-10 </div>
</div>
<script> new Vue({ el: '#v-for-object-value-name', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p>And another for the index:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, name, index) in object"</span>&gt;</span><br> {{ index }}. {{ name }}: {{ value }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="v-for-object-value-name-index" class="demo">
    <div> 0. title: How to do lists in Vue </div>
    <div> 1. author: Jane Doe </div>
    <div> 2. publishedAt: 2016-04-10 </div>
</div>
<script> new Vue({ el: '#v-for-object-value-name-index', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } })</script>
<p class="tip">When iterating over an object, the order is based on the enumeration order of <code>Object.keys()</code>,
    which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.</p>
<h2 id="Maintaining-State"><a href="#Maintaining-State" class="headerlink" title="Maintaining State"
        data-scroll="">Maintaining State</a></h2>
<p>When Vue is updating a list of elements rendered with <code>v-for</code>, by default it uses an “in-place patch”
    strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the
    items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular
    index. This is similar to the behavior of <code>track-by="$index"</code> in Vue 1.x.</p>
<p>This default mode is efficient, but <strong>only suitable when your list render output does not rely on child
        component state or temporary DOM state (e.g. form input values)</strong>.</p>
<p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need
    to provide a unique <code>key</code> attribute for each item:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- content --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the
    iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p>
<p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not
    specifically tied to <code>v-for</code>, as we will see later in the guide.</p>
<p class="tip">Don’t use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric
    values instead.</p>
<p>For detailed usage of the <code>key</code> attribute, please see the <a href="/v2/api/#key"><code>key</code> API
        documentation</a>.</p>
<h2 id="Array-Change-Detection"><a href="#Array-Change-Detection" class="headerlink" title="Array Change Detection"
        data-scroll="">Array Change Detection</a></h2>
<h3 id="Mutation-Methods"><a href="#Mutation-Methods" class="headerlink" title="Mutation Methods"
        data-scroll="">Mutation Methods</a></h3>
<p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p>
<ul>
    <li><code>push()</code></li>
    <li><code>pop()</code></li>
    <li><code>shift()</code></li>
    <li><code>unshift()</code></li>
    <li><code>splice()</code></li>
    <li><code>sort()</code></li>
    <li><code>reverse()</code></li>
</ul>
<p>You can open the console and play with the previous examples’ <code>items</code> array by calling their mutation
    methods. For example: <code>example1.items.push({ message: 'Baz' })</code>.</p>
<h3 id="Replacing-an-Array"><a href="#Replacing-an-Array" class="headerlink" title="Replacing an Array"
        data-scroll="">Replacing an Array</a></h3>
<p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also
    non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not
    mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods,
    you can replace the old array with the new one:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">example1.<span class="hljs-property">items</span> = example1.<span class="hljs-property">items</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {<br> <span class="hljs-keyword">return</span> item.<span class="hljs-property">message</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Foo/</span>)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is
    not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another
    array containing overlapping objects is a very efficient operation.</p>
<h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats" data-scroll="">Caveats</a></h3>
<p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong> with arrays and
    objects. These are discussed in the <a href="reactivity.html#Change-Detection-Caveats">reactivity</a> section.</p>
<h2 id="Displaying-Filtered-Sorted-Results"><a href="#Displaying-Filtered-Sorted-Results" class="headerlink"
        title="Displaying Filtered/Sorted Results" data-scroll="">Displaying Filtered/Sorted Results</a></h2>
<p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the
    original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in evenNumbers"</span>&gt;</span>{{ n }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">numbers</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>},<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">evenNumbers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) {<br> <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can use a
    method:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"set in sets"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in even(set)"</span>&gt;</span>{{ n }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">sets</span>: [[ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]<br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">even</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) {<br> <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) {<br> <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-a-Range"><a href="#v-for-with-a-Range" class="headerlink" title="v-for with a Range"
        data-scroll=""><code>v-for</code> with a Range</a></h2>
<p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"n in 10"</span>&gt;</span>{{ n }} <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="range" class="demo"><span>1 </span><span>2 </span><span>3 </span><span>4 </span><span>5 </span><span>6
    </span><span>7 </span><span>8 </span><span>9 </span><span>10 </span></div>
<script> new Vue({ el: '#range' })</script>
<h2 id="v-for-on-a-lt-template-gt"><a href="#v-for-on-a-lt-template-gt" class="headerlink" title="v-for on a <template>"
        data-scroll=""><code>v-for</code> on a <code>&lt;template&gt;</code></a></h2>
<p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code>
    to render a block of multiple elements. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{{ item.msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"divider"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"presentation"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"
        data-scroll=""><code>v-for</code> with <code>v-if</code></a></h2>
<p class="tip">Note that it’s <strong>not</strong> recommended to use <code>v-if</code> and <code>v-for</code> together.
    Refer to <a href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for details.</p>
<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the
    <code>v-if</code> will be run on each iteration of the loop separately. This can be useful when you want to render
    nodes for only <em>some</em> items, like below:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in todos"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!todo.isComplete"</span>&gt;</span><br> {{ todo }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above only renders the todos that are not complete.</p>
<p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a
    wrapper element (or <a
        href="conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt"><code>&lt;template&gt;</code></a>). For
    example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todos.length"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in todos"</span>&gt;</span><br> {{ todo }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No todos left!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-for-with-a-Component"><a href="#v-for-with-a-Component" class="headerlink" title="v-for with a Component"
        data-scroll=""><code>v-for</code> with a Component</a></h2>
<blockquote>
    <p>This section assumes knowledge of <a href="components.html">Components</a>. Feel free to skip it and come back
        later.</p>
</blockquote>
<p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<blockquote>
    <p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href="list.html#key"><code>key</code></a> is now
        required.</p>
</blockquote>
<p>However, this won’t automatically pass any data to the component, because components have isolated scopes of their
    own. In order to pass the iterated data into the component, we should also use props:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component
    tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component
    reusable in other situations.</p>
<p>Here’s a complete example of a simple todo list:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todo-list-example"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">"addNewTodo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"new-todo"</span>&gt;</span>Add a todo<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"newTodoText"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">id</span>=<span class="hljs-string">"new-todo"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"E.g. Feed the cat"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag"> <span class="hljs-attr">is</span>=<span class="hljs-string">"todo-item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(todo, index) in todos"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"todo.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"todo.title"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:remove</span>=<span class="hljs-string">"todos.splice(index, 1)"</span></span><br><span class="hljs-tag"> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Note the <code>is="todo-item"</code> attribute. This is necessary in DOM templates, because only an
    <code>&lt;li&gt;</code> element is valid inside a <code>&lt;ul&gt;</code>. It does the same thing as
    <code>&lt;todo-item&gt;</code>, but works around a potential browser parsing error. See <a
        href="components.html#DOM-Template-Parsing-Caveats">DOM Template Parsing Caveats</a> to learn more.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'todo-item'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'\</span><br><span class="hljs-string"> &lt;li&gt;\</span><br><span class="hljs-string"> {{ title }}\</span><br><span class="hljs-string"> &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span><br><span class="hljs-string"> &lt;/li&gt;\</span><br><span class="hljs-string"> '</span>,<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>]<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#todo-list-example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">newTodoText</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">todos</span>: [<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Do the dishes'</span>,<br> },<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Take out the trash'</span>,<br> },<br> {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'Mow the lawn'</span><br> }<br> ],<br> <span class="hljs-attr">nextTodoId</span>: <span class="hljs-number">4</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">addNewTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>({<br> <span class="hljs-attr">id</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextTodoId</span>++,<br> <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span><br> })<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span> = <span class="hljs-string">''</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="todo-list-example" class="demo">
    <form><label for="new-todo">Add a todo</label> <input id="new-todo" placeholder="E.g. Feed the cat">
        <button>Add</button></form>
    <ul>
        <li> Do the dishes <button>Remove</button></li>
        <li> Take out the trash <button>Remove</button></li>
        <li> Mow the lawn <button>Remove</button></li>
    </ul>
</div>
<script> Vue.component('todo-item', { template: '\ <li>\ {{ title }}\ <button v-on:click="$emit(\'remove\')">Remove</button>\ </li>\ ', props: ['title'] }) new Vue({ el: '#todo-list-example', data: { newTodoText: '', todos: [{ id: 1, title: 'Do the dishes', }, { id: 2, title: 'Take out the trash', }, { id: 3, title: 'Mow the lawn' }], nextTodoId: 4 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = '' } } })</script>
<div class="guide-links"> <span>← <a href="/v2/guide/conditional.html">Conditional Rendering</a></span> <span
        style="float: right"><a href="/v2/guide/events.html">Event Handling</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Event Handling</h1>
<div class="vueschool"><a href="https://vueschool.io/lessons/vuejs-user-events?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Learn how to handle events on Vue School">Learn how to handle events in a free
        Vue School lesson</a></div>
<h2 id="Listening-to-Events"><a href="#Listening-to-Events" class="headerlink" title="Listening to Events"
        data-scroll="">Listening to Events</a></h2>
<p>We can use the <code>v-on</code> directive to listen to DOM events and run some JavaScript when they’re triggered.
</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-1"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"counter += 1"</span>&gt;</span>Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked {{ counter }} times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-1'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="example-1" class="demo"><button>Add 1</button>
    <p>The button above has been clicked 0 times.</p>
</div>
<script> var example1 = new Vue({ el: '#example-1', data: { counter: 0 } })</script>
<h2 id="Method-Event-Handlers"><a href="#Method-Event-Handlers" class="headerlink" title="Method Event Handlers"
        data-scroll="">Method Event Handlers</a></h2>
<p>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the
    <code>v-on</code> attribute isn’t feasible. That’s why <code>v-on</code> can also accept the name of a method you’d
    like to call.</p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-2"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- `greet` is the name of a method defined below --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"greet"</span>&gt;</span>Greet<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> example2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-2'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">name</span>: <span class="hljs-string">'Vue.js'</span><br> },<br> <span class="hljs-comment">// define methods under the `methods` object</span><br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {<br> <span class="hljs-comment">// `this` inside methods points to the Vue instance</span><br> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hello '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">'!'</span>)<br> <span class="hljs-comment">// `event` is the native DOM event</span><br> <span class="hljs-keyword">if</span> (event) {<br> <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>)<br> }<br> }<br> }<br>})<br><br><span class="hljs-comment">// you can invoke methods in JavaScript too</span><br>example2.<span class="hljs-title function_">greet</span>() <span class="hljs-comment">// =&gt; 'Hello Vue.js!'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p>
<div id="example-2" class="demo"><button>Greet</button></div>
<script> var example2 = new Vue({ el: '#example-2', data: { name: 'Vue.js' }, methods: { greet: function (event) { alert('Hello ' + this.name + '!') if (event) { alert(event.target.tagName) } } } })</script>
<h2 id="Methods-in-Inline-Handlers"><a href="#Methods-in-Inline-Handlers" class="headerlink"
        title="Methods in Inline Handlers" data-scroll="">Methods in Inline Handlers</a></h2>
<p>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-3"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"say('hi')"</span>&gt;</span>Say hi<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"say('what')"</span>&gt;</span>Say what<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-3'</span>,<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) {<br> <span class="hljs-title function_">alert</span>(message)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:<br> </p>
<div id="example-3" class="demo"><button>Say hi</button> <button>Say what</button></div>
<script> new Vue({ el: '#example-3', methods: { say: function (message) { alert(message) } } })</script>
<p></p>
<p>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method
    using the special <code>$event</code> variable:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span><br> Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">warn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">message, event</span>) {<br> <span class="hljs-comment">// now we have access to the native event</span><br> <span class="hljs-keyword">if</span> (event) {<br> event.<span class="hljs-title function_">preventDefault</span>()<br> }<br> <span class="hljs-title function_">alert</span>(message)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Event-Modifiers"><a href="#Event-Modifiers" class="headerlink" title="Event Modifiers" data-scroll="">Event
        Modifiers</a></h2>
<p>It is a very common need to call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> inside
    event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about
    data logic rather than having to deal with DOM event details.</p>
<p>To address this problem, Vue provides <strong>event modifiers</strong> for <code>v-on</code>. Recall that modifiers
    are directive postfixes denoted by a dot.</p>
<ul>
    <li><code>.stop</code></li>
    <li><code>.prevent</code></li>
    <li><code>.capture</code></li>
    <li><code>.self</code></li>
    <li><code>.once</code></li>
    <li><code>.passive</code></li>
</ul>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- the click event's propagation will be stopped --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- the submit event will no longer reload the page --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">"onSubmit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- modifiers can be chained --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">"doThat"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- just the modifier --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- use capture mode when adding the event listener --&gt;</span><br><span class="hljs-comment">&lt;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.capture</span>=<span class="hljs-string">"doThis"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span><br><span class="hljs-comment">&lt;!-- i.e. not from a child element --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.self</span>=<span class="hljs-string">"doThat"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Order matters when using modifiers because the relevant code is generated in the same order. Therefore
    using <code>v-on:click.prevent.self</code> will prevent <strong>all clicks</strong> while
    <code>v-on:click.self.prevent</code> will only prevent clicks on the element itself.</p>
<blockquote>
    <p>New in 2.1.4+</p>
</blockquote>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- the click event will be triggered at most once --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be
    used on <a href="components-custom-events.html">component events</a>. If you haven’t read about components yet,
    don’t worry about this for now.</p>
<blockquote>
    <p>New in 2.3.0+</p>
</blockquote>
<p>Vue also offers the <code>.passive</code> modifier, corresponding to <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters"><code>addEventListener</code>‘s
        <code>passive</code> option</a>.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- the scroll event's default behavior (scrolling) will happen --&gt;</span><br><span class="hljs-comment">&lt;!-- immediately, instead of waiting for `onScroll` to complete --&gt;</span><br><span class="hljs-comment">&lt;!-- in case it contains `event.preventDefault()` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:scroll.passive</span>=<span class="hljs-string">"onScroll"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The <code>.passive</code> modifier is especially useful for improving performance on mobile devices.</p>
<p class="tip">Don’t use <code>.passive</code> and <code>.prevent</code> together, because <code>.prevent</code> will be
    ignored and your browser will probably show you a warning. Remember, <code>.passive</code> communicates to the
    browser that you <em>don’t</em> want to prevent the event’s default behavior.</p>
<h2 id="Key-Modifiers"><a href="#Key-Modifiers" class="headerlink" title="Key Modifiers" data-scroll="">Key
        Modifiers</a></h2>
<p>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for
    <code>v-on</code> when listening for key events:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">"submit"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can directly use any valid key names exposed via <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a>
    as modifiers by converting them to kebab-case.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.page-down</span>=<span class="hljs-string">"onPageDown"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the above example, the handler will only be called if <code>$event.key</code> is equal to <code>'PageDown'</code>.
</p>
<h3 id="Key-Codes"><a href="#Key-Codes" class="headerlink" title="Key Codes" data-scroll="">Key Codes</a></h3>
<p class="tip">The use of <code>keyCode</code> events <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">is deprecated</a> and may not be
    supported in new browsers.</p>
<p>Using <code>keyCode</code> attributes is also permitted:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.13</span>=<span class="hljs-string">"submit"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</p>
<ul>
    <li><code>.enter</code></li>
    <li><code>.tab</code></li>
    <li><code>.delete</code> (captures both “Delete” and “Backspace” keys)</li>
    <li><code>.esc</code></li>
    <li><code>.space</code></li>
    <li><code>.up</code></li>
    <li><code>.down</code></li>
    <li><code>.left</code></li>
    <li><code>.right</code></li>
</ul>
<p class="tip">A few keys (<code>.esc</code> and all arrow keys) have inconsistent <code>key</code> values in IE9, so
    these built-in aliases should be preferred if you need to support IE9.</p>
<p>You can also <a href="../api/#keyCodes">define custom key modifier aliases</a> via the global
    <code>config.keyCodes</code> object:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// enable `v-on:keyup.f1`</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">keyCodes</span>.<span class="hljs-property">f1</span> = <span class="hljs-number">112</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="System-Modifier-Keys"><a href="#System-Modifier-Keys" class="headerlink" title="System Modifier Keys"
        data-scroll="">System Modifier Keys</a></h2>
<blockquote>
    <p>New in 2.1.0+</p>
</blockquote>
<p>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier
    key is pressed:</p>
<ul>
    <li><code>.ctrl</code></li>
    <li><code>.alt</code></li>
    <li><code>.shift</code></li>
    <li><code>.meta</code></li>
</ul>
<blockquote>
    <p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On
        Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and
        Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled
        “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>
</blockquote>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Alt + C --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.alt.67</span>=<span class="hljs-string">"clear"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Ctrl + Click --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.ctrl</span>=<span class="hljs-string">"doSomething"</span>&gt;</span>Do something<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Note that modifier keys are different from regular keys and when used with <code>keyup</code> events,
    they have to be pressed when the event is emitted. In other words, <code>keyup.ctrl</code> will only trigger if you
    release a key while holding down <code>ctrl</code>. It won’t trigger if you release the <code>ctrl</code> key alone.
    If you do want such behaviour, use the <code>keyCode</code> for <code>ctrl</code> instead: <code>keyup.17</code>.
</p>
<h3 id="exact-Modifier"><a href="#exact-Modifier" class="headerlink" title=".exact Modifier"
        data-scroll=""><code>.exact</code> Modifier</a></h3>
<blockquote>
    <p>New in 2.5.0+</p>
</blockquote>
<p>The <code>.exact</code> modifier allows control of the exact combination of system modifiers needed to trigger an
    event.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- this will fire even if Alt or Shift is also pressed --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl</span>=<span class="hljs-string">"onClick"</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- this will only fire when Ctrl and no other keys are pressed --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl.exact</span>=<span class="hljs-string">"onCtrlClick"</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- this will only fire when no system modifiers are pressed --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.exact</span>=<span class="hljs-string">"onClick"</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Mouse-Button-Modifiers"><a href="#Mouse-Button-Modifiers" class="headerlink" title="Mouse Button Modifiers"
        data-scroll="">Mouse Button Modifiers</a></h3>
<blockquote>
    <p>New in 2.2.0+</p>
</blockquote>
<ul>
    <li><code>.left</code></li>
    <li><code>.right</code></li>
    <li><code>.middle</code></li>
</ul>
<p>These modifiers restrict the handler to events triggered by a specific mouse button.</p>
<h2 id="Why-Listeners-in-HTML"><a href="#Why-Listeners-in-HTML" class="headerlink" title="Why Listeners in HTML?"
        data-scroll="">Why Listeners in HTML?</a></h2>
<p>You might be concerned that this whole event listening approach violates the good old rules about “separation of
    concerns”. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that’s
    handling the current view, it won’t cause any maintenance difficulty. In fact, there are several benefits in using
    <code>v-on</code>:</p>
<ol>
    <li>
        <p>It’s easier to locate the handler function implementations within your JS code by skimming the HTML template.
        </p>
    </li>
    <li>
        <p>Since you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and
            DOM-free. This makes it easier to test.</p>
    </li>
    <li>
        <p>When a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about
            cleaning it up yourself.</p>
    </li>
</ol>
<div class="guide-links"> <span>← <a href="/v2/guide/list.html">List Rendering</a></span> <span style="float: right"><a
            href="/v2/guide/forms.html">Form Input Bindings</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Form Input Bindings</h1>
<h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage" data-scroll="">Basic Usage</a></h2>
<p>You can use the <code>v-model</code> directive to create two-way data bindings on form input, textarea, and select
    elements. It automatically picks the correct way to update the element based on the input type. Although a bit
    magical, <code>v-model</code> is essentially syntax sugar for updating data on user input events, plus special care
    for some edge cases.</p>
<p class="tip"><code>v-model</code> will ignore the initial <code>value</code>, <code>checked</code>, or
    <code>selected</code> attributes found on any form elements. It will always treat the Vue instance data as the
    source of truth. You should declare the initial value on the JavaScript side, inside the <code>data</code> option of
    your component.</p>
<p><code>v-model</code> internally uses different properties and emits different events for different input elements:
</p>
<ul>
    <li>text and textarea elements use <code>value</code> property and <code>input</code> event;</li>
    <li>checkboxes and radiobuttons use <code>checked</code> property and <code>change</code> event;</li>
    <li>select fields use <code>value</code> as a prop and <code>change</code> as an event.</li>
</ul>
<p class="tip" id="vmodel-ime-tip">For languages that require an <a target="_blank" rel="noopener"
        href="https://en.wikipedia.org/wiki/Input_method">IME</a> (Chinese, Japanese, Korean, etc.), you’ll notice that
    <code>v-model</code> doesn’t get updated during IME composition. If you want to cater to these updates as well, use
    the <code>input</code> event instead.</p>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text" data-scroll="">Text</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"edit me"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Message is: {{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-1" class="demo"><input placeholder="edit me">
    <p>Message is: </p>
</div>
<script> new Vue({ el: '#example-1', data: { message: '' } })</script>
<h3 id="Multiline-text"><a href="#Multiline-text" class="headerlink" title="Multiline text" data-scroll="">Multiline
        text</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Multiline message is:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"white-space: pre-line;"</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"add multiple lines"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-textarea" class="demo"><span>Multiline message is:</span>
    <p style="white-space: pre-line;"></p> <br> <textarea placeholder="add multiple lines"></textarea>
</div>
<script> new Vue({ el: '#example-textarea', data: { message: '' } })</script>
<p class="tip">Interpolation on textareas (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) won't work. Use
    <code>v-model</code> instead.</p>
<h3 id="Checkbox"><a href="#Checkbox" class="headerlink" title="Checkbox" data-scroll="">Checkbox</a></h3>
<p>Single checkbox, boolean value:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checked"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"checkbox"</span>&gt;</span>{{ checked }}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-2" class="demo"><input type="checkbox" id="checkbox"> <label for="checkbox">false</label></div>
<script> new Vue({ el: '#example-2', data: { checked: false } })</script>
<p>Multiple checkboxes, bound to the same Array:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jack"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jack"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checkedNames"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"jack"</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"john"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"John"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checkedNames"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"john"</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mike"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Mike"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checkedNames"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"mike"</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Checked names: {{ checkedNames }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'...'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">checkedNames</span>: []<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-3" class="demo"><input type="checkbox" id="jack" value="Jack"> <label for="jack">Jack</label> <input
        type="checkbox" id="john" value="John"> <label for="john">John</label> <input type="checkbox" id="mike"
        value="Mike"> <label for="mike">Mike</label> <br> <span>Checked names: []</span></div>
<script> new Vue({ el: '#example-3', data: { checkedNames: [] } })</script>
<h3 id="Radio"><a href="#Radio" class="headerlink" title="Radio" data-scroll="">Radio</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"one"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"One"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"picked"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"one"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"two"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Two"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"picked"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"two"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Picked: {{ picked }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-4" class="demo"><input type="radio" id="one" value="One"> <label for="one">One</label> <br> <input
        type="radio" id="two" value="Two"> <label for="two">Two</label> <br> <span>Picked: </span></div>
<script> new Vue({ el: '#example-4', data: { picked: '' } })</script>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select" data-scroll="">Select</a></h3>
<p>Single select:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>Please select one<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: {{ selected }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'...'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">selected</span>: <span class="hljs-string">''</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-5" class="demo"><select>
        <option disabled="disabled" value="">Please select one</option>
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select> <span>Selected: </span></div>
<script> new Vue({ el: '#example-5', data: { selected: '' } })</script>
<p class="tip">If the initial value of your <code>v-model</code> expression does not match any of the options, the
    <code>&lt;select&gt;</code> element will render in an “unselected” state. On iOS, this will prevent the user from
    being able to select the first item, because iOS does not fire a <code>change</code> event in this case. It is
    therefore recommended to provide a <code>disabled</code> option with an empty value, as demonstrated in the example
    above.</p>
<p>Multiple select (bound to Array):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span> <span class="hljs-attr">multiple</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: {{ selected }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-6" class="demo"><select multiple="multiple" style="width: 50px;">
        <option>A</option>
        <option>B</option>
        <option>C</option>
    </select> <br> <span>Selected: []</span></div>
<script> new Vue({ el: '#example-6', data: { selected: [] } })</script>
<p>Dynamic options rendered with <code>v-for</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"option in options"</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"option.value"</span>&gt;</span><br> {{ option.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: {{ selected }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'...'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">selected</span>: <span class="hljs-string">'A'</span>,<br> <span class="hljs-attr">options</span>: [<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'One'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'A'</span> },<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'Two'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'B'</span> },<br> { <span class="hljs-attr">text</span>: <span class="hljs-string">'Three'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'C'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-7" class="demo"><select>
        <option value="A"> One </option>
        <option value="B"> Two </option>
        <option value="C"> Three </option>
    </select> <span>Selected: A</span></div>
<script> new Vue({ el: '#example-7', data: { selected: 'A', options: [{ text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' }] } })</script>
<h2 id="Value-Bindings"><a href="#Value-Bindings" class="headerlink" title="Value Bindings" data-scroll="">Value
        Bindings</a></h2>
<p>For radio, checkbox and select options, the <code>v-model</code> binding values are usually static strings (or
    booleans for checkboxes):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- `picked` is a string "a" when checked --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"picked"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"a"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- `toggle` is either true or false --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"toggle"</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- `selected` is a string "abc" when the first option is selected --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"abc"</span>&gt;</span>ABC<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>But sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use
    <code>v-bind</code> to achieve that. In addition, using <code>v-bind</code> allows us to bind the input value to
    non-string values.</p>
<h3 id="Checkbox-1"><a href="#Checkbox-1" class="headerlink" title="Checkbox" data-scroll="">Checkbox</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"toggle"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">true-value</span>=<span class="hljs-string">"yes"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">false-value</span>=<span class="hljs-string">"no"</span></span><br><span class="hljs-tag">&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// when checked:</span><br>vm.<span class="hljs-property">toggle</span> === <span class="hljs-string">'yes'</span><br><span class="hljs-comment">// when unchecked:</span><br>vm.<span class="hljs-property">toggle</span> === <span class="hljs-string">'no'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">The <code>true-value</code> and <code>false-value</code> attributes don’t affect the input’s
    <code>value</code> attribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that
    one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.</p>
<h3 id="Radio-1"><a href="#Radio-1" class="headerlink" title="Radio" data-scroll="">Radio</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"pick"</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"a"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// when checked:</span><br>vm.<span class="hljs-property">pick</span> === vm.<span class="hljs-property">a</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Select-Options"><a href="#Select-Options" class="headerlink" title="Select Options" data-scroll="">Select
        Options</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- inline object literal --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"{ number: 123 }"</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// when selected:</span><br><span class="hljs-keyword">typeof</span> vm.<span class="hljs-property">selected</span> <span class="hljs-comment">// =&gt; 'object'</span><br>vm.<span class="hljs-property">selected</span>.<span class="hljs-property">number</span> <span class="hljs-comment">// =&gt; 123</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers" data-scroll="">Modifiers</a></h2>
<h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy" data-scroll=""><code>.lazy</code></a></h3>
<p>By default, <code>v-model</code> syncs the input with the data after each <code>input</code> event (with the
    exception of IME composition, as <a href="#vmodel-ime-tip">stated above</a>). You can add the <code>lazy</code>
    modifier to instead sync <em>after</em> <code>change</code> events:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- synced after "change" instead of "input" --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"msg"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="number"><a href="#number" class="headerlink" title=".number" data-scroll=""><code>.number</code></a></h3>
<p>If you want user input to be automatically typecast as a Number, you can add the <code>number</code> modifier to your
    <code>v-model</code> managed inputs:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This is often useful, because even with <code>type="number"</code>, the value of HTML input elements always returns a
    string. If the value cannot be parsed with <code>parseFloat()</code>, then the original value is returned.</p>
<h3 id="trim"><a href="#trim" class="headerlink" title=".trim" data-scroll=""><code>.trim</code></a></h3>
<p>If you want whitespace from user input to be trimmed automatically, you can add the <code>trim</code> modifier to
    your <code>v-model</code>-managed inputs:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">"msg"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="v-model-with-Components"><a href="#v-model-with-Components" class="headerlink" title="v-model with Components"
        data-scroll=""><code>v-model</code> with Components</a></h2>
<blockquote>
    <p>If you’re not yet familiar with Vue’s components, you can skip this for now.</p>
</blockquote>
<p>HTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable
    inputs with completely customized behavior. These inputs even work with <code>v-model</code>!</p>
<p>To learn more, read about <a href="components.html#Using-v-model-on-Components">custom inputs</a> in the Components
    guide.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/events.html">Event Handling</a></span> <span
        style="float: right"><a href="/v2/guide/components.html">Components Basics</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Components Basics</h1>
<div class="vueschool"><a href="https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Components Fundamentals Course">Watch a free video course on Vue
        School</a></div>
<h2 id="Base-Example"><a href="#Base-Example" class="headerlink" title="Base Example" data-scroll="">Base Example</a>
</h2>
<p>Here’s an example of a Vue component:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Define a new component called button-counter</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'button-counter'</span>, {<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br> }<br> },<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;button v-on:click="count++"&gt;You clicked me {{ count }} times.&lt;/button&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Components are reusable Vue instances with a name: in this case, <code>&lt;button-counter&gt;</code>. We can use this
    component as a custom element inside a root Vue instance created with <code>new Vue</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"components-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({ <span class="hljs-attr">el</span>: <span class="hljs-string">'#components-demo'</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="components-demo" class="demo"><button>You clicked me 0 times.</button></div>
<script> Vue.component('button-counter', { data: function () { return { count: 0 } }, template: '<button v-on:click="count += 1">You clicked me {{ count }} times.</button>' }) new Vue({ el: '#components-demo' })</script>
<p>Since components are reusable Vue instances, they accept the same options as <code>new Vue</code>, such as
    <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks. The only
    exceptions are a few root-specific options like <code>el</code>.</p>
<h2 id="Reusing-Components"><a href="#Reusing-Components" class="headerlink" title="Reusing Components"
        data-scroll="">Reusing Components</a></h2>
<p>Components can be reused as many times as you want:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"components-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button-counter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-counter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="components-demo2" class="demo"><button>You clicked me 0 times.</button> <button>You clicked me 0
        times.</button> <button>You clicked me 0 times.</button></div>
<script> new Vue({ el: '#components-demo2' })</script>
<p>Notice that when clicking on the buttons, each one maintains its own, separate <code>count</code>. That’s because
    each time you use a component, a new <strong>instance</strong> of it is created.</p>
<h3 id="data-Must-Be-a-Function"><a href="#data-Must-Be-a-Function" class="headerlink" title="data Must Be a Function"
        data-scroll=""><code>data</code> Must Be a Function</a></h3>
<p>When we defined the <code>&lt;button-counter&gt;</code> component, you may have noticed that <code>data</code> wasn’t
    directly provided an object, like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Instead, <strong>a component’s <code>data</code> option must be a function</strong>, so that each instance can
    maintain an independent copy of the returned data object:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If Vue didn’t have this rule, clicking on one button would affect the data of <em>all other instances</em>, like
    below:</p>
<div id="components-demo3" class="demo"><button>You clicked me 0 times.</button> <button>You clicked me 0
        times.</button> <button>You clicked me 0 times.</button></div>
<script> var buttonCounter2Data = { count: 0 } Vue.component('button-counter2', { data: function () { return buttonCounter2Data }, template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>' }) new Vue({ el: '#components-demo3' })</script>
<h2 id="Organizing-Components"><a href="#Organizing-Components" class="headerlink" title="Organizing Components"
        data-scroll="">Organizing Components</a></h2>
<p>It’s common for an app to be organized into a tree of nested components:</p>
<p><img src="/images/components.png" alt="Component Tree"></p>
<p>For example, you might have components for a header, sidebar, and content area, each typically containing other
    components for navigation links, blog posts, etc.</p>
<p>To use these components in templates, they must be registered so that Vue knows about them. There are two types of
    component registration: <strong>global</strong> and <strong>local</strong>. So far, we’ve only registered components
    globally, using <code>Vue.component</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component-name'</span>, {<br> <span class="hljs-comment">// ... options ...</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Globally registered components can be used in the template of any root Vue instance (<code>new Vue</code>) created
    afterwards – and even inside all subcomponents of that Vue instance’s component tree.</p>
<p>That’s all you need to know about registration for now, but once you’ve finished reading this page and feel
    comfortable with its content, we recommend coming back later to read the full guide on <a
        href="components-registration.html">Component Registration</a>.</p>
<h2 id="Passing-Data-to-Child-Components-with-Props"><a href="#Passing-Data-to-Child-Components-with-Props"
        class="headerlink" title="Passing Data to Child Components with Props" data-scroll="">Passing Data to Child
        Components with Props</a></h2>
<p>Earlier, we mentioned creating a component for blog posts. The problem is, that component won’t be useful unless you
    can pass data to it, such as the title and content of the specific post we want to display. That’s where props come
    in.</p>
<p>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a
    property on that component instance. To pass a title to our blog post component, we can include it in the list of
    props this component accepts, using a <code>props</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'blog-post'</span>, {<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;h3&gt;{{ title }}&lt;/h3&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A component can have as many props as you’d like and by default, any value can be passed to any prop. In the template
    above, you’ll see that we can access this value on the component instance, just like with <code>data</code>.</p>
<p>Once a prop is registered, you can pass data to it as a custom attribute, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"My journey with Vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Blogging with Vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Why Vue is so fun"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="blog-post-demo" class="demo">
    <h3>My journey with Vue</h3>
    <h3>Blogging with Vue</h3>
    <h3>Why Vue is so fun</h3>
</div>
<script> Vue.component('blog-post1', { props: ['title'], template: '<h3>{{ title }}</h3>' }) new Vue({ el: '#blog-post-demo' })</script>
<p>In a typical app, however, you’ll likely have an array of posts in <code>data</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#blog-post-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">posts</span>: [<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'My journey with Vue'</span> },<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Blogging with Vue'</span> },<br> { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Why Vue is so fun'</span> }<br> ]<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then want to render a component for each one:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"post in posts"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"post.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"post.title"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Above, you’ll see that we can use <code>v-bind</code> to dynamically pass props. This is especially useful when you
    don’t know the exact content you’re going to render ahead of time, like when <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example">fetching
        posts from an API</a>.</p>
<p>That’s all you need to know about props for now, but once you’ve finished reading this page and feel comfortable with
    its content, we recommend coming back later to read the full guide on <a href="components-props.html">Props</a>.</p>
<h2 id="A-Single-Root-Element"><a href="#A-Single-Root-Element" class="headerlink" title="A Single Root Element"
        data-scroll="">A Single Root Element</a></h2>
<p>When building out a <code>&lt;blog-post&gt;</code> component, your template will eventually contain more than just
    the title:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>At the very least, you’ll want to include the post’s content:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you try this in your template, however, Vue will show an error, explaining that <strong>every component must have
        a single root element</strong>. You can fix this error by wrapping the template in a parent element, such as:
</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"blog-post"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>As our component grows, it’s likely we’ll not only need the title and content of a post, but also the published date,
    comments, and more. Defining a prop for each related piece of information could become very annoying:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"post in posts"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"post.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"post.title"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:content</span>=<span class="hljs-string">"post.content"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:publishedAt</span>=<span class="hljs-string">"post.publishedAt"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:comments</span>=<span class="hljs-string">"post.comments"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>So this might be a good time to refactor the <code>&lt;blog-post&gt;</code> component to accept a single
    <code>post</code> prop instead:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"post in posts"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"post.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:post</span>=<span class="hljs-string">"post"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'blog-post'</span>, {<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'post'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;div class="blog-post"&gt;</span><br><span class="hljs-string"> &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span><br><span class="hljs-string"> &lt;div v-html="post.content"&gt;&lt;/div&gt;</span><br><span class="hljs-string"> &lt;/div&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">The above example and some future ones use JavaScript’s <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal</a>
    to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must
    support IE and are not transpiling (e.g. with Babel or TypeScript), use <a target="_blank" rel="noopener"
        href="https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/">newline escapes</a>
    instead.</p>
<p>Now, whenever a new property is added to <code>post</code> objects, it will automatically be available inside
    <code>&lt;blog-post&gt;</code>.</p>
<h2 id="Listening-to-Child-Components-Events"><a href="#Listening-to-Child-Components-Events" class="headerlink"
        title="Listening to Child Components Events" data-scroll="">Listening to Child Components Events</a></h2>
<p>As we develop our <code>&lt;blog-post&gt;</code> component, some features may require communicating back up to the
    parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while
    leaving the rest of the page its default size:</p>
<p>In the parent, we can support this feature by adding a <code>postFontSize</code> data property:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#blog-posts-events-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">posts</span>: [<span class="hljs-comment">/* ... */</span>],<br> <span class="hljs-attr">postFontSize</span>: <span class="hljs-number">1</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Which can be used in the template to control the font size of all blog posts:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"blog-posts-events-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"{ fontSize: postFontSize + 'em' }"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"post in posts"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"post.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:post</span>=<span class="hljs-string">"post"</span></span><br><span class="hljs-tag"> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now let’s add a button to enlarge the text right before the content of every post:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'blog-post'</span>, {<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'post'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;div class="blog-post"&gt;</span><br><span class="hljs-string"> &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span><br><span class="hljs-string"> &lt;button&gt;</span><br><span class="hljs-string"> Enlarge text</span><br><span class="hljs-string"> &lt;/button&gt;</span><br><span class="hljs-string"> &lt;div v-html="post.content"&gt;&lt;/div&gt;</span><br><span class="hljs-string"> &lt;/div&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The problem is, this button doesn’t do anything:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span><br> Enlarge text<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts.
    Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to
    any event on the child component instance with <code>v-on</code>, just as we would with a native DOM event:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">...</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enlarge-text</span>=<span class="hljs-string">"postFontSize += 0.1"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then the child component can emit an event on itself by calling the built-in <a
        href="../api/#vm-emit"><strong><code>$emit</code></strong> method</a>, passing the name of the event:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"$emit('enlarge-text')"</span>&gt;</span><br> Enlarge text<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Thanks to the <code>v-on:enlarge-text="postFontSize += 0.1"</code> listener, the parent will receive the event and
    update <code>postFontSize</code> value.</p>
<div id="blog-posts-events-demo" class="demo">
    <div style="font-size: 1em;">
        <div class="blog-post">
            <h3>My journey with Vue</h3> <button> Enlarge text </button>
            <div>...content...</div>
        </div>
        <div class="blog-post">
            <h3>Blogging with Vue</h3> <button> Enlarge text </button>
            <div>...content...</div>
        </div>
        <div class="blog-post">
            <h3>Why Vue is so fun</h3> <button> Enlarge text </button>
            <div>...content...</div>
        </div>
    </div>
</div>
<script> Vue.component('blog-post', { props: ['post'], template: '\ <div class="blog-post">\ <h3>{{ post.title }}</h3>\ <button v-on:click="$emit(\'enlarge-text\')">\ Enlarge text\ </button>\ <div v-html="post.content"></div>\ </div>\ ' }) new Vue({ el: '#blog-posts-events-demo', data: { posts: [{ id: 1, title: 'My journey with Vue', content: '...content...' }, { id: 2, title: 'Blogging with Vue', content: '...content...' }, { id: 3, title: 'Why Vue is so fun', content: '...content...' }], postFontSize: 1 } })</script>
<h3 id="Emitting-a-Value-With-an-Event"><a href="#Emitting-a-Value-With-an-Event" class="headerlink"
        title="Emitting a Value With an Event" data-scroll="">Emitting a Value With an Event</a></h3>
<p>It’s sometimes useful to emit a specific value with an event. For example, we may want the
    <code>&lt;blog-post&gt;</code> component to be in charge of how much to enlarge the text by. In those cases, we can
    use <code>$emit</code>‘s 2nd parameter to provide this value:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"$emit('enlarge-text', 0.1)"</span>&gt;</span><br> Enlarge text<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then when we listen to the event in the parent, we can access the emitted event’s value with <code>$event</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">...</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enlarge-text</span>=<span class="hljs-string">"postFontSize += $event"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or, if the event handler is a method:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">...</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enlarge-text</span>=<span class="hljs-string">"onEnlargeText"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then the value will be passed as the first parameter of that method:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">onEnlargeText</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">enlargeAmount</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">postFontSize</span> += enlargeAmount<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Using-v-model-on-Components"><a href="#Using-v-model-on-Components" class="headerlink"
        title="Using v-model on Components" data-scroll="">Using <code>v-model</code> on Components</a></h3>
<p>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember that:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"searchText"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>does the same thing as:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"searchText"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">"searchText = $event.target.value"</span></span><br><span class="hljs-tag">&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When used on a component, <code>v-model</code> instead does this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"searchText"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">"searchText = $event"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For this to actually work though, the <code>&lt;input&gt;</code> inside the component must:</p>
<ul>
    <li>Bind the <code>value</code> attribute to a <code>value</code> prop</li>
    <li>On <code>input</code>, emit its own custom <code>input</code> event with the new value</li>
</ul>
<p>Here’s that in action:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'custom-input'</span>, {<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'value'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;input</span><br><span class="hljs-string"> v-bind:value="value"</span><br><span class="hljs-string"> v-on:input="$emit('input', $event.target.value)"</span><br><span class="hljs-string"> &gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now <code>v-model</code> should work perfectly with this component:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"searchText"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That’s all you need to know about custom component events for now, but once you’ve finished reading this page and
    feel comfortable with its content, we recommend coming back later to read the full guide on <a
        href="components-custom-events.html">Custom Events</a>.</p>
<h2 id="Content-Distribution-with-Slots"><a href="#Content-Distribution-with-Slots" class="headerlink"
        title="Content Distribution with Slots" data-scroll="">Content Distribution with Slots</a></h2>
<p>Just like with HTML elements, it’s often useful to be able to pass content to a component, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">alert-box</span>&gt;</span><br> Something bad happened.<br><span class="hljs-tag">&lt;/<span class="hljs-name">alert-box</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Which might render something like:</p>
<div id="slots-demo" class="demo">
    <div class="demo-alert-box"><strong>Error!</strong> Something bad happened. </div>
</div>
<script> Vue.component('alert-box', { template: '\ <div class="demo-alert-box">\ <strong>Error!</strong>\ <slot></slot>\ </div>\ ' }) new Vue({ el: '#slots-demo' })</script>
<style>
    .demo-alert-box {
        padding: 10px 20px;
        background: #f3beb8;
        border: 1px solid #f09898;
    }
</style>
<p>Fortunately, this task is made very simple by Vue’s custom <code>&lt;slot&gt;</code> element:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'alert-box'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;div class="demo-alert-box"&gt;</span><br><span class="hljs-string"> &lt;strong&gt;Error!&lt;/strong&gt;</span><br><span class="hljs-string"> &lt;slot&gt;&lt;/slot&gt;</span><br><span class="hljs-string"> &lt;/div&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>As you’ll see above, we just add the slot where we want it to go – and that’s it. We’re done!</p>
<p>That’s all you need to know about slots for now, but once you’ve finished reading this page and feel comfortable with
    its content, we recommend coming back later to read the full guide on <a href="components-slots.html">Slots</a>.</p>
<h2 id="Dynamic-Components"><a href="#Dynamic-Components" class="headerlink" title="Dynamic Components"
        data-scroll="">Dynamic Components</a></h2>
<p>Sometimes, it’s useful to dynamically switch between components, like in a tabbed interface:</p>
<div id="dynamic-component-demo" class="demo"><button
        class="dynamic-component-demo-tab-button dynamic-component-demo-tab-button-active"> Home </button><button
        class="dynamic-component-demo-tab-button"> Posts </button><button class="dynamic-component-demo-tab-button">
        Archive </button>
    <div class="dynamic-component-demo-tab">Home component</div>
</div>
<script> Vue.component('tab-home', { template: '<div>Home component</div>' }) Vue.component('tab-posts', { template: '<div>Posts component</div>' }) Vue.component('tab-archive', { template: '<div>Archive component</div>' }) new Vue({ el: '#dynamic-component-demo', data: { currentTab: 'Home', tabs: ['Home', 'Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } })</script>
<style>
    .dynamic-component-demo-tab-button {
        padding: 6px 10px;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
        border: 1px solid #ccc;
        cursor: pointer;
        background: #f0f0f0;
        margin-bottom: -1px;
        margin-right: -1px;
    }

    .dynamic-component-demo-tab-button:hover {
        background: #e0e0e0;
    }

    .dynamic-component-demo-tab-button-active {
        background: #e0e0e0;
    }

    .dynamic-component-demo-tab {
        border: 1px solid #ccc;
        padding: 10px;
    }
</style>
<p>The above is made possible by Vue’s <code>&lt;component&gt;</code> element with the <code>is</code> special
    attribute:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Component changes when currentTabComponent changes --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the example above, <code>currentTabComponent</code> can contain either:</p>
<ul>
    <li>the name of a registered component, or</li>
    <li>a component’s options object</li>
</ul>
<p>See <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components">this
        example</a> to experiment with the full code, or <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding">this
        version</a> for an example binding to a component’s options object, instead of its registered name.</p>
<p>Keep in mind that this attribute can be used with regular HTML elements, however they will be treated as components,
    which means all attributes <strong>will be bound as DOM attributes</strong>. For some properties such as
    <code>value</code> to work as you would expect, you will need to bind them using the <a
        href="../api/#v-bind"><code>.prop</code> modifier</a>.</p>
<p>That’s all you need to know about dynamic components for now, but once you’ve finished reading this page and feel
    comfortable with its content, we recommend coming back later to read the full guide on <a
        href="components-dynamic-async.html">Dynamic &amp; Async Components</a>.</p>
<h2 id="DOM-Template-Parsing-Caveats"><a href="#DOM-Template-Parsing-Caveats" class="headerlink"
        title="DOM Template Parsing Caveats" data-scroll="">DOM Template Parsing Caveats</a></h2>
<p>Some HTML elements, such as <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> and
    <code>&lt;select&gt;</code> have restrictions on what elements can appear inside them, and some elements such as
    <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code>, and <code>&lt;option&gt;</code> can only appear inside certain
    other elements.</p>
<p>This will lead to issues when using components with elements that have such restrictions. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">blog-post-row</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post-row</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The custom component <code>&lt;blog-post-row&gt;</code> will be hoisted out as invalid content, causing errors in the
    eventual rendered output. Fortunately, the <code>is</code> special attribute offers a workaround:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"blog-post-row"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It should be noted that <strong>this limitation does <em>not</em> apply if you are using string templates from one of
        the following sources</strong>:</p>
<ul>
    <li>String templates (e.g. <code>template: '...'</code>)</li>
    <li><a href="single-file-components.html">Single-file (<code>.vue</code>) components</a></li>
    <li><a href="components-edge-cases.html#X-Templates"><code>&lt;script type="text/x-template"&gt;</code></a></li>
</ul>
<p>That’s all you need to know about DOM template parsing caveats for now – and actually, the end of Vue’s
    <em>Essentials</em>. Congratulations! There’s still more to learn, but first, we recommend taking a break to play
    with Vue yourself and build something fun.</p>
<p>Once you feel comfortable with the knowledge you’ve just digested, we recommend coming back to read the full guide on
    <a href="components-dynamic-async.html">Dynamic &amp; Async Components</a>, as well as the other pages in the
    Components In-Depth section of the sidebar.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/forms.html">Form Input Bindings</a></span> <span
        style="float: right"><a href="/v2/guide/components-registration.html">Component Registration</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Component Registration</h1>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<div class="vueschool"><a href="https://vueschool.io/lessons/global-vs-local-components?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Component Registration lesson">Watch a free video lesson on Vue
        School</a></div>
<h2 id="Component-Names"><a href="#Component-Names" class="headerlink" title="Component Names" data-scroll="">Component
        Names</a></h2>
<p>When registering a component, it will always be given a name. For example, in the global registration we’ve seen so
    far:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component-name'</span>, { <span class="hljs-comment">/* ... */</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The component’s name is the first argument of <code>Vue.component</code>.</p>
<p>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM
    (as opposed to in a string template or <a href="single-file-components.html">single-file component</a>), we strongly
    recommend following the <a target="_blank" rel="noopener"
        href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C rules</a> for
    custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML
    elements.</p>
<p>You can see other recommendations for component names in the <a
        href="../style-guide/#Base-component-names-strongly-recommended">Style Guide</a>.</p>
<h3 id="Name-Casing"><a href="#Name-Casing" class="headerlink" title="Name Casing" data-scroll="">Name Casing</a></h3>
<p>You have two options when defining component names:</p>
<h4 id="With-kebab-case"><a href="#With-kebab-case" class="headerlink" title="With kebab-case"></a>With kebab-case</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component-name'</span>, { <span class="hljs-comment">/* ... */</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as
    in <code>&lt;my-component-name&gt;</code>.</p>
<h4 id="With-PascalCase"><a href="#With-PascalCase" class="headerlink" title="With PascalCase"></a>With PascalCase</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'MyComponentName'</span>, { <span class="hljs-comment">/* ... */</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When defining a component with PascalCase, you can use either case when referencing its custom element. That means
    both <code>&lt;my-component-name&gt;</code> and <code>&lt;MyComponentName&gt;</code> are acceptable. Note, however,
    that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</p>
<h2 id="Global-Registration"><a href="#Global-Registration" class="headerlink" title="Global Registration"
        data-scroll="">Global Registration</a></h2>
<p>So far, we’ve only created components using <code>Vue.component</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component-name'</span>, {<br> <span class="hljs-comment">// ... options ...</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>These components are <strong>globally registered</strong>. That means they can be used in the template of any root
    Vue instance (<code>new Vue</code>) created after registration. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'component-a'</span>, { <span class="hljs-comment">/* ... */</span> })<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'component-b'</span>, { <span class="hljs-comment">/* ... */</span> })<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'component-c'</span>, { <span class="hljs-comment">/* ... */</span> })<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({ <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component-a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component-b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-b</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component-c</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-c</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This even applies to all subcomponents, meaning all three of these components will also be available <em>inside each
        other</em>.</p>
<h2 id="Local-Registration"><a href="#Local-Registration" class="headerlink" title="Local Registration"
        data-scroll="">Local Registration</a></h2>
<p>Global registration often isn’t ideal. For example, if you’re using a build system like Webpack, globally registering
    all components means that even if you stop using a component, it could still be included in your final build. This
    unnecessarily increases the amount of JavaScript your users have to download.</p>
<p>In these cases, you can define your components as plain JavaScript objects:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">ComponentA</span> = { <span class="hljs-comment">/* ... */</span> }<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">ComponentB</span> = { <span class="hljs-comment">/* ... */</span> }<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">ComponentC</span> = { <span class="hljs-comment">/* ... */</span> }<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then define the components you’d like to use in a <code>components</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-string">'component-a'</span>: <span class="hljs-title class_">ComponentA</span>,<br> <span class="hljs-string">'component-b'</span>: <span class="hljs-title class_">ComponentB</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For each property in the <code>components</code> object, the key will be the name of the custom element, while the
    value will contain the options object for the component.</p>
<p>Note that <strong>locally registered components are <em>not</em> also available in subcomponents</strong>. For
    example, if you wanted <code>ComponentA</code> to be available in <code>ComponentB</code>, you’d have to use:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">ComponentA</span> = { <span class="hljs-comment">/* ... */</span> }<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">ComponentB</span> = {<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-string">'component-a'</span>: <span class="hljs-title class_">ComponentA</span><br> },<br> <span class="hljs-comment">// ...</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or if you’re using ES2015 modules, such as through Babel and Webpack, that might look more like:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA.vue'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-title class_">ComponentA</span><br> },<br> <span class="hljs-comment">// ...</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that in ES2015+, placing a variable name like <code>ComponentA</code> inside an object is shorthand for
    <code>ComponentA: ComponentA</code>, meaning the name of the variable is both:</p>
<ul>
    <li>the custom element name to use in the template, and</li>
    <li>the name of the variable containing the component options</li>
</ul>
<h2 id="Module-Systems"><a href="#Module-Systems" class="headerlink" title="Module Systems" data-scroll="">Module
        Systems</a></h2>
<p>If you’re not using a module system with <code>import</code>/<code>require</code>, you can probably skip this section
    for now. If you are, we have some special instructions and tips just for you.</p>
<h3 id="Local-Registration-in-a-Module-System"><a href="#Local-Registration-in-a-Module-System" class="headerlink"
        title="Local Registration in a Module System" data-scroll="">Local Registration in a Module System</a></h3>
<p>If you’re still here, then it’s likely you’re using a module system, such as with Babel and Webpack. In these cases,
    we recommend creating a <code>components</code> directory, with each component in its own file.</p>
<p>Then you’ll need to import each component you’d like to use, before you locally register it. For example, in a
    hypothetical <code>ComponentB.js</code> or <code>ComponentB.vue</code> file:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentA'</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentC</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./ComponentC'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-title class_">ComponentA</span>,<br> <span class="hljs-title class_">ComponentC</span><br> },<br> <span class="hljs-comment">// ...</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now both <code>ComponentA</code> and <code>ComponentC</code> can be used inside <code>ComponentB</code>‘s template.
</p>
<h3 id="Automatic-Global-Registration-of-Base-Components"><a href="#Automatic-Global-Registration-of-Base-Components"
        class="headerlink" title="Automatic Global Registration of Base Components" data-scroll="">Automatic Global
        Registration of Base Components</a></h3>
<p>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We
    sometimes refer to these as <a href="../style-guide/#Base-component-names-strongly-recommended">base components</a>
    and they tend to be used very frequently across your components.</p>
<p>The result is that many components may include long lists of base components:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseButton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./BaseButton.vue'</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseIcon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./BaseIcon.vue'</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseInput</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./BaseInput.vue'</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-title class_">BaseButton</span>,<br> <span class="hljs-title class_">BaseIcon</span>,<br> <span class="hljs-title class_">BaseInput</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Just to support relatively little markup in a template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">BaseInput</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"searchText"</span></span><br><span class="hljs-tag"> @<span class="hljs-attr">keydown.enter</span>=<span class="hljs-string">"search"</span></span><br><span class="hljs-tag">/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BaseButton</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"search"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">BaseIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"search"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BaseButton</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Fortunately, if you’re using Webpack (or <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-cli">Vue CLI 3+</a>, which uses Webpack internally), you can use
    <code>require.context</code> to globally register only these very common base components. Here’s an example of the
    code you might use to globally import base components in your app’s entry file (e.g. <code>src/main.js</code>):</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> upperFirst <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/upperFirst'</span><br><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash/camelCase'</span><br><br><span class="hljs-keyword">const</span> requireComponent = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<br> <span class="hljs-comment">// The relative path of the components folder</span><br> <span class="hljs-string">'./components'</span>,<br> <span class="hljs-comment">// Whether or not to look in subfolders</span><br> <span class="hljs-literal">false</span>,<br> <span class="hljs-comment">// The regular expression used to match base component filenames</span><br> <span class="hljs-regexp">/Base[A-Z]\w+\.(vue|js)$/</span><br>)<br><br>requireComponent.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> {<br> <span class="hljs-comment">// Get component config</span><br> <span class="hljs-keyword">const</span> componentConfig = requireComponent(fileName)<br><br> <span class="hljs-comment">// Get PascalCase name of component</span><br> <span class="hljs-keyword">const</span> componentName = <span class="hljs-title function_">upperFirst</span>(<br> <span class="hljs-title function_">camelCase</span>(<br> <span class="hljs-comment">// Gets the file name regardless of folder depth</span><br> fileName<br> .<span class="hljs-title function_">split</span>(<span class="hljs-string">'/'</span>)<br> .<span class="hljs-title function_">pop</span>()<br> .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">''</span>)<br> )<br> )<br><br><br> <span class="hljs-comment">// Register component globally</span><br> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<br> componentName,<br> <span class="hljs-comment">// Look for the component options on `.default`, which will</span><br> <span class="hljs-comment">// exist if the component was exported with `export default`,</span><br> <span class="hljs-comment">// otherwise fall back to module's root.</span><br> componentConfig.<span class="hljs-property">default</span> || componentConfig<br> )<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Remember that <strong>global registration must take place before the root Vue instance is created (with
        <code>new Vue</code>)</strong>. <a target="_blank" rel="noopener"
        href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">Here’s
        an example</a> of this pattern in a real project context.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/components.html">Components Basics</a></span> <span
        style="float: right"><a href="/v2/guide/components-props.html">Props</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Props</h1>
<script> const __pageRedirects = { '#Non-Prop-Attributes': '/guide/components/attrs.html' }</script>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<div class="vueschool"><a href="https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs"
        target="_blank" rel="sponsored noopener" title="Learn how component props work with Vue School">Learn how
        component props work with a free lesson on Vue School</a></div>
<h2 id="Prop-Casing-camelCase-vs-kebab-case"><a href="#Prop-Casing-camelCase-vs-kebab-case" class="headerlink"
        title="Prop Casing (camelCase vs kebab-case)" data-scroll="">Prop Casing (camelCase vs kebab-case)</a></h2>
<p>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That
    means when you’re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited)
    equivalents:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'blog-post'</span>, {<br> <span class="hljs-comment">// camelCase in JavaScript</span><br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'postTitle'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- kebab-case in HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">post-title</span>=<span class="hljs-string">"hello!"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Again, if you’re using string templates, this limitation does not apply.</p>
<h2 id="Prop-Types"><a href="#Prop-Types" class="headerlink" title="Prop Types" data-scroll="">Prop Types</a></h2>
<p>So far, we’ve only seen props listed as an array of strings:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>, <span class="hljs-string">'likes'</span>, <span class="hljs-string">'isPublished'</span>, <span class="hljs-string">'commentIds'</span>, <span class="hljs-string">'author'</span>]<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Usually though, you’ll want every prop to be a specific type of value. In these cases, you can list props as an
    object, where the properties’ names and values contain the prop names and types, respectively:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br> <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">isPublished</span>: <span class="hljs-title class_">Boolean</span>,<br> <span class="hljs-attr">commentIds</span>: <span class="hljs-title class_">Array</span>,<br> <span class="hljs-attr">author</span>: <span class="hljs-title class_">Object</span>,<br> <span class="hljs-attr">callback</span>: <span class="hljs-title class_">Function</span>,<br> <span class="hljs-attr">contactsPromise</span>: <span class="hljs-title class_">Promise</span> <span class="hljs-comment">// or any other constructor</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This not only documents your component, but will also warn users in the browser’s JavaScript console if they pass the
    wrong type. You’ll learn much more about <a href="#Prop-Validation">type checks and other prop validations</a>
    further down this page.</p>
<h2 id="Passing-Static-or-Dynamic-Props"><a href="#Passing-Static-or-Dynamic-Props" class="headerlink"
        title="Passing Static or Dynamic Props" data-scroll="">Passing Static or Dynamic Props</a></h2>
<p>So far, you’ve seen props passed a static value, like in:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"My journey with Vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You’ve also seen props assigned dynamically with <code>v-bind</code>, such as in:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Dynamically assign the value of a variable --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"post.title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dynamically assign the value of a complex expression --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"post.title + ' by ' + post.author.name"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the two examples above, we happen to pass string values, but <em>any</em> type of value can actually be passed to
    a prop.</p>
<h3 id="Passing-a-Number"><a href="#Passing-a-Number" class="headerlink" title="Passing a Number" data-scroll="">Passing
        a Number</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Even though `42` is static, we need v-bind to tell Vue that --&gt;</span><br><span class="hljs-comment">&lt;!-- this is a JavaScript expression rather than a string. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">"42"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">"post.likes"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Passing-a-Boolean"><a href="#Passing-a-Boolean" class="headerlink" title="Passing a Boolean"
        data-scroll="">Passing a Boolean</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Including the prop with no value will imply `true`. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">is-published</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Even though `false` is static, we need v-bind to tell Vue that --&gt;</span><br><span class="hljs-comment">&lt;!-- this is a JavaScript expression rather than a string. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">"false"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">"post.isPublished"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Passing-an-Array"><a href="#Passing-an-Array" class="headerlink" title="Passing an Array" data-scroll="">Passing
        an Array</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Even though the array is static, we need v-bind to tell Vue that --&gt;</span><br><span class="hljs-comment">&lt;!-- this is a JavaScript expression rather than a string. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">"[234, 266, 273]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">"post.commentIds"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Passing-an-Object"><a href="#Passing-an-Object" class="headerlink" title="Passing an Object"
        data-scroll="">Passing an Object</a></h3>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Even though the object is static, we need v-bind to tell Vue that --&gt;</span><br><span class="hljs-comment">&lt;!-- this is a JavaScript expression rather than a string. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">"{</span></span><br><span class="hljs-string"><span class="hljs-tag"> name: 'Veronica',</span></span><br><span class="hljs-string"><span class="hljs-tag"> company: 'Veridian Dynamics'</span></span><br><span class="hljs-string"><span class="hljs-tag"> }"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">"post.author"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Passing-the-Properties-of-an-Object"><a href="#Passing-the-Properties-of-an-Object" class="headerlink"
        title="Passing the Properties of an Object" data-scroll="">Passing the Properties of an Object</a></h3>
<p>If you want to pass all the properties of an object as props, you can use <code>v-bind</code> without an argument
    (<code>v-bind</code> instead of <code>v-bind:prop-name</code>). For example, given a <code>post</code> object:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">post</span>: {<br> <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br> <span class="hljs-attr">title</span>: <span class="hljs-string">'My Journey with Vue'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The following template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"post"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Will be equivalent to:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"post.id"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"post.title"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="One-Way-Data-Flow"><a href="#One-Way-Data-Flow" class="headerlink" title="One-Way Data Flow"
        data-scroll="">One-Way Data Flow</a></h2>
<p>All props form a <strong>one-way-down binding</strong> between the child property and the parent one: when the parent
    property updates, it will flow down to the child, but not the other way around. This prevents child components from
    accidentally mutating the parent’s state, which can make your app’s data flow harder to understand.</p>
<p>In addition, every time the parent component is updated, all props in the child component will be refreshed with the
    latest value. This means you should <strong>not</strong> attempt to mutate a prop inside a child component. If you
    do, Vue will warn you in the console.</p>
<p>There are usually two cases where it’s tempting to mutate a prop:</p>
<ol>
    <li>
        <p><strong>The prop is used to pass in an initial value; the child component wants to use it as a local data
                property afterwards.</strong> In this case, it’s best to define a local data property that uses the prop
            as its initial value:</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'initialCounter'</span>],<br><span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">initialCounter</span><br> }<br>}<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p><strong>The prop is passed in as a raw value that needs to be transformed.</strong> In this case, it’s best
            to define a computed property using the prop’s value:</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'size'</span>],<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">normalizedSize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>()<br> }<br>}<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
</ol>
<p class="tip">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object,
    mutating the object or array itself inside the child component <strong>will</strong> affect parent state.</p>
<h2 id="Prop-Validation"><a href="#Prop-Validation" class="headerlink" title="Prop Validation" data-scroll="">Prop
        Validation</a></h2>
<p>Components can specify requirements for their props, such as the types you’ve already seen. If a requirement isn’t
    met, Vue will warn you in the browser’s JavaScript console. This is especially useful when developing a component
    that’s intended to be used by others.</p>
<p>To specify prop validations, you can provide an object with validation requirements to the value of
    <code>props</code>, instead of an array of strings. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component'</span>, {<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-comment">// Basic type check (`null` and `undefined` values will pass any type validation)</span><br> <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-comment">// Multiple possible types</span><br> <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br> <span class="hljs-comment">// Required string</span><br> <span class="hljs-attr">propC</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> },<br> <span class="hljs-comment">// Number with a default value</span><br> <span class="hljs-attr">propD</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br> },<br> <span class="hljs-comment">// Object with a default value</span><br> <span class="hljs-attr">propE</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br> <span class="hljs-comment">// Object or array defaults must be returned from</span><br> <span class="hljs-comment">// a factory function</span><br> <span class="hljs-attr">default</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span> }<br> }<br> },<br> <span class="hljs-comment">// Custom validator function</span><br> <span class="hljs-attr">propF</span>: {<br> <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {<br> <span class="hljs-comment">// The value must match one of these strings</span><br> <span class="hljs-keyword">return</span> [<span class="hljs-string">'success'</span>, <span class="hljs-string">'warning'</span>, <span class="hljs-string">'danger'</span>].<span class="hljs-title function_">includes</span>(value)<br> }<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When prop validation fails, Vue will produce a console warning (if using the development build).</p>
<p class="tip">Note that props are validated <strong>before</strong> a component instance is created, so instance
    properties (e.g. <code>data</code>, <code>computed</code>, etc) will not be available inside <code>default</code> or
    <code>validator</code> functions.</p>
<h3 id="Type-Checks"><a href="#Type-Checks" class="headerlink" title="Type Checks" data-scroll="">Type Checks</a></h3>
<p>The <code>type</code> can be one of the following native constructors:</p>
<ul>
    <li>String</li>
    <li>Number</li>
    <li>Boolean</li>
    <li>Array</li>
    <li>Object</li>
    <li>Date</li>
    <li>Function</li>
    <li>Symbol</li>
</ul>
<p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an
    <code>instanceof</code> check. For example, given the following constructor function exists:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (firstName, lastName) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You could use:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'blog-post'</span>, {<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">author</span>: <span class="hljs-title class_">Person</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to validate that the value of the <code>author</code> prop was created with <code>new Person</code>.</p>
<h2 id="Non-Prop-Attributes"><a href="#Non-Prop-Attributes" class="headerlink" title="Non-Prop Attributes"
        data-scroll="">Non-Prop Attributes</a></h2>
<p>A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.
</p>
<p>While explicitly defined props are preferred for passing information to a child component, authors of component
    libraries can’t always foresee the contexts in which their components might be used. That’s why components can
    accept arbitrary attributes, which are added to the component’s root element.</p>
<p>For example, imagine we’re using a 3rd-party <code>bootstrap-date-input</code> component with a Bootstrap plugin that
    requires a <code>data-date-picker</code> attribute on the <code>input</code>. We can add this attribute to our
    component instance:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">bootstrap-date-input</span> <span class="hljs-attr">data-date-picker</span>=<span class="hljs-string">"activated"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bootstrap-date-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And the <code>data-date-picker="activated"</code> attribute will automatically be added to the root element of
    <code>bootstrap-date-input</code>.</p>
<h3 id="Replacing-Merging-with-Existing-Attributes"><a href="#Replacing-Merging-with-Existing-Attributes"
        class="headerlink" title="Replacing/Merging with Existing Attributes" data-scroll="">Replacing/Merging with
        Existing Attributes</a></h3>
<p>Imagine this is the template for <code>bootstrap-date-input</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">bootstrap-date-input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">data-date-picker</span>=<span class="hljs-string">"activated"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"date-picker-theme-dark"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bootstrap-date-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In this case, two different values for <code>class</code> are defined:</p>
<ul>
    <li><code>form-control</code>, which is set by the component in its template</li>
    <li><code>date-picker-theme-dark</code>, which is passed to the component by its parent</li>
</ul>
<p>For most attributes, the value provided to the component will replace the value set by the component. So for example,
    passing <code>type="text"</code> will replace <code>type="date"</code> and probably break it! Fortunately, the
    <code>class</code> and <code>style</code> attributes are a little smarter, so both values are merged, making the
    final value: <code>form-control date-picker-theme-dark</code>.</p>
<h3 id="Disabling-Attribute-Inheritance"><a href="#Disabling-Attribute-Inheritance" class="headerlink"
        title="Disabling Attribute Inheritance" data-scroll="">Disabling Attribute Inheritance</a></h3>
<p>If you do <strong>not</strong> want the root element of a component to inherit attributes, you can set
    <code>inheritAttrs: false</code> in the component’s options. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component'</span>, {<br> <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-comment">// ...</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This can be especially useful in combination with the <code>$attrs</code> instance property, which contains the
    attribute names and values passed to a component, such as:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'Enter your username'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>With <code>inheritAttrs: false</code> and <code>$attrs</code>, you can manually decide which element you want to
    forward attributes to, which is often desirable for <a
        href="../style-guide/#Base-component-names-strongly-recommended">base components</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'base-input'</span>, {<br> <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'label'</span>, <span class="hljs-string">'value'</span>],<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;label&gt;</span><br><span class="hljs-string"> {{ label }}</span><br><span class="hljs-string"> &lt;input</span><br><span class="hljs-string"> v-bind="$attrs"</span><br><span class="hljs-string"> v-bind:value="value"</span><br><span class="hljs-string"> v-on:input="$emit('input', $event.target.value)"</span><br><span class="hljs-string"> &gt;</span><br><span class="hljs-string"> &lt;/label&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Note that <code>inheritAttrs: false</code> option does <strong>not</strong> affect <code>style</code> and
    <code>class</code> bindings.</p>
<p>This pattern allows you to use base components more like raw HTML elements, without having to care about which
    element is actually at its root:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">label</span>=<span class="hljs-string">"Username:"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">required</span></span><br><span class="hljs-tag"> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter your username"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/components-registration.html">Component Registration</a></span>
    <span style="float: right"><a href="/v2/guide/components-custom-events.html">Custom Events</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Custom Events</h1>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<div class="vueschool"><a href="https://vueschool.io/lessons/communication-between-components?friend=vuejs"
        target="_blank" rel="sponsored noopener" title="Learn how to work with custom events on Vue School">Learn how to
        work with custom events in a free Vue School lesson</a></div>
<h2 id="Event-Names"><a href="#Event-Names" class="headerlink" title="Event Names" data-scroll="">Event Names</a></h2>
<p>Unlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an
    emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event
    name:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">'myEvent'</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Listening to the kebab-cased version will have no effect:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Won't work --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-on:my-event</span>=<span class="hljs-string">"doSomething"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there’s
    no reason to use camelCase or PascalCase. Additionally, <code>v-on</code> event listeners inside DOM templates will
    be automatically transformed to lowercase (due to HTML’s case-insensitivity), so <code>v-on:myEvent</code> would
    become <code>v-on:myevent</code> – making <code>myEvent</code> impossible to listen to.</p>
<p>For these reasons, we recommend you <strong>always use kebab-case for event names</strong>.</p>
<h2 id="Customizing-Component-v-model"><a href="#Customizing-Component-v-model" class="headerlink"
        title="Customizing Component v-model" data-scroll="">Customizing Component <code>v-model</code></a></h2>
<blockquote>
    <p>New in 2.2.0+</p>
</blockquote>
<p>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the
    event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> attribute
    for a <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">different purpose</a>.
    Using the <code>model</code> option can avoid a conflict in such cases:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'base-checkbox'</span>, {<br> <span class="hljs-attr">model</span>: {<br> <span class="hljs-attr">prop</span>: <span class="hljs-string">'checked'</span>,<br> <span class="hljs-attr">event</span>: <span class="hljs-string">'change'</span><br> },<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">checked</span>: <span class="hljs-title class_">Boolean</span><br> },<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;input</span><br><span class="hljs-string"> type="checkbox"</span><br><span class="hljs-string"> v-bind:checked="checked"</span><br><span class="hljs-string"> v-on:change="$emit('change', $event.target.checked)"</span><br><span class="hljs-string"> &gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now when using <code>v-model</code> on this component:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-checkbox</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"lovingVue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-checkbox</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>the value of <code>lovingVue</code> will be passed to the <code>checked</code> prop. The <code>lovingVue</code>
    property will then be updated when <code>&lt;base-checkbox&gt;</code> emits a <code>change</code> event with a new
    value.</p>
<p class="tip">Note that you still have to declare the <code>checked</code> prop in the component’s <code>props</code>
    option.</p>
<h2 id="Binding-Native-Events-to-Components"><a href="#Binding-Native-Events-to-Components" class="headerlink"
        title="Binding Native Events to Components" data-scroll="">Binding Native Events to Components</a></h2>
<p>There may be times when you want to listen directly to a native event on the root element of a component. In these
    cases, you can use the <code>.native</code> modifier for <code>v-on</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">v-on:focus.native</span>=<span class="hljs-string">"onFocus"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like
    an <code>&lt;input&gt;</code>. For example, the <code>&lt;base-input&gt;</code> component above might refactor so
    that the root element is actually a <code>&lt;label&gt;</code> element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br> {{ label }}<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"value"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">"$emit('input', $event.target.value)"</span></span><br><span class="hljs-tag"> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In that case, the <code>.native</code> listener in the parent would silently break. There would be no errors, but the
    <code>onFocus</code> handler wouldn’t be called when we expected it to.</p>
<p>To solve this problem, Vue provides a <code>$listeners</code> property containing an object of listeners being used
    on the component. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-attr">focus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) { <span class="hljs-comment">/* ... */</span> }<br> <span class="hljs-attr">input</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) { <span class="hljs-comment">/* ... */</span> },<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Using the <code>$listeners</code> property, you can forward all event listeners on the component to a specific child
    element with <code>v-on="$listeners"</code>. For elements like <code>&lt;input&gt;</code>, that you also want to
    work with <code>v-model</code>, it’s often useful to create a new computed property for listeners, like
    <code>inputListeners</code> below:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'base-input'</span>, {<br> <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">props</span>: [<span class="hljs-string">'label'</span>, <span class="hljs-string">'value'</span>],<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">inputListeners</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span><br> <span class="hljs-comment">// `Object.assign` merges objects together to form a new object</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({},<br> <span class="hljs-comment">// We add all the listeners from the parent</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$listeners</span>,<br> <span class="hljs-comment">// Then we can add custom listeners or override the</span><br> <span class="hljs-comment">// behavior of some listeners.</span><br> {<br> <span class="hljs-comment">// This ensures that the component works with v-model</span><br> <span class="hljs-attr">input</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {<br> vm.$emit(<span class="hljs-string">'input'</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br> }<br> }<br> )<br> }<br> },<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;label&gt;</span><br><span class="hljs-string"> {{ label }}</span><br><span class="hljs-string"> &lt;input</span><br><span class="hljs-string"> v-bind="$attrs"</span><br><span class="hljs-string"> v-bind:value="value"</span><br><span class="hljs-string"> v-on="inputListeners"</span><br><span class="hljs-string"> &gt;</span><br><span class="hljs-string"> &lt;/label&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now the <code>&lt;base-input&gt;</code> component is a <strong>fully transparent wrapper</strong>, meaning it can be
    used exactly like a normal <code>&lt;input&gt;</code> element: all the same attributes and listeners will work,
    without the <code>.native</code> modifier.</p>
<h2 id="sync-Modifier"><a href="#sync-Modifier" class="headerlink" title=".sync Modifier"
        data-scroll=""><code>.sync</code> Modifier</a></h2>
<blockquote>
    <p>New in 2.3.0+</p>
</blockquote>
<p>In some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance
    issues, because child components can mutate the parent without the source of that mutation being obvious in both the
    parent and the child.</p>
<p>That’s why instead, we recommend emitting events in the pattern of <code>update:myPropName</code>. For example, in a
    hypothetical component with a <code>title</code> prop, we could communicate the intent of assigning a new value
    with:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">'update:title'</span>, newTitle)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then the parent can listen to that event and update a local data property, if it wants to. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"doc.title"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:update:title</span>=<span class="hljs-string">"doc.title = $event"</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For convenience, we offer a shorthand for this pattern with the <code>.sync</code> modifier:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title.sync</span>=<span class="hljs-string">"doc.title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with
    expressions (e.g. <code>v-bind:title.sync=”doc.title + ‘!’”</code> is invalid). Instead, you must only provide the
    name of the property you want to bind, similar to <code>v-model</code>.</p>
<p>The <code>.sync</code> modifier can also be used with <code>v-bind</code> when using an object to set multiple props
    at once:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind.sync</span>=<span class="hljs-string">"doc"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This passes each property in the <code>doc</code> object (e.g. <code>title</code>) as an individual prop, then adds
    <code>v-on</code> update listeners for each one.</p>
<p class="tip">Using <code>v-bind.sync</code> with a literal object, such as in
    <code>v-bind.sync=”{ title: doc.title }”</code>, will not work, because there are too many edge cases to consider in
    parsing a complex expression like this.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/components-props.html">Props</a></span> <span
        style="float: right"><a href="/v2/guide/components-slots.html">Slots</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Slots</h1>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<blockquote>
    <p>In 2.6.0, we introduced a new unified syntax (the <code>v-slot</code> directive) for named and scoped slots. It
        replaces the <code>slot</code> and <code>slot-scope</code> attributes, which are now deprecated, but have
        <em>not</em> been removed and are still documented <a href="#Deprecated-Syntax">here</a>. The rationale for
        introducing the new syntax is described in this <a target="_blank" rel="noopener"
            href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC</a>.</p>
</blockquote>
<h2 id="Slot-Content"><a href="#Slot-Content" class="headerlink" title="Slot Content" data-scroll="">Slot Content</a>
</h2>
<p>Vue implements a content distribution API inspired by the <a target="_blank" rel="noopener"
        href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components spec
        draft</a>, using the <code>&lt;slot&gt;</code> element to serve as distribution outlets for content.</p>
<p>This allows you to compose components like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span><br> Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then in the template for <code>&lt;navigation-link&gt;</code>, you might have:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span></span><br><span class="hljs-tag">&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When the component renders, <code>&lt;slot&gt;&lt;/slot&gt;</code> will be replaced by “Your Profile”. Slots can
    contain any template code, including HTML:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- Add a Font Awesome icon --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or even other components:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- Use a component to add an icon --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span><br> Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If <code>&lt;navigation-link&gt;</code>‘s template did <strong>not</strong> contain a <code>&lt;slot&gt;</code>
    element, any content provided between its opening and closing tag would be discarded.</p>
<h2 id="Compilation-Scope"><a href="#Compilation-Scope" class="headerlink" title="Compilation Scope"
        data-scroll="">Compilation Scope</a></h2>
<p>When you want to use data inside a slot, such as in:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span><br> Logged in as {{ user.name }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That slot has access to the same instance properties (i.e. the same “scope”) as the rest of the template. The slot
    does <strong>not</strong> have access to <code>&lt;navigation-link&gt;</code>‘s scope. For example, trying to access
    <code>url</code> would not work:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span><br> Clicking here will send you to: {{ url }}<br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> The `url` will be undefined, because this content is passed</span><br><span class="hljs-comment"> _to_ &lt;navigation-link&gt;, rather than defined _inside_ the</span><br><span class="hljs-comment"> &lt;navigation-link&gt; component.</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>As a rule, remember that:</p>
<blockquote>
    <p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in
        the child scope.</p>
</blockquote>
<h2 id="Fallback-Content"><a href="#Fallback-Content" class="headerlink" title="Fallback Content"
        data-scroll="">Fallback Content</a></h2>
<p>There are cases when it’s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no
    content is provided. For example, in a <code>&lt;submit-button&gt;</code> component:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>We might want the text “Submit” to be rendered inside the <code>&lt;button&gt;</code> most of the time. To make
    “Submit” the fallback content, we can place it in between the <code>&lt;slot&gt;</code> tags:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now when we use <code>&lt;submit-button&gt;</code> in a parent component, providing no content for the slot:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>will render the fallback content, “Submit”:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><br> Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>But if we provide content:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><br> Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then the provided content will be rendered instead:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><br> Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Named-Slots"><a href="#Named-Slots" class="headerlink" title="Named Slots" data-scroll="">Named Slots</a></h2>
<blockquote>
    <p>Updated in 2.6.0+. <a href="#Deprecated-Syntax">See here</a> for the deprecated syntax using the
        <code>slot</code> attribute.</p>
</blockquote>
<p>There are times when it’s useful to have multiple slots. For example, in a <code>&lt;base-layout&gt;</code> component
    with the following template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- We want header content here --&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- We want main content here --&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- We want footer content here --&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For these cases, the <code>&lt;slot&gt;</code> element has a special attribute, <code>name</code>, which can be used
    to define additional slots:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A <code>&lt;slot&gt;</code> outlet without <code>name</code> implicitly has the name “default”.</p>
<p>To provide content to named slots, we can use the <code>v-slot</code> directive on a <code>&lt;template&gt;</code>,
    providing the name of the slot as <code>v-slot</code>‘s argument:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now everything inside the <code>&lt;template&gt;</code> elements will be passed to the corresponding slots. Any
    content not wrapped in a <code>&lt;template&gt;</code> using <code>v-slot</code> is assumed to be for the default
    slot.</p>
<p>However, you can still wrap default slot content in a <code>&lt;template&gt;</code> if you wish to be explicit:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Either way, the rendered HTML will be:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that <strong><code>v-slot</code> can only be added to a <code>&lt;template&gt;</code></strong> (with <a
        href="#Abbreviated-Syntax-for-Lone-Default-Slots">one exception</a>), unlike the deprecated <a
        href="#Deprecated-Syntax"><code>slot</code> attribute</a>.</p>
<h2 id="Scoped-Slots"><a href="#Scoped-Slots" class="headerlink" title="Scoped Slots" data-scroll="">Scoped Slots</a>
</h2>
<blockquote>
    <p>Updated in 2.6.0+. <a href="#Deprecated-Syntax">See here</a> for the deprecated syntax using the
        <code>slot-scope</code> attribute.</p>
</blockquote>
<p>Sometimes, it’s useful for slot content to have access to data only available in the child component. For example,
    imagine a <code>&lt;current-user&gt;</code> component with the following template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>{{ user.lastName }}<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>We might want to replace this fallback content to display the user’s first name, instead of last, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span><br> {{ user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That won’t work, however, because only the <code>&lt;current-user&gt;</code> component has access to the
    <code>user</code> and the content we’re providing is rendered in the parent.</p>
<p>To make <code>user</code> available to the slot content in the parent, we can bind <code>user</code> as an attribute
    to the <code>&lt;slot&gt;</code> element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span><br> {{ user.lastName }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Attributes bound to a <code>&lt;slot&gt;</code> element are called <strong>slot props</strong>. Now, in the parent
    scope, we can use <code>v-slot</code> with a value to define a name for the slot props we’ve been provided:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.user.firstName }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In this example, we’ve chosen to name the object containing all our slot props <code>slotProps</code>, but you can
    use any name you like.</p>
<h3 id="Abbreviated-Syntax-for-Lone-Default-Slots"><a href="#Abbreviated-Syntax-for-Lone-Default-Slots"
        class="headerlink" title="Abbreviated Syntax for Lone Default Slots" data-scroll="">Abbreviated Syntax for Lone
        Default Slots</a></h3>
<p>In cases like above, when <em>only</em> the default slot is provided content, the component’s tags can be used as the
    slot’s template. This allows us to use <code>v-slot</code> directly on the component:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This can be shortened even further. Just as non-specified content is assumed to be for the default slot,
    <code>v-slot</code> without an argument is assumed to refer to the default slot:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that the abbreviated syntax for default slot <strong>cannot</strong> be mixed with named slots, as it would lead
    to scope ambiguity:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- INVALID, will result in warning --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.user.firstName }}<br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>&gt;</span><br> slotProps is NOT available here<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Whenever there are multiple slots, use the full <code>&lt;template&gt;</code> based syntax for <em>all</em> slots:
</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.user.firstName }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>&gt;</span><br> ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Destructuring-Slot-Props"><a href="#Destructuring-Slot-Props" class="headerlink"
        title="Destructuring Slot Props" data-scroll="">Destructuring Slot Props</a></h3>
<p>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">function</span> (<span class="hljs-params">slotProps</span>) {<br> <span class="hljs-comment">// ... slot content ...</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That means the value of <code>v-slot</code> can actually accept any valid JavaScript expression that can appear in
    the argument position of a function definition. So in supported environments (<a
        href="single-file-components.html">single-file components</a> or <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility">modern
        browsers</a>), you can also use <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring">ES2015
        destructuring</a> to pull out specific slot props, like so:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user }"</span>&gt;</span><br> {{ user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This can make the template much cleaner, especially when the slot provides many props. It also opens other
    possibilities, such as renaming props, e.g. <code>user</code> to <code>person</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user: person }"</span>&gt;</span><br> {{ person.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can even define fallbacks, to be used in case a slot prop is undefined:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user = { firstName: 'Guest' } }"</span>&gt;</span><br> {{ user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Dynamic-Slot-Names"><a href="#Dynamic-Slot-Names" class="headerlink" title="Dynamic Slot Names"
        data-scroll="">Dynamic Slot Names</a></h2>
<blockquote>
    <p>New in 2.6.0+</p>
</blockquote>
<p><a href="syntax.html#Dynamic-Arguments">Dynamic directive arguments</a> also work on <code>v-slot</code>, allowing
    the definition of dynamic slot names:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span><br> ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Named-Slots-Shorthand"><a href="#Named-Slots-Shorthand" class="headerlink" title="Named Slots Shorthand"
        data-scroll="">Named Slots Shorthand</a></h2>
<blockquote>
    <p>New in 2.6.0+</p>
</blockquote>
<p>Similar to <code>v-on</code> and <code>v-bind</code>, <code>v-slot</code> also has a shorthand, replacing everything
    before the argument (<code>v-slot:</code>) with the special symbol <code>#</code>. For example,
    <code>v-slot:header</code> can be rewritten as <code>#header</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>However, just as with other directives, the shorthand is only available when an argument is provided. That means the
    following syntax is invalid:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- This will trigger a warning --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #=<span class="hljs-string">"{ user }"</span>&gt;</span><br> {{ user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Instead, you must always specify the name of the slot if you wish to use the shorthand:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">"{ user }"</span>&gt;</span><br> {{ user.firstName }}<br><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Other-Examples"><a href="#Other-Examples" class="headerlink" title="Other Examples" data-scroll="">Other
        Examples</a></h2>
<p><strong>Slot props allow us to turn slots into reusable templates that can render different content based on input
        props.</strong> This is most useful when you are designing a reusable component that encapsulates data logic
    while allowing the consuming parent component to customize part of its layout.</p>
<p>For example, we are implementing a <code>&lt;todo-list&gt;</code> component that contains the layout and filtering
    logic for a list:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in filteredTodos"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"todo.id"</span></span><br><span class="hljs-tag"> &gt;</span><br> {{ todo.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a
    slot, then binding <code>todo</code> as a slot prop:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"todo in filteredTodos"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"todo.id"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> We have a slot for each todo, passing it the</span><br><span class="hljs-comment"> `todo` object as a slot prop.</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo"</span> <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">"todo"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- Fallback content --&gt;</span><br> {{ todo.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now when we use the <code>&lt;todo-list&gt;</code> component, we can optionally define an alternative
    <code>&lt;template&gt;</code> for todo items, but with access to data from the child:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-bind:todos</span>=<span class="hljs-string">"todos"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:todo</span>=<span class="hljs-string">"{ todo }"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todo.isComplete"</span>&gt;</span>✓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> {{ todo.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">todo-list</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples
    of scoped slot usage, we recommend browsing libraries such as <a target="_blank" rel="noopener"
        href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>, <a target="_blank"
        rel="noopener" href="https://github.com/posva/vue-promised">Vue Promised</a>, and <a target="_blank"
        rel="noopener" href="https://github.com/LinusBorg/portal-vue">Portal Vue</a>.</p>
<h2 id="Deprecated-Syntax"><a href="#Deprecated-Syntax" class="headerlink" title="Deprecated Syntax"
        data-scroll="">Deprecated Syntax</a></h2>
<blockquote>
    <p>The <code>v-slot</code> directive was introduced in Vue 2.6.0, offering an improved, alternative API to the
        still-supported <code>slot</code> and <code>slot-scope</code> attributes. The full rationale for introducing
        <code>v-slot</code> is described in this <a target="_blank" rel="noopener"
            href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC</a>. The
        <code>slot</code> and <code>slot-scope</code> attributes will continue to be supported in all future 2.x
        releases, but are officially deprecated and will eventually be removed in Vue 3.</p>
</blockquote>
<h3 id="Named-Slots-with-the-slot-Attribute"><a href="#Named-Slots-with-the-slot-Attribute" class="headerlink"
        title="Named Slots with the slot Attribute" data-scroll="">Named Slots with the <code>slot</code> Attribute</a>
</h3>
<blockquote>
    <p><abbr title="Still supported in all 2.x versions of Vue, but no longer recommended.">Deprecated</abbr> in 2.6.0+.
        See <a href="#Named-Slots">here</a> for the new, recommended syntax.</p>
</blockquote>
<p>To pass content to named slots from the parent, use the special <code>slot</code> attribute on
    <code>&lt;template&gt;</code> (using the <code>&lt;base-layout&gt;</code> component described <a
        href="#Named-Slots">here</a> as example):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"footer"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or, the <code>slot</code> attribute can also be used directly on a normal element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"footer"</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all for any
    unmatched content. In both examples above, the rendered HTML would be:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Scoped-Slots-with-the-slot-scope-Attribute"><a href="#Scoped-Slots-with-the-slot-scope-Attribute"
        class="headerlink" title="Scoped Slots with the slot-scope Attribute" data-scroll="">Scoped Slots with the
        <code>slot-scope</code> Attribute</a></h3>
<blockquote>
    <p><abbr title="Still supported in all 2.x versions of Vue, but no longer recommended.">Deprecated</abbr> in 2.6.0+.
        See <a href="#Scoped-Slots">here</a> for the new, recommended syntax.</p>
</blockquote>
<p>To receive props passed to a slot, the parent component can use <code>&lt;template&gt;</code> with the
    <code>slot-scope</code> attribute (using the <code>&lt;slot-example&gt;</code> described <a
        href="#Scoped-Slots">here</a> as example):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot-example</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"default"</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.msg }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">slot-example</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here, <code>slot-scope</code> declares the received props object as the <code>slotProps</code> variable, and makes it
    available inside the <code>&lt;template&gt;</code> scope. You can name <code>slotProps</code> anything you like
    similar to naming function arguments in JavaScript.</p>
<p>Here <code>slot="default"</code> can be omitted as it is implied:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot-example</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.msg }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">slot-example</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The <code>slot-scope</code> attribute can also be used directly on a non-<code>&lt;template&gt;</code> element
    (including components):</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot-example</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"slotProps"</span>&gt;</span><br> {{ slotProps.msg }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">slot-example</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The value of <code>slot-scope</code> can accept any valid JavaScript expression that can appear in the argument
    position of a function definition. This means in supported environments (<a
        href="single-file-components.html">single-file components</a> or <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility">modern
        browsers</a>) you can also use <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring">ES2015
        destructuring</a> in the expression, like so:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot-example</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"{ msg }"</span>&gt;</span><br> {{ msg }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">slot-example</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Using the <code>&lt;todo-list&gt;</code> described <a href="#Other-Examples">here</a> as an example, here’s the
    equivalent usage using <code>slot-scope</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-bind:todos</span>=<span class="hljs-string">"todos"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo"</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"{ todo }"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todo.isComplete"</span>&gt;</span>✓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> {{ todo.text }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">todo-list</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/components-custom-events.html">Custom Events</a></span> <span
        style="float: right"><a href="/v2/guide/components-dynamic-async.html">Dynamic &amp; Async Components</a>
        →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Dynamic &amp; Async Components</h1>
<script> const __pageRedirects = { '#Async-Components': '/guide/components/async.html' }</script>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<h2 id="keep-alive-with-Dynamic-Components"><a href="#keep-alive-with-Dynamic-Components" class="headerlink"
        title="keep-alive with Dynamic Components" data-scroll=""><code>keep-alive</code> with Dynamic Components</a>
</h2>
<p>Earlier, we used the <code>is</code> attribute to switch between components in a tabbed interface:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When switching between these components though, you’ll sometimes want to maintain their state or avoid re-rendering
    for performance reasons. For example, when expanding our tabbed interface a little:</p>
<div id="dynamic-component-demo" class="demo"><button
        class="dynamic-component-demo-tab-button dynamic-component-demo-active">Posts</button><button
        class="dynamic-component-demo-tab-button">Archive</button>
    <div class="dynamic-component-demo-posts-tab dynamic-component-demo-tab">
        <ul class="dynamic-component-demo-posts-sidebar">
            <li class=""> Cat Ipsum </li>
            <li class=""> Hipster Ipsum </li>
            <li class=""> Cupcake Ipsum </li>
        </ul>
        <div class="dynamic-component-demo-post-container"><strong> Click on a blog title to the left to view it.
            </strong></div>
    </div>
</div>
<script> Vue.component('tab-posts', { data: function () { return { posts: [{ id: 1, title: 'Cat Ipsum', content: '<p>Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around</p>' }, { id: 2, title: 'Hipster Ipsum', content: '<p>Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.</p>' }, { id: 3, title: 'Cupcake Ipsum', content: '<p>Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.</p>' }], selectedPost: null } }, template: '\ <div class="dynamic-component-demo-posts-tab">\ <ul class="dynamic-component-demo-posts-sidebar">\ <li\ v-for="post in posts"\ v-bind:key="post.id"\ v-bind:class="{ \'dynamic-component-demo-active\': post === selectedPost }"\ v-on:click="selectedPost = post"\ >\ {{ post.title }}\ </li>\ </ul>\ <div class="dynamic-component-demo-post-container">\ <div \ v-if="selectedPost"\ class="dynamic-component-demo-post"\ >\ <h3>{{ selectedPost.title }}</h3>\ <div v-html="selectedPost.content"></div>\ </div>\ <strong v-else>\ Click on a blog title to the left to view it.\ </strong>\ </div>\ </div>\ ' }) Vue.component('tab-archive', { template: '<div>Archive component</div>' }) new Vue({ el: '#dynamic-component-demo', data: { currentTab: 'Posts', tabs: ['Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } })</script>
<style>
    .dynamic-component-demo-tab-button {
        padding: 6px 10px;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
        border: 1px solid #ccc;
        cursor: pointer;
        background: #f0f0f0;
        margin-bottom: -1px;
        margin-right: -1px;
        overflow-anchor: none;
    }

    .dynamic-component-demo-tab-button:hover {
        background: #e0e0e0;
    }

    .dynamic-component-demo-tab-button.dynamic-component-demo-active {
        background: #e0e0e0;
    }

    .dynamic-component-demo-tab {
        border: 1px solid #ccc;
        padding: 10px;
    }

    .dynamic-component-demo-posts-tab {
        display: flex;
    }

    .dynamic-component-demo-posts-sidebar {
        max-width: 40vw;
        margin: 0 !important;
        padding: 0 10px 0 0 !important;
        list-style-type: none;
        border-right: 1px solid #ccc;
    }

    .dynamic-component-demo-posts-sidebar li {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        cursor: pointer;
    }

    .dynamic-component-demo-posts-sidebar li:hover {
        background: #eee;
    }

    .dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active {
        background: lightblue;
    }

    .dynamic-component-demo-post-container {
        padding-left: 10px;
    }

    .dynamic-component-demo-post> :first-child {
        margin-top: 0 !important;
        padding-top: 0 !important;
    }
</style>
<p>You’ll notice that if you select a post, switch to the <em>Archive</em> tab, then switch back to <em>Posts</em>, it’s
    no longer showing the post you selected. That’s because each time you switch to a new tab, Vue creates a new
    instance of the <code>currentTabComponent</code>.</p>
<p>Recreating dynamic components is normally useful behavior, but in this case, we’d really like those tab component
    instances to be cached once they’re created for the first time. To solve this problem, we can wrap our dynamic
    component with a <code>&lt;keep-alive&gt;</code> element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Inactive components will be cached! --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"currentTabComponent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Check out the result below:</p>
<div id="dynamic-component-keep-alive-demo" class="demo"><button
        class="dynamic-component-demo-tab-button dynamic-component-demo-active">Posts</button><button
        class="dynamic-component-demo-tab-button">Archive</button>
    <div class="dynamic-component-demo-posts-tab dynamic-component-demo-tab">
        <ul class="dynamic-component-demo-posts-sidebar">
            <li class=""> Cat Ipsum </li>
            <li class=""> Hipster Ipsum </li>
            <li class=""> Cupcake Ipsum </li>
        </ul>
        <div class="dynamic-component-demo-post-container"><strong> Click on a blog title to the left to view it.
            </strong></div>
    </div>
</div>
<script> new Vue({ el: '#dynamic-component-keep-alive-demo', data: { currentTab: 'Posts', tabs: ['Posts', 'Archive'] }, computed: { currentTabComponent: function () { return 'tab-' + this.currentTab.toLowerCase() } } })</script>
<p>Now the <em>Posts</em> tab maintains its state (the selected post) even when it’s not rendered. See <a
        target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components">this
        example</a> for the complete code.</p>
<p class="tip">Note that <code>&lt;keep-alive&gt;</code> requires the components being switched between to all have
    names, either using the <code>name</code> option on a component, or through local/global registration.</p>
<p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href="../api/#keep-alive">API reference</a>.</p>
<h2 id="Async-Components"><a href="#Async-Components" class="headerlink" title="Async Components" data-scroll="">Async
        Components</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/dynamically-load-components?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Async Components lesson">Watch a free video lesson on Vue School</a>
</div>
<p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server
    when it’s needed. To make that easier, Vue allows you to define your component as a factory function that
    asynchronously resolves your component definition. Vue will only trigger the factory function when the component
    needs to be rendered and will cache the result for future re-renders. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'async-example'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {<br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// Pass the component definition to the resolve callback</span><br> <span class="hljs-title function_">resolve</span>({<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;I am async!&lt;/div&gt;'</span><br> })<br> }, <span class="hljs-number">1000</span>)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>As you can see, the factory function receives a <code>resolve</code> callback, which should be called when you have
    retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the
    load has failed. The <code>setTimeout</code> here is for demonstration; how to retrieve the component is up to you.
    One recommended approach is to use async components together with <a target="_blank" rel="noopener"
        href="https://webpack.js.org/guides/code-splitting/">Webpack’s code-splitting feature</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'async-webpack-example'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) {<br> <span class="hljs-comment">// This special require syntax will instruct Webpack to</span><br> <span class="hljs-comment">// automatically split your built code into bundles which</span><br> <span class="hljs-comment">// are loaded over Ajax requests.</span><br> <span class="hljs-built_in">require</span>([<span class="hljs-string">'./my-async-component'</span>], resolve)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 and ES2015 syntax you can make
    use of dynamic imports:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<br> <span class="hljs-string">'async-webpack-example'</span>,<br> <span class="hljs-comment">// A dynamic import returns a Promise.</span><br> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'./my-async-component'</span>)<br>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When using <a href="components-registration.html#Local-Registration">local registration</a>, you can also directly
    provide a function that returns a <code>Promise</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-string">'my-component'</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'./my-async-component'</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">If you’re a <strong>Browserify</strong> user that would like to use async components, its creator has
    unfortunately <a target="_blank" rel="noopener"
        href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224">made it clear</a> that async
    loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has
    found <a target="_blank" rel="noopener" href="https://github.com/vuejs/v2.vuejs.org/issues/620">some
        workarounds</a>, which may be helpful for existing and complex applications. For all other scenarios, we
    recommend using Webpack for built-in, first-class async support.</p>
<h3 id="Handling-Loading-State"><a href="#Handling-Loading-State" class="headerlink" title="Handling Loading State"
        data-scroll="">Handling Loading State</a></h3>
<blockquote>
    <p>New in 2.3.0+</p>
</blockquote>
<p>The async component factory can also return an object of the following format:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncComponent</span> = (<span class="hljs-params"></span>) =&gt; ({<br> <span class="hljs-comment">// The component to load (should be a Promise)</span><br> <span class="hljs-attr">component</span>: <span class="hljs-title function_">import</span>(<span class="hljs-string">'./MyComponent.vue'</span>),<br> <span class="hljs-comment">// A component to use while the async component is loading</span><br> <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>,<br> <span class="hljs-comment">// A component to use if the load fails</span><br> <span class="hljs-attr">error</span>: <span class="hljs-title class_">ErrorComponent</span>,<br> <span class="hljs-comment">// Delay before showing the loading component. Default: 200ms.</span><br> <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br> <span class="hljs-comment">// The error component will be displayed if a timeout is</span><br> <span class="hljs-comment">// provided and exceeded. Default: Infinity.</span><br> <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<blockquote>
    <p>Note that you must use <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router">Vue
            Router</a> 2.4.0+ if you wish to use the above syntax for route components.</p>
</blockquote>
<div class="guide-links"> <span>← <a href="/v2/guide/components-slots.html">Slots</a></span> <span
        style="float: right"><a href="/v2/guide/components-edge-cases.html">Handling Edge Cases</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Handling Edge Cases</h1>
<blockquote>
    <p>This page assumes you’ve already read the <a href="components.html">Components Basics</a>. Read that first if you
        are new to components.</p>
</blockquote>
<p class="tip">All the features on this page document the handling of edge cases, meaning unusual situations that
    sometimes require bending Vue’s rules a little. Note however, that they all have disadvantages or situations where
    they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</p>
<h2 id="Element-amp-Component-Access"><a href="#Element-amp-Component-Access" class="headerlink"
        title="Element &amp; Component Access" data-scroll="">Element &amp; Component Access</a></h2>
<p>In most cases, it’s best to avoid reaching into other component instances or manually manipulating DOM elements.
    There are cases, however, when it can be appropriate.</p>
<h3 id="Accessing-the-Root-Instance"><a href="#Accessing-the-Root-Instance" class="headerlink"
        title="Accessing the Root Instance" data-scroll="">Accessing the Root Instance</a></h3>
<p>In every subcomponent of a <code>new Vue</code> instance, this root instance can be accessed with the
    <code>$root</code> property. For example, in this root instance:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// The root Vue instance</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>All subcomponents will now be able to access this instance and use it as a global store:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Get root data</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.<span class="hljs-property">foo</span><br><br><span class="hljs-comment">// Set root data</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment">// Access root computed properties</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.<span class="hljs-property">bar</span><br><br><span class="hljs-comment">// Call root methods</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.<span class="hljs-title function_">baz</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">This can be convenient for demos or very small apps with a handful of components. However, the pattern
    does not scale well to medium or large-scale applications, so we strongly recommend using <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vuex">Vuex</a> to manage state in most cases.</p>
<h3 id="Accessing-the-Parent-Component-Instance"><a href="#Accessing-the-Parent-Component-Instance" class="headerlink"
        title="Accessing the Parent Component Instance" data-scroll="">Accessing the Parent Component Instance</a></h3>
<p>Similar to <code>$root</code>, the <code>$parent</code> property can be used to access the parent instance from a
    child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</p>
<p class="tip">In most cases, reaching into the parent makes your application more difficult to debug and understand,
    especially if you mutate data in the parent. When looking at that component later, it will be very difficult to
    figure out where that mutation came from.</p>
<p>There are cases however, particularly shared component libraries, when this <em>might</em> be appropriate. For
    example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these
    hypothetical Google Maps components:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">google-map</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">google-map-markers</span> <span class="hljs-attr">v-bind:places</span>=<span class="hljs-string">"iceCreamShops"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">google-map-markers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">google-map</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The <code>&lt;google-map&gt;</code> component might define a <code>map</code> property that all subcomponents need
    access to. In this case <code>&lt;google-map-markers&gt;</code> might want to access that map with something like
    <code>this.$parent.getMap</code>, in order to add a set of markers to it. You can see this pattern <a
        target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance">in
        action here</a>.</p>
<p>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we
    add a new <code>&lt;google-map-region&gt;</code> component and when <code>&lt;google-map-markers&gt;</code> appears
    within that, it should only render markers that fall within that region:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">google-map</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">google-map-region</span> <span class="hljs-attr">v-bind:shape</span>=<span class="hljs-string">"cityBoundaries"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">google-map-markers</span> <span class="hljs-attr">v-bind:places</span>=<span class="hljs-string">"iceCreamShops"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">google-map-markers</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">google-map-region</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">google-map</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then inside <code>&lt;google-map-markers&gt;</code> you might find yourself reaching for a hack like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> map = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">map</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">map</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This has quickly gotten out of hand. That’s why to provide context information to descendant components arbitrarily
    deep, we instead recommend <a href="#Dependency-Injection">dependency injection</a>.</p>
<h3 id="Accessing-Child-Component-Instances-amp-Child-Elements"><a
        href="#Accessing-Child-Component-Instances-amp-Child-Elements" class="headerlink"
        title="Accessing Child Component Instances &amp; Child Elements" data-scroll="">Accessing Child Component
        Instances &amp; Child Elements</a></h3>
<p>Despite the existence of props and events, sometimes you might still need to directly access a child component in
    JavaScript. To achieve this you can assign a reference ID to the child component using the <code>ref</code>
    attribute. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"usernameInput"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now in the component where you’ve defined this <code>ref</code>, you can use:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">usernameInput</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to access the <code>&lt;base-input&gt;</code> instance. This may be useful when you want to, for example,
    programmatically focus this input from a parent. In that case, the <code>&lt;base-input&gt;</code> component may
    similarly use a <code>ref</code> to provide access to specific elements inside it, such as:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"input"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And even define methods for use by the parent:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-comment">// Used to focus the input from the parent</span><br> <span class="hljs-attr">focus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>.<span class="hljs-title function_">focus</span>()<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Thus allowing the parent component to focus the input inside <code>&lt;base-input&gt;</code> with:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">usernameInput</span>.<span class="hljs-title function_">focus</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array containing the child
    components mirroring the data source.</p>
<p class="tip"><code>$refs</code> are only populated after the component has been rendered, and they are not reactive.
    It is only meant as an escape hatch for direct child manipulation - you should avoid accessing <code>$refs</code>
    from within templates or computed properties.</p>
<h3 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"
        data-scroll="">Dependency Injection</a></h3>
<p>Earlier, when we described <a href="#Accessing-the-Parent-Component-Instance">Accessing the Parent Component
        Instance</a>, we showed an example like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">google-map</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">google-map-region</span> <span class="hljs-attr">v-bind:shape</span>=<span class="hljs-string">"cityBoundaries"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">google-map-markers</span> <span class="hljs-attr">v-bind:places</span>=<span class="hljs-string">"iceCreamShops"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">google-map-markers</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">google-map-region</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">google-map</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In this component, all descendants of <code>&lt;google-map&gt;</code> needed access to a <code>getMap</code> method,
    in order to know which map to interact with. Unfortunately, using the <code>$parent</code> property didn’t scale
    well to more deeply nested components. That’s where dependency injection can be useful, using two new instance
    options: <code>provide</code> and <code>inject</code>.</p>
<p>The <code>provide</code> options allows us to specify the data/methods we want to <strong>provide</strong> to
    descendant components. In this case, that’s the <code>getMap</code> method inside <code>&lt;google-map&gt;</code>:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">provide</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">getMap</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">getMap</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then in any descendants, we can use the <code>inject</code> option to receive specific properties we’d like to add to
    that instance:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">inject</span>: [<span class="hljs-string">'getMap'</span>]<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can see the <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection">full
        example here</a>. The advantage over using <code>$parent</code> is that we can access <code>getMap</code> in
    <em>any</em> descendant component, without exposing the entire instance of <code>&lt;google-map&gt;</code>. This
    allows us to more safely keep developing that component, without fear that we might change/remove something that a
    child component is relying on. The interface between these components remains clearly defined, just as with
    <code>props</code>.</p>
<p>In fact, you can think of dependency injection as sort of “long-range props”, except:</p>
<ul>
    <li>ancestor components don’t need to know which descendants use the properties it provides</li>
    <li>descendant components don’t need to know where injected properties are coming from</li>
</ul>
<p class="tip">However, there are downsides to dependency injection. It couples components in your application to the
    way they’re currently organized, making refactoring more difficult. Provided properties are also not reactive. This
    is by design, because using them to create a central data store scales just as poorly as <a
        href="#Accessing-the-Root-Instance">using <code>$root</code></a> for the same purpose. If the properties you
    want to share are specific to your app, rather than generic, or if you ever want to update provided data inside
    ancestors, then that’s a good sign that you probably need a real state management solution like <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vuex">Vuex</a> instead.</p>
<p>Learn more about dependency injection in <a href="/v2/api/#provide-inject">the API doc</a>.</p>
<h2 id="Programmatic-Event-Listeners"><a href="#Programmatic-Event-Listeners" class="headerlink"
        title="Programmatic Event Listeners" data-scroll="">Programmatic Event Listeners</a></h2>
<p>So far, you’ve seen uses of <code>$emit</code>, listened to with <code>v-on</code>, but Vue instances also offer
    other methods in its events interface. We can:</p>
<ul>
    <li>Listen for an event with <code>$on(eventName, eventHandler)</code></li>
    <li>Listen for an event only once with <code>$once(eventName, eventHandler)</code></li>
    <li>Stop listening for an event with <code>$off(eventName, eventHandler)</code></li>
</ul>
<p>You normally won’t have to use these, but they’re available for cases when you need to manually listen for events on
    a component instance. They can also be useful as a code organization tool. For example, you may often see this
    pattern for integrating a 3rd-party library:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Attach the datepicker to an input once</span><br><span class="hljs-comment">// it's mounted to the DOM.</span><br><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// Pikaday is a 3rd-party datepicker library</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">picker</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pikaday</span>({<br> <span class="hljs-attr">field</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>,<br> <span class="hljs-attr">format</span>: <span class="hljs-string">'YYYY-MM-DD'</span><br> })<br>},<br><span class="hljs-comment">// Right before the component is destroyed,</span><br><span class="hljs-comment">// also destroy the datepicker.</span><br><span class="hljs-attr">beforeDestroy</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">picker</span>.<span class="hljs-title function_">destroy</span>()<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This has two potential issues:</p>
<ul>
    <li>It requires saving the <code>picker</code> to the component instance, when it’s possible that only lifecycle
        hooks need access to it. This isn’t terrible, but it could be considered clutter.</li>
    <li>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up
        anything we set up.</li>
</ul>
<p>You could resolve both issues with a programmatic listener:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> picker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pikaday</span>({<br> <span class="hljs-attr">field</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>,<br> <span class="hljs-attr">format</span>: <span class="hljs-string">'YYYY-MM-DD'</span><br> })<br><br> <span class="hljs-variable language_">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> picker.<span class="hljs-title function_">destroy</span>()<br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically
    cleaning up after itself:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachDatepicker</span>(<span class="hljs-string">'startDateInput'</span>)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachDatepicker</span>(<span class="hljs-string">'endDateInput'</span>)<br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">attachDatepicker</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">refName</span>) {<br> <span class="hljs-keyword">var</span> picker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pikaday</span>({<br> <span class="hljs-attr">field</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>[refName],<br> <span class="hljs-attr">format</span>: <span class="hljs-string">'YYYY-MM-DD'</span><br> })<br><br> <span class="hljs-variable language_">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> picker.<span class="hljs-title function_">destroy</span>()<br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>See <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners">this
        example</a> for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup
    within a single component, the best solution will usually be to create more modular components. In this case, we’d
    recommend creating a reusable <code>&lt;input-datepicker&gt;</code> component.</p>
<p>To learn more about programmatic listeners, check out the API for <a href="/v2/api/#Instance-Methods-Events">Events
        Instance Methods</a>.</p>
<p class="tip">Note that Vue’s event system is different from the browser’s <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget API</a>. Though they work
    similarly, <code>$emit</code>, <code>$on</code>, and <code>$off</code> are <strong>not</strong> aliases for
    <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.</p>
<h2 id="Circular-References"><a href="#Circular-References" class="headerlink" title="Circular References"
        data-scroll="">Circular References</a></h2>
<h3 id="Recursive-Components"><a href="#Recursive-Components" class="headerlink" title="Recursive Components"
        data-scroll="">Recursive Components</a></h3>
<p>Components can recursively invoke themselves in their own template. However, they can only do so with the
    <code>name</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">name</span>: <span class="hljs-string">'unique-name-of-my-component'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the
    component’s <code>name</code> option.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'unique-name-of-my-component'</span>, {<br> <span class="hljs-comment">// ...</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you’re not careful, recursive components can also lead to infinite loops:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">name</span>: <span class="hljs-string">'stack-overflow'</span>,<br><span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is
    conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p>
<h3 id="Circular-References-Between-Components"><a href="#Circular-References-Between-Components" class="headerlink"
        title="Circular References Between Components" data-scroll="">Circular References Between Components</a></h3>
<p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a
    <code>tree-folder</code> component with this template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ folder.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">tree-folder-contents</span> <span class="hljs-attr">:children</span>=<span class="hljs-string">"folder.children"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then a <code>tree-folder-contents</code> component with this template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"child in children"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">tree-folder</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"child.children"</span> <span class="hljs-attr">:folder</span>=<span class="hljs-string">"child"</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span>{{ child.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When you look closely, you’ll see that these components will actually be each other’s descendant <em>and</em>
    ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this
    paradox is resolved for you automatically. If that’s you, you can stop reading here.</p>
<p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or
    Browserify, you’ll get an error:</p>
<figure class="highlight plaintext">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs plaintext">Failed to mount component: template or render function not defined.<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To explain what’s happening, let’s call our components A and B. The module system sees that it needs A, but first A
    needs B, but B needs A, but A needs B, etc. It’s stuck in a loop, not knowing how to fully resolve either component
    without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A
    needs B <em>eventually</em>, but there’s no need to resolve B first.”</p>
<p>In our case, let’s make that point the <code>tree-folder</code> component. We know the child that creates the paradox
    is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook
    to register it:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">beforeCreate</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">components</span>.<span class="hljs-property">TreeFolderContents</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./tree-folder-contents.vue'</span>).<span class="hljs-property">default</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or alternatively, you could use Webpack’s asynchronous <code>import</code> when you register the component locally:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">components</span>: {<br> <span class="hljs-title class_">TreeFolderContents</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'./tree-folder-contents.vue'</span>)<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Problem solved!</p>
<h2 id="Alternate-Template-Definitions"><a href="#Alternate-Template-Definitions" class="headerlink"
        title="Alternate Template Definitions" data-scroll="">Alternate Template Definitions</a></h2>
<h3 id="Inline-Templates"><a href="#Inline-Templates" class="headerlink" title="Inline Templates" data-scroll="">Inline
        Templates</a></h3>
<p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its
    inner content as its template, rather than treating it as distributed content. This allows more flexible
    template-authoring.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">inline-template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>These are compiled as the component's own template.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Not parent's transclusion content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Your inline template needs to be defined inside the DOM element to which Vue is attached.</p>
<p class="tip">However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best
    practice, prefer defining templates inside the component using the <code>template</code> option or in a
    <code>&lt;template&gt;</code> element in a <code>.vue</code> file.</p>
<h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates" data-scroll="">X-Templates</a></h3>
<p>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then
    referencing the template by an id. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/x-template"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hello-world-template"</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello hello hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'hello-world'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'#hello-world-template'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Your x-template needs to be defined outside the DOM element to which Vue is attached.</p>
<p class="tip">These can be useful for demos with large templates or in extremely small applications, but should
    otherwise be avoided, because they separate templates from the rest of the component definition.</p>
<h2 id="Controlling-Updates"><a href="#Controlling-Updates" class="headerlink" title="Controlling Updates"
        data-scroll="">Controlling Updates</a></h2>
<p>Thanks to Vue’s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases,
    however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are
    other cases when you might want to prevent unnecessary updates.</p>
<h3 id="Forcing-an-Update"><a href="#Forcing-an-Update" class="headerlink" title="Forcing an Update"
        data-scroll="">Forcing an Update</a></h3>
<p class="tip">If you find yourself needing to force an update in Vue, in 99.99% of cases, you’ve made a mistake
    somewhere.</p>
<p>You may not have accounted for change detection caveats <a href="/v2/guide/list.html#Caveats">with arrays</a> or <a
        href="/v2/guide/list.html#Object-Change-Detection-Caveats">objects</a>, or you may be relying on state that
    isn’t tracked by Vue’s reactivity system, e.g. with <code>data</code>.</p>
<p>However, if you’ve ruled out the above and find yourself in this extremely rare situation of having to manually force
    an update, you can do so with <a href="../api/#vm-forceUpdate"><code>$forceUpdate</code></a>.</p>
<h3 id="Cheap-Static-Components-with-v-once"><a href="#Cheap-Static-Components-with-v-once" class="headerlink"
        title="Cheap Static Components with v-once" data-scroll="">Cheap Static Components with <code>v-once</code></a>
</h3>
<p>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <strong>a
        lot</strong> of static content. In these cases, you can ensure that it’s only evaluated once and then cached by
    adding the <code>v-once</code> directive to the root element, like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'terms-of-service'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string"> &lt;div v-once&gt;</span><br><span class="hljs-string"> &lt;h1&gt;Terms of Service&lt;/h1&gt;</span><br><span class="hljs-string"> ... a lot of static content ...</span><br><span class="hljs-string"> &lt;/div&gt;</span><br><span class="hljs-string"> `</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render
    a lot of static content, it’s simply not necessary unless you actually notice slow rendering – plus, it could cause
    a lot of confusion later. For example, imagine another developer who’s not familiar with <code>v-once</code> or
    simply misses it in the template. They might spend hours trying to figure out why the template isn’t updating
    correctly.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/components-dynamic-async.html">Dynamic &amp; Async
            Components</a></span> <span style="float: right"><a href="/v2/guide/transitions.html">Enter/Leave &amp; List
            Transitions</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Enter/Leave &amp; List Transitions</h1>
<script> const __pageRedirects = { '#List-Transitions': '/guide/built-ins/transition-group.html' }</script>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview" data-scroll="">Overview</a></h2>
<p>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM.
    This includes tools to:</p>
<ul>
    <li>automatically apply classes for CSS transitions and animations</li>
    <li>integrate 3rd-party CSS animation libraries, such as Animate.css</li>
    <li>use JavaScript to directly manipulate the DOM during transition hooks</li>
    <li>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</li>
</ul>
<p>On this page, we’ll only cover entering, leaving, and list transitions, but you can see the next section for <a
        href="transitioning-state.html">managing state transitions</a>.</p>
<h2 id="Transitioning-Single-Elements-Components"><a href="#Transitioning-Single-Elements-Components" class="headerlink"
        title="Transitioning Single Elements/Components" data-scroll="">Transitioning Single Elements/Components</a>
</h2>
<p>Vue provides a <code>transition</code> wrapper component, allowing you to add entering/leaving transitions for any
    element or component in the following contexts:</p>
<ul>
    <li>Conditional rendering (using <code>v-if</code>)</li>
    <li>Conditional display (using <code>v-show</code>)</li>
    <li>Dynamic components</li>
    <li>Component root nodes</li>
</ul>
<p>This is what an example looks like in action:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span><br> Toggle<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fade"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.fade-enter-active</span>, <span class="hljs-selector-class">.fade-leave-active</span> {<br> <span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">5s</span>;<br>}<br><span class="hljs-selector-class">.fade-enter</span>, <span class="hljs-selector-class">.fade-leave-to</span> <span class="hljs-comment">/* .fade-leave-active below version 2.1.8 */</span> {<br> <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="demo"><button> Toggle </button>
    <p>hello</p>
</div>
<script> new Vue({ el: '#demo', data: { show: true } })</script>
<style>
    .demo-transition-enter-active,
    .demo-transition-leave-active {
        transition: opacity .5s
    }

    .demo-transition-enter,
    .demo-transition-leave-to {
        opacity: 0
    }
</style>
<p>When an element wrapped in a <code>transition</code> component is inserted or removed, this is what happens:</p>
<ol>
    <li>
        <p>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it
            does, CSS transition classes will be added/removed at appropriate timings.</p>
    </li>
    <li>
        <p>If the transition component provided <a href="#JavaScript-Hooks">JavaScript hooks</a>, these hooks will be
            called at appropriate timings.</p>
    </li>
    <li>
        <p>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for
            insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation
            frame, different from Vue’s concept of <code>nextTick</code>).</p>
    </li>
</ol>
<h3 id="Transition-Classes"><a href="#Transition-Classes" class="headerlink" title="Transition Classes"
        data-scroll="">Transition Classes</a></h3>
<p>There are six classes applied for enter/leave transitions.</p>
<ol>
    <li>
        <p><code>v-enter</code>: Starting state for enter. Added before element is inserted, removed one frame after
            element is inserted.</p>
    </li>
    <li>
        <p><code>v-enter-active</code>: Active state for enter. Applied during the entire entering phase. Added before
            element is inserted, removed when transition/animation finishes. This class can be used to define the
            duration, delay and easing curve for the entering transition.</p>
    </li>
    <li>
        <p><code>v-enter-to</code>: <strong>Only available in versions 2.1.8+.</strong> Ending state for enter. Added
            one frame after element is inserted (at the same time <code>v-enter</code> is removed), removed when
            transition/animation finishes.</p>
    </li>
    <li>
        <p><code>v-leave</code>: Starting state for leave. Added immediately when a leaving transition is triggered,
            removed after one frame.</p>
    </li>
    <li>
        <p><code>v-leave-active</code>: Active state for leave. Applied during the entire leaving phase. Added
            immediately when leave transition is triggered, removed when the transition/animation finishes. This class
            can be used to define the duration, delay and easing curve for the leaving transition.</p>
    </li>
    <li>
        <p><code>v-leave-to</code>: <strong>Only available in versions 2.1.8+.</strong> Ending state for leave. Added
            one frame after a leaving transition is triggered (at the same time <code>v-leave</code> is removed),
            removed when the transition/animation finishes.</p>
    </li>
</ol>
<p><img src="/images/transition.png" alt="Transition Diagram"></p>
<p>Each of these classes will be prefixed with the name of the transition. Here the <code>v-</code> prefix is the
    default when you use a <code>&lt;transition&gt;</code> element with no name. If you use
    <code>&lt;transition name="my-transition"&gt;</code> for example, then the <code>v-enter</code> class would instead
    be <code>my-transition-enter</code>.</p>
<p><code>v-enter-active</code> and <code>v-leave-active</code> give you the ability to specify different easing curves
    for enter/leave transitions, which you’ll see an example of in the following section.</p>
<h3 id="CSS-Transitions"><a href="#CSS-Transitions" class="headerlink" title="CSS Transitions" data-scroll="">CSS
        Transitions</a></h3>
<p>One of the most common transition types uses CSS transitions. Here’s an example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-1"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span><br> Toggle render<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"slide-fade"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-1'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-comment">/* Enter and leave animations can use different */</span><br><span class="hljs-comment">/* durations and timing functions. */</span><br><span class="hljs-selector-class">.slide-fade-enter-active</span> {<br> <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">3s</span> ease;<br>}<br><span class="hljs-selector-class">.slide-fade-leave-active</span> {<br> <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">8s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1.0</span>);<br>}<br><span class="hljs-selector-class">.slide-fade-enter</span>, <span class="hljs-selector-class">.slide-fade-leave-to</span><br><span class="hljs-comment">/* .slide-fade-leave-active below version 2.1.8 */</span> {<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">10px</span>);<br> <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-1" class="demo"><button> Toggle render </button>
    <p>hello</p>
</div>
<script> new Vue({ el: '#example-1', data: { show: true } })</script>
<style>
    .slide-fade-enter-active {
        transition: all .3s ease;
    }

    .slide-fade-leave-active {
        transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
    }

    .slide-fade-enter,
    .slide-fade-leave-to {
        transform: translateX(10px);
        opacity: 0;
    }
</style>
<h3 id="CSS-Animations"><a href="#CSS-Animations" class="headerlink" title="CSS Animations" data-scroll="">CSS
        Animations</a></h3>
<p>CSS animations are applied in the same way as CSS transitions, the difference being that <code>v-enter</code> is not
    removed immediately after the element is inserted, but on an <code>animationend</code> event.</p>
<p>Here’s an example, omitting prefixed CSS rules for the sake of brevity:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-2"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span>Toggle show<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"bounce"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-2'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.bounce-enter-active</span> {<br> <span class="hljs-attribute">animation</span>: bounce-in .<span class="hljs-number">5s</span>;<br>}<br><span class="hljs-selector-class">.bounce-leave-active</span> {<br> <span class="hljs-attribute">animation</span>: bounce-in .<span class="hljs-number">5s</span> reverse;<br>}<br><span class="hljs-keyword">@keyframes</span> bounce-in {<br> <span class="hljs-number">0%</span> {<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br> }<br> <span class="hljs-number">50%</span> {<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);<br> }<br> <span class="hljs-number">100%</span> {<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-2" class="demo"><button>Toggle show</button>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum
        id. Pellentesque habitant morbi tristique senectus et netus.</p>
</div>
<style>
    .bounce-enter-active {
        -webkit-animation: bounce-in .5s;
        animation: bounce-in .5s;
    }

    .bounce-leave-active {
        -webkit-animation: bounce-in .5s reverse;
        animation: bounce-in .5s reverse;
    }

    @keyframes bounce-in {
        0% {
            -webkit-transform: scale(0);
            transform: scale(0);
        }

        50% {
            -webkit-transform: scale(1.5);
            transform: scale(1.5);
        }

        100% {
            -webkit-transform: scale(1);
            transform: scale(1);
        }
    }

    @-webkit-keyframes bounce-in {
        0% {
            -webkit-transform: scale(0);
            transform: scale(0);
        }

        50% {
            -webkit-transform: scale(1.5);
            transform: scale(1.5);
        }

        100% {
            -webkit-transform: scale(1);
            transform: scale(1);
        }
    }
</style>
<script> new Vue({ el: '#example-2', data: { show: true } })</script>
<h3 id="Custom-Transition-Classes"><a href="#Custom-Transition-Classes" class="headerlink"
        title="Custom Transition Classes" data-scroll="">Custom Transition Classes</a></h3>
<p>You can also specify custom transition classes by providing the following attributes:</p>
<ul>
    <li><code>enter-class</code></li>
    <li><code>enter-active-class</code></li>
    <li><code>enter-to-class</code> (2.1.8+)</li>
    <li><code>leave-class</code></li>
    <li><code>leave-active-class</code></li>
    <li><code>leave-to-class</code> (2.1.8+)</li>
</ul>
<p>These will override the conventional class names. This is especially useful when you want to combine Vue’s transition
    system with an existing CSS animation library, such as <a target="_blank" rel="noopener"
        href="https://daneden.github.io/animate.css/">Animate.css</a>.</p>
<p>Here’s an example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-3"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span><br> Toggle render<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">name</span>=<span class="hljs-string">"custom-classes-transition"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">"animated tada"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">"animated bounceOutRight"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-3'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">
<div id="example-3" class="demo"><button> Toggle render </button>
    <p>hello</p>
</div>
<script> new Vue({ el: '#example-3', data: { show: true } })</script>
<h3 id="Using-Transitions-and-Animations-Together"><a href="#Using-Transitions-and-Animations-Together"
        class="headerlink" title="Using Transitions and Animations Together" data-scroll="">Using Transitions and
        Animations Together</a></h3>
<p>Vue needs to attach event listeners in order to know when a transition has ended. It can either be
    <code>transitionend</code> or <code>animationend</code>, depending on the type of CSS rules applied. If you are only
    using one or the other, Vue can automatically detect the correct type.</p>
<p>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by
    Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you
    want Vue to care about in a <code>type</code> attribute, with a value of either <code>animation</code> or
    <code>transition</code>.</p>
<h3 id="Explicit-Transition-Durations"><a href="#Explicit-Transition-Durations" class="headerlink"
        title="Explicit Transition Durations" data-scroll="">Explicit Transition Durations</a></h3>
<blockquote>
    <p>New in 2.2.0+</p>
</blockquote>
<p>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first
    <code>transitionend</code> or <code>animationend</code> event on the root transition element. However, this may not
    always be desired - for example, we may have a choreographed transition sequence where some nested inner elements
    have a delayed transition or a longer transition duration than the root transition element.</p>
<p>In such cases you can specify an explicit transition duration (in milliseconds) using the <code>duration</code> prop
    on the <code>&lt;transition&gt;</code> component:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">:duration</span>=<span class="hljs-string">"1000"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can also specify separate values for enter and leave durations:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">:duration</span>=<span class="hljs-string">"{ enter: 500, leave: 800 }"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="JavaScript-Hooks"><a href="#JavaScript-Hooks" class="headerlink" title="JavaScript Hooks"
        data-scroll="">JavaScript Hooks</a></h3>
<p>You can also define JavaScript hooks in attributes:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">"beforeEnter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">"enter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:after-enter</span>=<span class="hljs-string">"afterEnter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enter-cancelled</span>=<span class="hljs-string">"enterCancelled"</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-leave</span>=<span class="hljs-string">"beforeLeave"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">"leave"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:after-leave</span>=<span class="hljs-string">"afterLeave"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:leave-cancelled</span>=<span class="hljs-string">"leaveCancelled"</span></span><br><span class="hljs-tag">&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-comment">// --------</span><br> <span class="hljs-comment">// ENTERING</span><br> <span class="hljs-comment">// --------</span><br><br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-comment">// the done callback is optional when</span><br> <span class="hljs-comment">// used in combination with CSS</span><br> <span class="hljs-attr">enter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-title function_">done</span>()<br> },<br> <span class="hljs-attr">afterEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-attr">enterCancelled</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br><br> <span class="hljs-comment">// --------</span><br> <span class="hljs-comment">// LEAVING</span><br> <span class="hljs-comment">// --------</span><br><br> <span class="hljs-attr">beforeLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-comment">// the done callback is optional when</span><br> <span class="hljs-comment">// used in combination with CSS</span><br> <span class="hljs-attr">leave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-title function_">done</span>()<br> },<br> <span class="hljs-attr">afterLeave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-comment">// leaveCancelled only available with v-show</span><br> <span class="hljs-attr">leaveCancelled</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>These hooks can be used in combination with CSS transitions/animations or on their own.</p>
<p class="tip">When using JavaScript-only transitions, <strong>the <code>done</code> callbacks are required for the
        <code>enter</code> and <code>leave</code> hooks</strong>. Otherwise, the hooks will be called synchronously and
    the transition will finish immediately.</p>
<p class="tip">It’s also a good idea to explicitly add <code>v-bind:css="false"</code> for JavaScript-only transitions
    so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the
    transition.</p>
<p>Now let’s dive into an example. Here’s a JavaScript transition using Velocity.js:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">Velocity works very much like jQuery.animate and is</span><br><span class="hljs-comment">a great option for JavaScript animations</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-4"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"show = !show"</span>&gt;</span><br> Toggle<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">"beforeEnter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">"enter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">"leave"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:css</span>=<span class="hljs-string">"false"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span><br> Demo<br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-4'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">0</span><br> el.<span class="hljs-property">style</span>.<span class="hljs-property">transformOrigin</span> = <span class="hljs-string">'left'</span><br> },<br> <span class="hljs-attr">enter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-title class_">Velocity</span>(el, { <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'1.4em'</span> }, { <span class="hljs-attr">duration</span>: <span class="hljs-number">300</span> })<br> <span class="hljs-title class_">Velocity</span>(el, { <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'1em'</span> }, { <span class="hljs-attr">complete</span>: done })<br> },<br> <span class="hljs-attr">leave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-title class_">Velocity</span>(el, { <span class="hljs-attr">translateX</span>: <span class="hljs-string">'15px'</span>, <span class="hljs-attr">rotateZ</span>: <span class="hljs-string">'50deg'</span> }, { <span class="hljs-attr">duration</span>: <span class="hljs-number">600</span> })<br> <span class="hljs-title class_">Velocity</span>(el, { <span class="hljs-attr">rotateZ</span>: <span class="hljs-string">'100deg'</span> }, { <span class="hljs-attr">loop</span>: <span class="hljs-number">2</span> })<br> <span class="hljs-title class_">Velocity</span>(el, {<br> <span class="hljs-attr">rotateZ</span>: <span class="hljs-string">'45deg'</span>,<br> <span class="hljs-attr">translateY</span>: <span class="hljs-string">'30px'</span>,<br> <span class="hljs-attr">translateX</span>: <span class="hljs-string">'30px'</span>,<br> <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span><br> }, { <span class="hljs-attr">complete</span>: done })<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="example-4" class="demo"><button> Toggle </button>
    <!---->
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
<script> new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } } })</script>
<h2 id="Transitions-on-Initial-Render"><a href="#Transitions-on-Initial-Render" class="headerlink"
        title="Transitions on Initial Render" data-scroll="">Transitions on Initial Render</a></h2>
<p>If you also want to apply a transition on the initial render of a node, you can add the <code>appear</code>
    attribute:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">appear</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>By default, this will use the transitions specified for entering and leaving. If you’d like however, you can also
    specify custom CSS classes:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">appear</span></span><br><span class="hljs-tag"> <span class="hljs-attr">appear-class</span>=<span class="hljs-string">"custom-appear-class"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">appear-to-class</span>=<span class="hljs-string">"custom-appear-to-class"</span> (<span class="hljs-attr">2.1.8</span>+)</span><br><span class="hljs-tag"> <span class="hljs-attr">appear-active-class</span>=<span class="hljs-string">"custom-appear-active-class"</span></span><br><span class="hljs-tag">&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>and custom JavaScript hooks:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">appear</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-appear</span>=<span class="hljs-string">"customBeforeAppearHook"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:appear</span>=<span class="hljs-string">"customAppearHook"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:after-appear</span>=<span class="hljs-string">"customAfterAppearHook"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:appear-cancelled</span>=<span class="hljs-string">"customAppearCancelledHook"</span></span><br><span class="hljs-tag">&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In the example above, either <code>appear</code> attribute or <code>v-on:appear</code> hook will cause an appear
    transition.</p>
<h2 id="Transitioning-Between-Elements"><a href="#Transitioning-Between-Elements" class="headerlink"
        title="Transitioning Between Elements" data-scroll="">Transitioning Between Elements</a></h2>
<p>We discuss <a href="#Transitioning-Between-Components">transitioning between components</a> later, but you can also
    transition between raw elements using <code>v-if</code>/<code>v-else</code>. One of the most common two-element
    transitions is between a list container and a message describing an empty list:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"items.length &gt; 0"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>Sorry, no items found.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This works well, but there’s one caveat to be aware of:</p>
<p class="tip">When toggling between elements that have <strong>the same tag name</strong>, you must tell Vue that they
    are distinct elements by giving them unique <code>key</code> attributes. Otherwise, Vue’s compiler will only replace
    the content of the element for efficiency. Even when technically unnecessary though, <strong>it’s considered good
        practice to always key multiple items within a <code>&lt;transition&gt;</code> component.</strong></p>
<p>For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"isEditing"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"save"</span>&gt;</span><br> Save<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"edit"</span>&gt;</span><br> Edit<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In these cases, you can also use the <code>key</code> attribute to transition between different states of the same
    element. Instead of using <code>v-if</code> and <code>v-else</code>, the above example could be rewritten as:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"isEditing"</span>&gt;</span><br> {{ isEditing ? 'Save' : 'Edit' }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It’s actually possible to transition between any number of elements, either by using multiple <code>v-if</code>s or
    binding a single element to a dynamic property. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"docState === 'saved'"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"saved"</span>&gt;</span><br> Edit<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"docState === 'edited'"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"edited"</span>&gt;</span><br> Save<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"docState === 'editing'"</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"editing"</span>&gt;</span><br> Cancel<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Which could also be written as:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"docState"</span>&gt;</span><br> {{ buttonMessage }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">buttonMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">docState</span>) {<br> <span class="hljs-keyword">case</span> <span class="hljs-string">'saved'</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">'Edit'</span><br> <span class="hljs-keyword">case</span> <span class="hljs-string">'edited'</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">'Save'</span><br> <span class="hljs-keyword">case</span> <span class="hljs-string">'editing'</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">'Cancel'</span><br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Transition-Modes"><a href="#Transition-Modes" class="headerlink" title="Transition Modes"
        data-scroll="">Transition Modes</a></h3>
<p>There’s still one problem though. Try clicking the button below:</p>
<div id="no-mode-demo" class="demo"><button> off </button></div>
<script> new Vue({ el: '#no-mode-demo', data: { on: false } })</script>
<style>
    .no-mode-fade-enter-active,
    .no-mode-fade-leave-active {
        transition: opacity .5s
    }

    .no-mode-fade-enter,
    .no-mode-fade-leave-active {
        opacity: 0
    }
</style>
<p>As it’s transitioning between the “on” button and the “off” button, both buttons are rendered - one transitioning out
    while the other transitions in. This is the default behavior of <code>&lt;transition&gt;</code> - entering and
    leaving happens simultaneously.</p>
<p>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</p>
<div id="no-mode-absolute-demo" class="demo">
    <div class="no-mode-absolute-demo-wrapper"><button> off </button></div>
</div>
<script> new Vue({ el: '#no-mode-absolute-demo', data: { on: false } })</script>
<style>
    .no-mode-absolute-demo-wrapper {
        position: relative;
        height: 18px;
    }

    .no-mode-absolute-demo-wrapper button {
        position: absolute;
    }

    .no-mode-absolute-fade-enter-active,
    .no-mode-absolute-fade-leave-active {
        transition: opacity .5s;
    }

    .no-mode-absolute-fade-enter,
    .no-mode-absolute-fade-leave-active {
        opacity: 0;
    }
</style>
<p>And then maybe also translated so that they look like slide transitions:</p>
<div id="no-mode-translate-demo" class="demo">
    <div class="no-mode-translate-demo-wrapper"><button> off </button></div>
</div>
<script> new Vue({ el: '#no-mode-translate-demo', data: { on: false } })</script>
<style>
    .no-mode-translate-demo-wrapper {
        position: relative;
        height: 18px;
    }

    .no-mode-translate-demo-wrapper button {
        position: absolute;
    }

    .no-mode-translate-fade-enter-active,
    .no-mode-translate-fade-leave-active {
        transition: all 1s;
    }

    .no-mode-translate-fade-enter,
    .no-mode-translate-fade-leave-active {
        opacity: 0;
    }

    .no-mode-translate-fade-enter {
        transform: translateX(31px);
    }

    .no-mode-translate-fade-leave-active {
        transform: translateX(-31px);
    }
</style>
<p>Simultaneous entering and leaving transitions aren’t always desirable though, so Vue offers some alternative
    <strong>transition modes</strong>:</p>
<ul>
    <li>
        <p><code>in-out</code>: New element transitions in first, then when complete, the current element transitions
            out.</p>
    </li>
    <li>
        <p><code>out-in</code>: Current element transitions out first, then when complete, the new element transitions
            in.</p>
    </li>
</ul>
<p>Now let’s update the transition for our on/off buttons with <code>out-in</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fade"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"out-in"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- ... the buttons ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="with-mode-demo" class="demo"><button> off </button></div>
<script> new Vue({ el: '#with-mode-demo', data: { on: false } })</script>
<style>
    .with-mode-fade-enter-active,
    .with-mode-fade-leave-active {
        transition: opacity .5s
    }

    .with-mode-fade-enter,
    .with-mode-fade-leave-active {
        opacity: 0
    }
</style>
<p>With one attribute addition, we’ve fixed that original transition without having to add any special styling.</p>
<p>The <code>in-out</code> mode isn’t used as often, but can sometimes be useful for a slightly different transition
    effect. Let’s try combining it with the slide-fade transition we worked on earlier:</p>
<div id="in-out-translate-demo" class="demo">
    <div class="in-out-translate-demo-wrapper"><button> off </button></div>
</div>
<script> new Vue({ el: '#in-out-translate-demo', data: { on: false } })</script>
<style>
    .in-out-translate-demo-wrapper {
        position: relative;
        height: 18px;
    }

    .in-out-translate-demo-wrapper button {
        position: absolute;
    }

    .in-out-translate-fade-enter-active,
    .in-out-translate-fade-leave-active {
        transition: all .5s;
    }

    .in-out-translate-fade-enter,
    .in-out-translate-fade-leave-active {
        opacity: 0;
    }

    .in-out-translate-fade-enter {
        transform: translateX(31px);
    }

    .in-out-translate-fade-leave-active {
        transform: translateX(-31px);
    }
</style>
<p>Pretty cool, right?</p>
<h2 id="Transitioning-Between-Components"><a href="#Transitioning-Between-Components" class="headerlink"
        title="Transitioning Between Components" data-scroll="">Transitioning Between Components</a></h2>
<p>Transitioning between components is even simpler - we don’t even need the <code>key</code> attribute. Instead, we
    wrap a <a href="components.html#Dynamic-Components">dynamic component</a>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"component-fade"</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"out-in"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#transition-components-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">view</span>: <span class="hljs-string">'v-a'</span><br> },<br> <span class="hljs-attr">components</span>: {<br> <span class="hljs-string">'v-a'</span>: {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;Component A&lt;/div&gt;'</span><br> },<br> <span class="hljs-string">'v-b'</span>: {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;Component B&lt;/div&gt;'</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.component-fade-enter-active</span>, <span class="hljs-selector-class">.component-fade-leave-active</span> {<br> <span class="hljs-attribute">transition</span>: opacity .<span class="hljs-number">3s</span> ease;<br>}<br><span class="hljs-selector-class">.component-fade-enter</span>, <span class="hljs-selector-class">.component-fade-leave-to</span><br><span class="hljs-comment">/* .component-fade-leave-active below version 2.1.8 */</span> {<br> <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="transition-components-demo" class="demo"><input type="radio" value="v-a" id="a" name="view"><label
        for="a">A</label> <input type="radio" value="v-b" id="b" name="view"><label for="b">B</label>
    <div>Component A</div>
</div>
<style>
    .component-fade-enter-active,
    .component-fade-leave-active {
        transition: opacity .3s ease;
    }

    .component-fade-enter,
    .component-fade-leave-to {
        opacity: 0;
    }
</style>
<script> new Vue({ el: '#transition-components-demo', data: { view: 'v-a' }, components: { 'v-a': { template: '<div>Component A</div>' }, 'v-b': { template: '<div>Component B</div>' } } })</script>
<h2 id="List-Transitions"><a href="#List-Transitions" class="headerlink" title="List Transitions" data-scroll="">List
        Transitions</a></h2>
<p>So far, we’ve managed transitions for:</p>
<ul>
    <li>Individual nodes</li>
    <li>Multiple nodes where only 1 is rendered at a time</li>
</ul>
<p>So what about for when we have a whole list of items we want to render simultaneously, for example with
    <code>v-for</code>? In this case, we’ll use the <code>&lt;transition-group&gt;</code> component. Before we dive into
    an example though, there are a few things that are important to know about this component:</p>
<ul>
    <li>Unlike <code>&lt;transition&gt;</code>, it renders an actual element: a <code>&lt;span&gt;</code> by default.
        You can change the element that’s rendered with the <code>tag</code> attribute.</li>
    <li><a href="#Transition-Modes">Transition modes</a> are not available, because we are no longer alternating between
        mutually exclusive elements.</li>
    <li>Elements inside are <strong>always required</strong> to have a unique <code>key</code> attribute.</li>
    <li>CSS transition classes will be applied to inner elements and not to the group/container itself.</li>
</ul>
<h3 id="List-Entering-Leaving-Transitions"><a href="#List-Entering-Leaving-Transitions" class="headerlink"
        title="List Entering/Leaving Transitions" data-scroll="">List Entering/Leaving Transitions</a></h3>
<p>Now let’s dive into an example, transitioning entering and leaving using the same CSS classes we’ve used previously:
</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"add"</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"remove"</span>&gt;</span>Remove<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"p"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span><br> {{ item }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#list-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],<br> <span class="hljs-attr">nextNum</span>: <span class="hljs-number">10</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">randomIndex</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>)<br> },<br> <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextNum</span>++)<br> },<br> <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">1</span>)<br> },<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.list-item</span> {<br> <span class="hljs-attribute">display</span>: inline-block;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;<br>}<br><span class="hljs-selector-class">.list-enter-active</span>, <span class="hljs-selector-class">.list-leave-active</span> {<br> <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br>}<br><span class="hljs-selector-class">.list-enter</span>, <span class="hljs-selector-class">.list-leave-to</span> <span class="hljs-comment">/* .list-leave-active below version 2.1.8 */</span> {<br> <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">30px</span>);<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="list-demo" class="demo"><button>Add</button> <button>Remove</button>
    <p><span class="list-item"> 1 </span><span class="list-item"> 2 </span><span class="list-item"> 3 </span><span
            class="list-item"> 4 </span><span class="list-item"> 5 </span><span class="list-item"> 6 </span><span
            class="list-item"> 7 </span><span class="list-item"> 8 </span><span class="list-item"> 9 </span></p>
</div>
<script> new Vue({ el: '#list-demo', data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } })</script>
<style>
    .list-item {
        display: inline-block;
        margin-right: 10px;
    }

    .list-enter-active,
    .list-leave-active {
        transition: all 1s;
    }

    .list-enter,
    .list-leave-to {
        opacity: 0;
        transform: translateY(30px);
    }
</style>
<p>There’s one problem with this example. When you add or remove an item, the ones around it instantly snap into their
    new place instead of smoothly transitioning. We’ll fix that later.</p>
<h3 id="List-Move-Transitions"><a href="#List-Move-Transitions" class="headerlink" title="List Move Transitions"
        data-scroll="">List Move Transitions</a></h3>
<p>The <code>&lt;transition-group&gt;</code> component has another trick up its sleeve. It can not only animate entering
    and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition
    of <strong>the <code>v-move</code> class</strong>, which is added when items are changing positions. Like the other
    classes, its prefix will match the value of a provided <code>name</code> attribute and you can also manually specify
    a class with the <code>move-class</code> attribute.</p>
<p>This class is mostly useful for specifying the transition timing and easing curve, as you’ll see below:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"flip-list-demo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"shuffle"</span>&gt;</span>Shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"flip-list"</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"ul"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item"</span>&gt;</span><br> {{ item }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#flip-list-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">shuffle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = _.<span class="hljs-title function_">shuffle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.flip-list-move</span> {<br> <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">1s</span>;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
<div id="flip-list-demo" class="demo"><button>Shuffle</button>
    <ul>
        <li> 1 </li>
        <li> 2 </li>
        <li> 3 </li>
        <li> 4 </li>
        <li> 5 </li>
        <li> 6 </li>
        <li> 7 </li>
        <li> 8 </li>
        <li> 9 </li>
    </ul>
</div>
<script> new Vue({ el: '#flip-list-demo', data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } })</script>
<style>
    .flip-list-move {
        transition: transform 1s;
    }
</style>
<p>This might seem like magic, but under the hood, Vue is using an animation technique called <a target="_blank"
        rel="noopener" href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a> to smoothly transition elements
    from their old position to their new position using transforms.</p>
<p>We can combine this technique with our previous implementation to animate every possible change to our list!</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list-complete-demo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"shuffle"</span>&gt;</span>Shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"add"</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"remove"</span>&gt;</span>Remove<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"list-complete"</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"p"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-complete-item"</span></span><br><span class="hljs-tag"> &gt;</span><br> {{ item }}<br> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#list-complete-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>],<br> <span class="hljs-attr">nextNum</span>: <span class="hljs-number">10</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">randomIndex</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>)<br> },<br> <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextNum</span>++)<br> },<br> <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">1</span>)<br> },<br> <span class="hljs-attr">shuffle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = _.<span class="hljs-title function_">shuffle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.list-complete-item</span> {<br> <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;<br> <span class="hljs-attribute">display</span>: inline-block;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;<br>}<br><span class="hljs-selector-class">.list-complete-enter</span>, <span class="hljs-selector-class">.list-complete-leave-to</span><br><span class="hljs-comment">/* .list-complete-leave-active below version 2.1.8 */</span> {<br> <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">30px</span>);<br>}<br><span class="hljs-selector-class">.list-complete-leave-active</span> {<br> <span class="hljs-attribute">position</span>: absolute;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
<div id="list-complete-demo" class="demo"><button>Shuffle</button> <button>Add</button> <button>Remove</button>
    <p><span class="list-complete-item"> 1 </span><span class="list-complete-item"> 2 </span><span
            class="list-complete-item"> 3 </span><span class="list-complete-item"> 4 </span><span
            class="list-complete-item"> 5 </span><span class="list-complete-item"> 6 </span><span
            class="list-complete-item"> 7 </span><span class="list-complete-item"> 8 </span><span
            class="list-complete-item"> 9 </span></p>
</div>
<script> new Vue({ el: '#list-complete-demo', data: { items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, shuffle: function () { this.items = _.shuffle(this.items) } } })</script>
<style>
    .list-complete-item {
        transition: all 1s;
        display: inline-block;
        margin-right: 10px;
    }

    .list-complete-enter,
    .list-complete-leave-to {
        opacity: 0;
        transform: translateY(30px);
    }

    .list-complete-leave-active {
        position: absolute;
    }
</style>
<p class="tip">One important note is that these FLIP transitions do not work with elements set to
    <code>display: inline</code>. As an alternative, you can use <code>display: inline-block</code> or place elements in
    a flex context.</p>
<p>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be <a
        target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-list-move-transitions">transitioned
        too</a>:</p>
<div id="sudoku-demo" class="demo"><strong>Lazy Sudoku</strong>
    <p>Keep hitting the shuffle button until you win.</p> <button> Shuffle </button>
    <div class="sudoku-container">
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
        <div class="cell"> 1 </div>
        <div class="cell"> 2 </div>
        <div class="cell"> 3 </div>
        <div class="cell"> 4 </div>
        <div class="cell"> 5 </div>
        <div class="cell"> 6 </div>
        <div class="cell"> 7 </div>
        <div class="cell"> 8 </div>
        <div class="cell"> 9 </div>
    </div>
</div>
<script> new Vue({ el: '#sudoku-demo', data: { cells: Array.apply(null, { length: 81 }).map(function (_, index) { return { id: index, number: index % 9 + 1 } }) }, methods: { shuffle: function () { this.cells = _.shuffle(this.cells) } } })</script>
<style>
    .sudoku-container {
        display: flex;
        flex-wrap: wrap;
        width: 238px;
        margin-top: 10px;
    }

    .cell {
        display: flex;
        justify-content: space-around;
        align-items: center;
        width: 25px;
        height: 25px;
        border: 1px solid #aaa;
        margin-right: -1px;
        margin-bottom: -1px;
    }

    .cell:nth-child(3n) {
        margin-right: 0;
    }

    .cell:nth-child(27n) {
        margin-bottom: 0;
    }

    .cell-move {
        transition: transform 1s;
    }
</style>
<h3 id="Staggering-List-Transitions"><a href="#Staggering-List-Transitions" class="headerlink"
        title="Staggering List Transitions" data-scroll="">Staggering List Transitions</a></h3>
<p>By communicating with JavaScript transitions through data attributes, it’s also possible to stagger transitions in a
    list:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"staggered-list-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"query"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span></span><br><span class="hljs-tag"> <span class="hljs-attr">name</span>=<span class="hljs-string">"staggered-fade"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">tag</span>=<span class="hljs-string">"ul"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:css</span>=<span class="hljs-string">"false"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">"beforeEnter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">"enter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">"leave"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in computedList"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.msg"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:data-index</span>=<span class="hljs-string">"index"</span></span><br><span class="hljs-tag"> &gt;</span>{{ item.msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#staggered-list-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">query</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">list</span>: [<br> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Bruce Lee'</span> },<br> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Jackie Chan'</span> },<br> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Chuck Norris'</span> },<br> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Jet Li'</span> },<br> { <span class="hljs-attr">msg</span>: <span class="hljs-string">'Kung Fury'</span> }<br> ]<br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">computedList</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span><br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {<br> <span class="hljs-keyword">return</span> item.<span class="hljs-property">msg</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(vm.<span class="hljs-property">query</span>.<span class="hljs-title function_">toLowerCase</span>()) !== -<span class="hljs-number">1</span><br> })<br> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">0</span><br> el.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-number">0</span><br> },<br> <span class="hljs-attr">enter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-keyword">var</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">150</span><br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title class_">Velocity</span>(<br> el,<br> { <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">height</span>: <span class="hljs-string">'1.6em'</span> },<br> { <span class="hljs-attr">complete</span>: done }<br> )<br> }, delay)<br> },<br> <span class="hljs-attr">leave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-keyword">var</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">150</span><br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title class_">Velocity</span>(<br> el,<br> { <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">0</span> },<br> { <span class="hljs-attr">complete</span>: done }<br> )<br> }, delay)<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
<div id="example-5" class="demo"><input>
    <ul>
        <li data-index="0">Bruce Lee</li>
        <li data-index="1">Jackie Chan</li>
        <li data-index="2">Chuck Norris</li>
        <li data-index="3">Jet Li</li>
        <li data-index="4">Kung Fury</li>
    </ul>
</div>
<script> new Vue({ el: '#example-5', data: { query: '', list: [{ msg: 'Bruce Lee' }, { msg: 'Jackie Chan' }, { msg: 'Chuck Norris' }, { msg: 'Jet Li' }, { msg: 'Kung Fury' }] }, computed: { computedList: function () { var vm = this return this.list.filter(function (item) { return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 }) } }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.height = 0 }, enter: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity(el, { opacity: 1, height: '1.6em' }, { complete: done }) }, delay) }, leave: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity(el, { opacity: 0, height: 0 }, { complete: done }) }, delay) } } })</script>
<h2 id="Reusable-Transitions"><a href="#Reusable-Transitions" class="headerlink" title="Reusable Transitions"
        data-scroll="">Reusable Transitions</a></h2>
<p>Transitions can be reused through Vue’s component system. To create a reusable transition, all you have to do is
    place a <code>&lt;transition&gt;</code> or <code>&lt;transition-group&gt;</code> component at the root, then pass
    any children into the transition component.</p>
<p>Here’s an example using a template component:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-special-transition'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'\</span><br><span class="hljs-string"> &lt;transition\</span><br><span class="hljs-string"> name="very-special-transition"\</span><br><span class="hljs-string"> mode="out-in"\</span><br><span class="hljs-string"> v-on:before-enter="beforeEnter"\</span><br><span class="hljs-string"> v-on:after-enter="afterEnter"\</span><br><span class="hljs-string"> &gt;\</span><br><span class="hljs-string"> &lt;slot&gt;&lt;/slot&gt;\</span><br><span class="hljs-string"> &lt;/transition&gt;\</span><br><span class="hljs-string"> '</span>,<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-attr">afterEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And <a href="render-function.html#Functional-Components">functional components</a> are especially well-suited to this
    task:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-special-transition'</span>, {<br> <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement, context</span>) {<br> <span class="hljs-keyword">var</span> data = {<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">name</span>: <span class="hljs-string">'very-special-transition'</span>,<br> <span class="hljs-attr">mode</span>: <span class="hljs-string">'out-in'</span><br> },<br> <span class="hljs-attr">on</span>: {<br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-attr">afterEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// ...</span><br> }<br> }<br> }<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'transition'</span>, data, context.<span class="hljs-property">children</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Dynamic-Transitions"><a href="#Dynamic-Transitions" class="headerlink" title="Dynamic Transitions"
        data-scroll="">Dynamic Transitions</a></h2>
<p>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the
    <code>name</code> attribute to a dynamic property.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">v-bind:name</span>=<span class="hljs-string">"transitionName"</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This can be useful when you’ve defined CSS transitions/animations using Vue’s transition class conventions and want
    to switch between them.</p>
<p>Really though, any transition attribute can be dynamically bound. And it’s not only attributes. Since event hooks are
    methods, they have access to any data in the context. That means depending on the state of your component, your
    JavaScript transitions can behave differently.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamic-fade-demo"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><br> Fade In: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"fadeInDuration"</span> <span class="hljs-attr">min</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">v-bind:max</span>=<span class="hljs-string">"maxFadeDuration"</span>&gt;</span><br> Fade Out: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"fadeOutDuration"</span> <span class="hljs-attr">min</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">v-bind:max</span>=<span class="hljs-string">"maxFadeDuration"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:css</span>=<span class="hljs-string">"false"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">"beforeEnter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">"enter"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">"leave"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"show"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"stop"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"stop = false; show = false"</span></span><br><span class="hljs-tag"> &gt;</span>Start animating<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-else</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"stop = true"</span></span><br><span class="hljs-tag"> &gt;</span>Stop it!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#dynamic-fade-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">fadeInDuration</span>: <span class="hljs-number">1000</span>,<br> <span class="hljs-attr">fadeOutDuration</span>: <span class="hljs-number">1000</span>,<br> <span class="hljs-attr">maxFadeDuration</span>: <span class="hljs-number">1500</span>,<br> <span class="hljs-attr">stop</span>: <span class="hljs-literal">true</span><br> },<br> <span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span> = <span class="hljs-literal">false</span><br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">0</span><br> },<br> <span class="hljs-attr">enter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span><br> <span class="hljs-title class_">Velocity</span>(el,<br> { <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span> },<br> {<br> <span class="hljs-attr">duration</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">fadeInDuration</span>,<br> <span class="hljs-attr">complete</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">done</span>()<br> <span class="hljs-keyword">if</span> (!vm.<span class="hljs-property">stop</span>) vm.<span class="hljs-property">show</span> = <span class="hljs-literal">false</span><br> }<br> }<br> )<br> },<br> <span class="hljs-attr">leave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) {<br> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span><br> <span class="hljs-title class_">Velocity</span>(el,<br> { <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span> },<br> {<br> <span class="hljs-attr">duration</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">fadeOutDuration</span>,<br> <span class="hljs-attr">complete</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">done</span>()<br> vm.<span class="hljs-property">show</span> = <span class="hljs-literal">true</span><br> }<br> }<br> )<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
<div id="dynamic-fade-demo" class="demo"> Fade In: <input type="range" min="0" max="1500"> Fade Out: <input type="range"
        min="0" max="1500">
    <p style="opacity: 0.00337407;" class="velocity-animating">hello</p> <button>Start animating</button>
</div>
<script> new Vue({ el: '#dynamic-fade-demo', data: { show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true }, mounted: function () { this.show = false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 }, enter: function (el, done) { var vm = this Velocity(el, { opacity: 1 }, { duration: this.fadeInDuration, complete: function () { done() if (!vm.stop) vm.show = false } }) }, leave: function (el, done) { var vm = this Velocity(el, { opacity: 0 }, { duration: this.fadeOutDuration, complete: function () { done() vm.show = true } }) } } })</script>
<p>Finally, the ultimate way of creating dynamic transitions is through components that accept props to change the
    nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/components-edge-cases.html">Handling Edge Cases</a></span> <span
        style="float: right"><a href="/v2/guide/transitioning-state.html">State Transitions</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>State Transitions</h1>
<p>Vue’s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating
    your data itself? For example:</p>
<ul>
    <li>numbers and calculations</li>
    <li>colors displayed</li>
    <li>the positions of SVG nodes</li>
    <li>the sizes and other properties of elements</li>
</ul>
<p>All of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can
    animate these state changes using 3rd-party libraries to tween state, in combination with Vue’s reactivity and
    component systems.</p>
<h2 id="Animating-State-with-Watchers"><a href="#Animating-State-with-Watchers" class="headerlink"
        title="Animating State with Watchers" data-scroll="">Animating State with Watchers</a></h2>
<p>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in
    the abstract, so let’s dive into an example using <a target="_blank" rel="noopener"
        href="https://greensock.com/">GreenSock</a>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.4/gsap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"animated-number-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"20"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ animatedNumber }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#animated-number-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">number</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">tweenedNumber</span>: <span class="hljs-number">0</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">animatedNumber</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedNumber</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">0</span>);<br> }<br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">number</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) {<br> gsap.<span class="hljs-title function_">to</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">tweenedNumber</span>: newValue });<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.4/gsap.min.js"></script>
<div id="animated-number-demo" class="demo"><input type="number" step="20">
    <p>0</p>
</div>
<script> new Vue({ el: '#animated-number-demo', data: { number: 0, tweenedNumber: 0 }, computed: { animatedNumber: function () { return this.tweenedNumber.toFixed(0); } }, watch: { number: function (newValue) { gsap.to(this.$data, { duration: 0.5, tweenedNumber: newValue }); } } })</script>
<p>When you update the number, the change is animated below the input. This makes for a nice demo, but what about
    something that isn’t directly stored as a number, like any valid CSS color for example? Here’s how we could
    accomplish this with <a target="_blank" rel="noopener" href="https://github.com/tweenjs/tween.js">Tween.js</a> and
    <a target="_blank" rel="noopener" href="https://github.com/brehaut/color-js">Color.js</a>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/color-js@1.0.3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-7"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"colorQuery"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">"updateColor"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Enter a color"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"updateColor"</span>&gt;</span>Update<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Preview:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"{ backgroundColor: tweenedCSSColor }"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"example-7-color-preview"</span></span><br><span class="hljs-tag"> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ tweenedCSSColor }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Color</span> = net.<span class="hljs-property">brehaut</span>.<span class="hljs-property">Color</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-7'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">colorQuery</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">color</span>: {<br> <span class="hljs-attr">red</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">green</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">blue</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span><br> },<br> <span class="hljs-attr">tweenedColor</span>: {}<br> },<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>)<br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">color</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span> () {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title function_">update</span>()) {<br> <span class="hljs-title function_">requestAnimationFrame</span>(animate)<br> }<br> }<br><br> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title class_">Tween</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span>)<br> .<span class="hljs-title function_">to</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>, <span class="hljs-number">750</span>)<br> .<span class="hljs-title function_">start</span>()<br><br> <span class="hljs-title function_">animate</span>()<br> }<br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">tweenedCSSColor</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>({<br> <span class="hljs-attr">red</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span>.<span class="hljs-property">red</span>,<br> <span class="hljs-attr">green</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span>.<span class="hljs-property">green</span>,<br> <span class="hljs-attr">blue</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span>.<span class="hljs-property">blue</span>,<br> <span class="hljs-attr">alpha</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweenedColor</span>.<span class="hljs-property">alpha</span><br> }).<span class="hljs-title function_">toCSS</span>()<br> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">updateColor</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">colorQuery</span>).<span class="hljs-title function_">toRGB</span>()<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">colorQuery</span> = <span class="hljs-string">''</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight css">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs css"><span class="hljs-selector-class">.example-7-color-preview</span> {<br> <span class="hljs-attribute">display</span>: inline-block;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdn.jsdelivr.net/npm/tween.js@16.3.4"></script>
<script src="https://cdn.jsdelivr.net/npm/color-js@1.0.3"></script>
<div id="example-7" class="demo"><input placeholder="Enter a color"> <button>Update</button>
    <p>Preview:</p> <span class="example-7-color-preview" style="background-color: rgb(0, 0, 0);"></span>
    <p>#000000</p>
</div>
<script> var Color = net.brehaut.Color new Vue({ el: '#example-7', data: { colorQuery: '', color: { red: 0, green: 0, blue: 0, alpha: 1 }, tweenedColor: {} }, created: function () { this.tweenedColor = Object.assign({}, this.color) }, watch: { color: function () { function animate() { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween(this.tweenedColor).to(this.color, 750).start() animate() } }, computed: { tweenedCSSColor: function () { return new Color({ red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha }).toCSS() } }, methods: { updateColor: function () { this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' } } })</script>
<style>
    .example-7-color-preview {
        display: inline-block;
        width: 50px;
        height: 50px;
    }
</style>
<h2 id="Dynamic-State-Transitions"><a href="#Dynamic-State-Transitions" class="headerlink"
        title="Dynamic State Transitions" data-scroll="">Dynamic State Transitions</a></h2>
<p>As with Vue’s transition components, the data backing state transitions can be updated in real time, which is
    especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be
    difficult to conceive of until you’ve played with the variables a little.</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenLite.min.js"></script>
<div id="svg-polygon-demo" class="demo"><svg width="200" height="200" class="demo-svg">
        <polygon
            points="100,45.3008 136.9778,49.1044 153.2634,82.6937 145.36539582727883,114.74011063168498 127.5674,137.9432 100,150.9988 53.6835,163.7492 20.591,125.8016 29.9961,77.2544 53.3863,35.8417"
            class="demo-polygon"></polygon>
        <circle cx="100" cy="100" r="90" class="demo-circle"></circle>
    </svg> <label>Sides: 10</label> <input type="range" min="3" max="500" class="demo-range-input"> <label>Minimum
        Radius: 50%</label> <input type="range" min="0" max="90" class="demo-range-input"> <label>Update Interval: 500
        milliseconds</label> <input type="range" min="10" max="2000" class="demo-range-input"></div>
<script> new Vue({ el: '#svg-polygon-demo', data: function () { var defaultSides = 10 var stats = Array.apply(null, { length: defaultSides }).map(function () { return 100 }) return { stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 } }, watch: { sides: function (newSides, oldSides) { var sidesDifference = newSides - oldSides if (sidesDifference > 0) { for (var i = 1; i <= sidesDifference; i++) { this.stats.push(this.newRandomValue()) } } else { var absoluteSidesDifference = Math.abs(sidesDifference) for (var i = 1; i <= absoluteSidesDifference; i++) { this.stats.shift() } } }, stats: function (newStats) { TweenLite.to(this.$data, this.updateInterval / 1000, { points: generatePoints(newStats) }) }, updateInterval: function () { this.resetInterval() } }, mounted: function () { this.resetInterval() }, methods: { randomizeStats: function () { var vm = this this.stats = this.stats.map(function () { return vm.newRandomValue() }) }, newRandomValue: function () { return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius)) }, resetInterval: function () { var vm = this clearInterval(this.interval) this.randomizeStats() this.interval = setInterval(function () { vm.randomizeStats() }, this.updateInterval) } } }) function valueToPoint(value, index, total) { var x = 0 var y = -value * 0.9 var angle = Math.PI * 2 / total * index var cos = Math.cos(angle) var sin = Math.sin(angle) var tx = x * cos - y * sin + 100 var ty = x * sin + y * cos + 100 return { x: tx, y: ty } } function generatePoints(stats) { var total = stats.length return stats.map(function (stat, index) { var point = valueToPoint(stat, index, total) return point.x + ',' + point.y }).join(' ') }</script>
<style>
    .demo-svg {
        display: block;
    }

    .demo-polygon {
        fill: #41B883;
    }

    .demo-circle {
        fill: transparent;
        stroke: #35495E;
    }

    .demo-range-input {
        display: block;
        width: 100%;
        margin-bottom: 15px;
    }
</style>
<p>See <a target="_blank" rel="noopener"
        href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-state-transitions">this
        example</a> for the complete code behind the above demo.</p>
<h2 id="Organizing-Transitions-into-Components"><a href="#Organizing-Transitions-into-Components" class="headerlink"
        title="Organizing Transitions into Components" data-scroll="">Organizing Transitions into Components</a></h2>
<p>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many
    animations can be extracted out into dedicated child components. Let’s do this with the animated integer from our
    earlier example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example-8"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"firstNumber"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"20"</span>&gt;</span> +<br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"secondNumber"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">step</span>=<span class="hljs-string">"20"</span>&gt;</span> =<br> {{ result }}<br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">animated-integer</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"firstNumber"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animated-integer</span>&gt;</span> +<br> <span class="hljs-tag">&lt;<span class="hljs-name">animated-integer</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"secondNumber"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animated-integer</span>&gt;</span> =<br> <span class="hljs-tag">&lt;<span class="hljs-name">animated-integer</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"result"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animated-integer</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// This complex tweening logic can now be reused between</span><br><span class="hljs-comment">// any integers we may wish to animate in our application.</span><br><span class="hljs-comment">// Components also offer a clean interface for configuring</span><br><span class="hljs-comment">// more dynamic transitions and complex transition</span><br><span class="hljs-comment">// strategies.</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'animated-integer'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;span&gt;{{ tweeningValue }}&lt;/span&gt;'</span>,<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">value</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> }<br> },<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">tweeningValue</span>: <span class="hljs-number">0</span><br> }<br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tween</span>(oldValue, newValue)<br> }<br> },<br> <span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tween</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">tween</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">startValue, endValue</span>) {<br> <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span> () {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title function_">update</span>()) {<br> <span class="hljs-title function_">requestAnimationFrame</span>(animate)<br> }<br> }<br><br> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title class_">Tween</span>({ <span class="hljs-attr">tweeningValue</span>: startValue })<br> .<span class="hljs-title function_">to</span>({ <span class="hljs-attr">tweeningValue</span>: endValue }, <span class="hljs-number">500</span>)<br> .<span class="hljs-title function_">onUpdate</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> vm.<span class="hljs-property">tweeningValue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tweeningValue</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">0</span>)<br> })<br> .<span class="hljs-title function_">start</span>()<br><br> <span class="hljs-title function_">animate</span>()<br> }<br> }<br>})<br><br><span class="hljs-comment">// All complexity has now been removed from the main Vue instance!</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example-8'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">firstNumber</span>: <span class="hljs-number">20</span>,<br> <span class="hljs-attr">secondNumber</span>: <span class="hljs-number">40</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">result</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstNumber</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondNumber</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<script src="https://cdn.jsdelivr.net/npm/tween.js@16.3.4"></script>
<div id="example-8" class="demo"><input type="number" step="20"> + <input type="number" step="20"> = 60 <p>
        <span>20</span> + <span>40</span> = <span>60</span></p>
</div>
<script> Vue.component('animated-integer', { template: '<span>{{ tweeningValue }}</span>', props: { value: { type: Number, required: true } }, data: function () { return { tweeningValue: 0 } }, watch: { value: function (newValue, oldValue) { this.tween(oldValue, newValue) } }, mounted: function () { this.tween(0, this.value) }, methods: { tween: function (startValue, endValue) { var vm = this function animate() { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween({ tweeningValue: startValue }).to({ tweeningValue: endValue }, 500).onUpdate(function () { vm.tweeningValue = this.tweeningValue.toFixed(0) }).start() animate() } } }) new Vue({ el: '#example-8', data: { firstNumber: 20, secondNumber: 40 }, computed: { result: function () { return this.firstNumber + this.secondNumber } } })</script>
<p>Within child components, we can use any combination of transition strategies that have been covered on this page,
    along with those offered by Vue’s <a href="transitions.html">built-in transition system</a>. Together, there are
    very few limits to what can be accomplished.</p>
<h2 id="Bringing-Designs-to-Life"><a href="#Bringing-Designs-to-Life" class="headerlink"
        title="Bringing Designs to Life" data-scroll="">Bringing Designs to Life</a></h2>
<p>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and
    mascots, they’re usually delivered as images or static SVGs. So although GitHub’s octocat, Twitter’s bird, and many
    other logos resemble living creatures, they don’t really seem alive.</p>
<p>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited,
    thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading
    indicators, and notifications more emotionally compelling.</p>
<p>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state
    changes:</p>
<p></p>
<div class="cp_embed_wrapper"><iframe allowfullscreen="true" allowpaymentrequest="true" allowtransparency="true"
        class="cp_embed_iframe " name="cp_embed_1" scrolling="no"
        src="https://codepen.io/sdras/embed/YZBGNp?height=265&amp;theme-id=light&amp;slug-hash=YZBGNp&amp;default-tab=result&amp;user=sdras&amp;embed-version=2&amp;pen-title=Vue-controlled%20Wall-E&amp;name=cp_embed_1"
        style="width: 100%; overflow:hidden; display:block;" title="Vue-controlled Wall-E" loading="lazy"
        id="cp_embed_YZBGNp" width="100%" height="265" frameborder="0"></iframe></div>
<p></p>
<script async="" src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
<div class="guide-links"> <span>← <a href="/v2/guide/transitions.html">Enter/Leave &amp; List Transitions</a></span>
    <span style="float: right"><a href="/v2/guide/mixins.html">Mixins</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Mixins</h1>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics" data-scroll="">Basics</a></h2>
<p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any
    component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own
    options.</p>
<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/next-level-vue/mixins" target="_blank"
        rel="noopener" title="Mixins Tutorial">Watch a video explanation on Vue Mastery</a></div>
<p>Example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// define a mixin object</span><br><span class="hljs-keyword">var</span> myMixin = {<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hello</span>()<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello from mixin!'</span>)<br> }<br> }<br>}<br><br><span class="hljs-comment">// define a component that uses this mixin</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>({<br> <span class="hljs-attr">mixins</span>: [myMixin]<br>})<br><br><span class="hljs-keyword">var</span> component = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>() <span class="hljs-comment">// =&gt; "hello from mixin!"</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Option-Merging"><a href="#Option-Merging" class="headerlink" title="Option Merging" data-scroll="">Option
        Merging</a></h2>
<p>When a mixin and the component itself contain overlapping options, they will be “merged” using appropriate
    strategies.</p>
<p>For example, data objects undergo a recursive merge, with the component’s data taking priority in cases of conflicts.
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = {<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span>,<br> <span class="hljs-attr">foo</span>: <span class="hljs-string">'abc'</span><br> }<br> }<br>}<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">mixins</span>: [mixin],<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'goodbye'</span>,<br> <span class="hljs-attr">bar</span>: <span class="hljs-string">'def'</span><br> }<br> },<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>)<br> <span class="hljs-comment">// =&gt; { message: "goodbye", foo: "abc", bar: "def" }</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be
    called <strong>before</strong> the component’s own hooks.</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = {<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'mixin hook called'</span>)<br> }<br>}<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">mixins</span>: [mixin],<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'component hook called'</span>)<br> }<br>})<br><br><span class="hljs-comment">// =&gt; "mixin hook called"</span><br><span class="hljs-comment">// =&gt; "component hook called"</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Options that expect object values, for example <code>methods</code>, <code>components</code> and
    <code>directives</code>, will be merged into the same object. The component’s options will take priority when there
    are conflicting keys in these objects:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = {<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo'</span>)<br> },<br> <span class="hljs-attr">conflicting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'from mixin'</span>)<br> }<br> }<br>}<br><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">mixins</span>: [mixin],<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar'</span>)<br> },<br> <span class="hljs-attr">conflicting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'from self'</span>)<br> }<br> }<br>})<br><br>vm.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// =&gt; "foo"</span><br>vm.<span class="hljs-title function_">bar</span>() <span class="hljs-comment">// =&gt; "bar"</span><br>vm.<span class="hljs-title function_">conflicting</span>() <span class="hljs-comment">// =&gt; "from self"</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that the same merge strategies are used in <code>Vue.extend()</code>.</p>
<h2 id="Global-Mixin"><a href="#Global-Mixin" class="headerlink" title="Global Mixin" data-scroll="">Global Mixin</a>
</h2>
<p>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect
    <strong>every</strong> Vue instance created afterwards. When used properly, this can be used to inject processing
    logic for custom options:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// inject a handler for `myOption` custom option</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>({<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> myOption = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">myOption</span><br> <span class="hljs-keyword">if</span> (myOption) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myOption)<br> }<br> }<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">myOption</span>: <span class="hljs-string">'hello!'</span><br>})<br><span class="hljs-comment">// =&gt; "hello!"</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including
    third party components. In most cases, you should only use it for custom option handling like demonstrated in the
    example above. It’s also a good idea to ship them as <a href="plugins.html">Plugins</a> to avoid duplicate
    application.</p>
<h2 id="Custom-Option-Merge-Strategies"><a href="#Custom-Option-Merge-Strategies" class="headerlink"
        title="Custom Option Merge Strategies" data-scroll="">Custom Option Merge Strategies</a></h2>
<p>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a
    custom option to be merged using custom logic, you need to attach a function to
    <code>Vue.config.optionMergeStrategies</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">optionMergeStrategies</span>.<span class="hljs-property">myOption</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">toVal, fromVal</span>) {<br> <span class="hljs-comment">// return mergedVal</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For most object-based options, you can use the same strategy used by <code>methods</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> strategies = <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">optionMergeStrategies</span><br>strategies.<span class="hljs-property">myOption</span> = strategies.<span class="hljs-property">methods</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>A more advanced example can be found on <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vuex">Vuex</a>‘s 1.x merging strategy:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> merge = <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">optionMergeStrategies</span>.<span class="hljs-property">computed</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">optionMergeStrategies</span>.<span class="hljs-property">vuex</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">toVal, fromVal</span>) {<br> <span class="hljs-keyword">if</span> (!toVal) <span class="hljs-keyword">return</span> fromVal<br> <span class="hljs-keyword">if</span> (!fromVal) <span class="hljs-keyword">return</span> toVal<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">getters</span>: <span class="hljs-title function_">merge</span>(toVal.<span class="hljs-property">getters</span>, fromVal.<span class="hljs-property">getters</span>),<br> <span class="hljs-attr">state</span>: <span class="hljs-title function_">merge</span>(toVal.<span class="hljs-property">state</span>, fromVal.<span class="hljs-property">state</span>),<br> <span class="hljs-attr">actions</span>: <span class="hljs-title function_">merge</span>(toVal.<span class="hljs-property">actions</span>, fromVal.<span class="hljs-property">actions</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/transitioning-state.html">State Transitions</a></span> <span
        style="float: right"><a href="/v2/guide/custom-directive.html">Custom Directives</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Custom Directives</h1>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro" data-scroll="">Intro</a></h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs" target="_blank"
        rel="sponsored noopener" title="Free Vue.js Custom Directives lesson">Watch a free video lesson on Vue
        School</a></div>
<p>In addition to the default set of directives shipped in core (<code>v-model</code> and <code>v-show</code>), Vue also
    allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and
    abstraction is components - however there may be cases where you need some low-level DOM access on plain elements,
    and this is where custom directives would still be useful. An example would be focusing on an input element, like
    this one:</p>
<div id="simplest-directive-example" class="demo"><input></div>
<script> Vue.directive('focus', { inserted: function (el) { el.focus() } }) new Vue({ el: '#simplest-directive-example' })</script>
<p>When the page loads, that element gains focus (note: <code>autofocus</code> doesn’t work on mobile Safari). In fact,
    if you haven’t clicked on anything else since visiting this page, the input above should be focused now. Now let’s
    build the directive that accomplishes this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Register a global custom directive called `v-focus`</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'focus'</span>, {<br> <span class="hljs-comment">// When the bound element is inserted into the DOM...</span><br> <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> <span class="hljs-comment">// Focus the element</span><br> el.<span class="hljs-title function_">focus</span>()<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you want to register a directive locally instead, components also accept a <code>directives</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">directives</span>: {<br> <span class="hljs-attr">focus</span>: {<br> <span class="hljs-comment">// directive definition</span><br> <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {<br> el.<span class="hljs-title function_">focus</span>()<br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then in a template, you can use the new <code>v-focus</code> attribute on any element, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Hook-Functions"><a href="#Hook-Functions" class="headerlink" title="Hook Functions" data-scroll="">Hook
        Functions</a></h2>
<p>A directive definition object can provide several hook functions (all optional):</p>
<ul>
    <li>
        <p><code>bind</code>: called only once, when the directive is first bound to the element. This is where you can
            do one-time setup work.</p>
    </li>
    <li>
        <p><code>inserted</code>: called when the bound element has been inserted into its parent node (this only
            guarantees parent node presence, not necessarily in-document).</p>
    </li>
    <li>
        <p><code>update</code>: called after the containing component’s VNode has updated, <strong>but possibly before
                its children have updated</strong>. The directive’s value may or may not have changed, but you can skip
            unnecessary updates by comparing the binding’s current and old values (see below on hook arguments).</p>
    </li>
</ul>
<p class="tip">We’ll cover VNodes in more detail <a href="./render-function.html#The-Virtual-DOM">later</a>, when we
    discuss <a href="./render-function.html">render functions</a>.</p>
<ul>
    <li>
        <p><code>componentUpdated</code>: called after the containing component’s VNode <strong>and the VNodes of its
                children</strong> have updated.</p>
    </li>
    <li>
        <p><code>unbind</code>: called only once, when the directive is unbound from the element.</p>
    </li>
</ul>
<p>We’ll explore the arguments passed into these hooks (i.e. <code>el</code>, <code>binding</code>, <code>vnode</code>,
    and <code>oldVnode</code>) in the next section.</p>
<h2 id="Directive-Hook-Arguments"><a href="#Directive-Hook-Arguments" class="headerlink"
        title="Directive Hook Arguments" data-scroll="">Directive Hook Arguments</a></h2>
<p>Directive hooks are passed these arguments:</p>
<ul>
    <li><code>el</code>: The element the directive is bound to. This can be used to directly manipulate the DOM.</li>
    <li><code>binding</code>: An object containing the following properties.<ul>
            <li><code>name</code>: The name of the directive, without the <code>v-</code> prefix.</li>
            <li><code>value</code>: The value passed to the directive. For example in
                <code>v-my-directive="1 + 1"</code>, the value would be <code>2</code>.</li>
            <li><code>oldValue</code>: The previous value, only available in <code>update</code> and
                <code>componentUpdated</code>. It is available whether or not the value has changed.</li>
            <li><code>expression</code>: The expression of the binding as a string. For example in
                <code>v-my-directive="1 + 1"</code>, the expression would be <code>"1 + 1"</code>.</li>
            <li><code>arg</code>: The argument passed to the directive, if any. For example in
                <code>v-my-directive:foo</code>, the arg would be <code>"foo"</code>.</li>
            <li><code>modifiers</code>: An object containing modifiers, if any. For example in
                <code>v-my-directive.foo.bar</code>, the modifiers object would be
                <code>{ foo: true, bar: true }</code>.</li>
        </ul>
    </li>
    <li><code>vnode</code>: The virtual node produced by Vue’s compiler. See the <a href="../api/#VNode-Interface">VNode
            API</a> for full details.</li>
    <li><code>oldVnode</code>: The previous virtual node, only available in the <code>update</code> and
        <code>componentUpdated</code> hooks.</li>
</ul>
<p class="tip">Apart from <code>el</code>, you should treat these arguments as read-only and never modify them. If you
    need to share information across hooks, it is recommended to do so through element’s <a target="_blank"
        rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset">dataset</a>.</p>
<p>An example of a custom directive using some of these properties:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hook-arguments-example"</span> <span class="hljs-attr">v-demo:foo.a.b</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'demo'</span>, {<br> <span class="hljs-attr">bind</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) {<br> <span class="hljs-keyword">var</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-property">stringify</span><br> el.<span class="hljs-property">innerHTML</span> =<br> <span class="hljs-string">'name: '</span> + <span class="hljs-title function_">s</span>(binding.<span class="hljs-property">name</span>) + <span class="hljs-string">'&lt;br&gt;'</span> +<br> <span class="hljs-string">'value: '</span> + <span class="hljs-title function_">s</span>(binding.<span class="hljs-property">value</span>) + <span class="hljs-string">'&lt;br&gt;'</span> +<br> <span class="hljs-string">'expression: '</span> + <span class="hljs-title function_">s</span>(binding.<span class="hljs-property">expression</span>) + <span class="hljs-string">'&lt;br&gt;'</span> +<br> <span class="hljs-string">'argument: '</span> + <span class="hljs-title function_">s</span>(binding.<span class="hljs-property">arg</span>) + <span class="hljs-string">'&lt;br&gt;'</span> +<br> <span class="hljs-string">'modifiers: '</span> + <span class="hljs-title function_">s</span>(binding.<span class="hljs-property">modifiers</span>) + <span class="hljs-string">'&lt;br&gt;'</span> +<br> <span class="hljs-string">'vnode keys: '</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(vnode).<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>)<br> }<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#hook-arguments-example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'hello!'</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div id="hook-arguments-example" class="demo">name: "demo"<br>value: "hello!"<br>expression: "message"<br>argument:
    "foo"<br>modifiers: {"a":true,"b":true}<br>vnode keys: tag, data, children, text, elm, ns, context, fnContext,
    fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment,
    isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder</div>
<script> Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '<br>' + 'value: ' + s(binding.value) + '<br>' + 'expression: ' + s(binding.expression) + '<br>' + 'argument: ' + s(binding.arg) + '<br>' + 'modifiers: ' + s(binding.modifiers) + '<br>' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' } })</script>
<h3 id="Dynamic-Directive-Arguments"><a href="#Dynamic-Directive-Arguments" class="headerlink"
        title="Dynamic Directive Arguments" data-scroll="">Dynamic Directive Arguments</a></h3>
<p>Directive arguments can be dynamic. For example, in <code>v-mydirective:[argument]="value"</code>, the
    <code>argument</code> can be updated based on data properties in our component instance! This makes our custom
    directives flexible for use throughout our application.</p>
<p>Let’s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning.
    We could create a custom directive where the value updates the vertical positioning in pixels, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"baseexample"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Scroll down the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin</span>=<span class="hljs-string">"200"</span>&gt;</span>Stick me 200px from the top of the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'pin'</span>, {<br> <span class="hljs-attr">bind</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'fixed'</span><br> el.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = binding.<span class="hljs-property">value</span> + <span class="hljs-string">'px'</span><br> }<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#baseexample'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to
    pin the element from the left, instead of the top? Here’s where a dynamic argument that can be updated per component
    instance comes in very handy:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamicexample"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin:</span>[<span class="hljs-attr">direction</span>]=<span class="hljs-string">"200"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'pin'</span>, {<br> <span class="hljs-attr">bind</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'fixed'</span><br> <span class="hljs-keyword">var</span> s = (binding.<span class="hljs-property">arg</span> == <span class="hljs-string">'left'</span> ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'top'</span>)<br> el.<span class="hljs-property">style</span>[s] = binding.<span class="hljs-property">value</span> + <span class="hljs-string">'px'</span><br> }<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#dynamicexample'</span>,<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">direction</span>: <span class="hljs-string">'left'</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Result:</p> <iframe style="width: 100%;" class="demo" scrolling="no" title="Dynamic Directive Arguments"
    src="//codepen.io/team/Vue/embed/rgLLzb/?height=300&amp;theme-id=32763&amp;default-tab=result"
    allowtransparency="true" allowfullscreen="true" height="200" frameborder="no"> See the Pen <a target="_blank"
        rel="noopener" href='https://codepen.io/team/Vue/pen/rgLLzb/'>Dynamic Directive Arguments</a> by Vue (<a
        target="_blank" rel="noopener" href='https://codepen.io/Vue'>@Vue</a>) on <a target="_blank" rel="noopener"
        href='https://codepen.io'>CodePen</a>. </iframe>
<p>Our custom directive is now flexible enough to support a few different use cases.</p>
<h2 id="Function-Shorthand"><a href="#Function-Shorthand" class="headerlink" title="Function Shorthand"
        data-scroll="">Function Shorthand</a></h2>
<p>In many cases, you may want the same behavior on <code>bind</code> and <code>update</code>, but don’t care about the
    other hooks. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'color-swatch'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) {<br> el.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = binding.<span class="hljs-property">value</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Object-Literals"><a href="#Object-Literals" class="headerlink" title="Object Literals" data-scroll="">Object
        Literals</a></h2>
<p>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can
    take any valid JavaScript expression.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-demo</span>=<span class="hljs-string">"{ color: 'white', text: 'hello!' }"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'demo'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binding.<span class="hljs-property">value</span>.<span class="hljs-property">color</span>) <span class="hljs-comment">// =&gt; "white"</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binding.<span class="hljs-property">value</span>.<span class="hljs-property">text</span>) <span class="hljs-comment">// =&gt; "hello!"</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/mixins.html">Mixins</a></span> <span style="float: right"><a
            href="/v2/guide/render-function.html">Render Functions &amp; JSX</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Render Functions &amp; JSX</h1>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics" data-scroll="">Basics</a></h2>
<p>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where
    you really need the full programmatic power of JavaScript. That’s where you can use the <strong>render
        function</strong>, a closer-to-the-compiler alternative to templates.</p>
<p>Let’s dive into a simple example where a <code>render</code> function would be practical. Say you want to generate
    anchored headings:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hello-world"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#hello-world"</span>&gt;</span><br> Hello world!<br> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For the HTML above, you decide you want this component interface:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">anchored-heading</span> <span class="hljs-attr">:level</span>=<span class="hljs-string">"1"</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">anchored-heading</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When you get started with a component that only generates a heading based on the <code>level</code> prop, you quickly
    arrive at this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/x-template"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"anchored-heading-template"</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"level === 1"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"level === 2"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"level === 3"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"level === 4"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"level === 5"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">h6</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"level === 6"</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"> <span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'anchored-heading'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'#anchored-heading-template'</span>,<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">level</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That template doesn’t feel great. It’s not only verbose, but we’re duplicating <code>&lt;slot&gt;&lt;/slot&gt;</code>
    for every heading level and will have to do the same when we add the anchor element.</p>
<p>While templates work great for most components, it’s clear that this isn’t one of them. So let’s try rewriting it
    with a <code>render</code> function:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'anchored-heading'</span>, {<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br> <span class="hljs-string">'h'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>, <span class="hljs-comment">// tag name</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <span class="hljs-comment">// array of children</span><br> )<br> },<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">level</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In
    this case, you have to know that when you pass children without a <code>v-slot</code> directive into a component,
    like the <code>Hello world!</code> inside of <code>anchored-heading</code>, those children are stored on the
    component instance at <code>$slots.default</code>. If you haven’t already, <strong>it’s recommended to read through
        the <a href="../api/#Instance-Properties">instance properties API</a> before diving into render
        functions.</strong></p>
<h2 id="Nodes-Trees-and-the-Virtual-DOM"><a href="#Nodes-Trees-and-the-Virtual-DOM" class="headerlink"
        title="Nodes, Trees, and the Virtual DOM" data-scroll="">Nodes, Trees, and the Virtual DOM</a></h2>
<p>Before we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for
    example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br> Some text content<br> <span class="hljs-comment">&lt;!-- <span class="hljs-doctag">TODO:</span> Add tagline --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When a browser reads this code, it builds a <a target="_blank" rel="noopener"
        href="https://javascript.info/dom-nodes">tree of “DOM nodes”</a> to help it keep track of everything, just as
    you might build a family tree to keep track of your extended family.</p>
<p>The tree of DOM nodes for the HTML above looks like this:</p>
<p><img src="/images/dom-tree.png" alt="DOM Tree Visualization"></p>
<p>Every element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page.
    And as in a family tree, each node can have children (i.e. each piece can contain other pieces).</p>
<p>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you
    tell Vue what HTML you want on the page, in a template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ blogTitle }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or a render function:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'h1'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">blogTitle</span>)<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And in both cases, Vue automatically keeps the page updated, even when <code>blogTitle</code> changes.</p>
<h3 id="The-Virtual-DOM"><a href="#The-Virtual-DOM" class="headerlink" title="The Virtual DOM" data-scroll="">The
        Virtual DOM</a></h3>
<p>Vue accomplishes this by building a <strong>virtual DOM</strong> to keep track of the changes it needs to make to the
    real DOM. Taking a closer look at this line:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'h1'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">blogTitle</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>What is <code>createElement</code> actually returning? It’s not <em>exactly</em> a real DOM element. It could perhaps
    more accurately be named <code>createNodeDescription</code>, as it contains information describing to Vue what kind
    of node it should render on the page, including descriptions of any child nodes. We call this node description a
    “virtual node”, usually abbreviated to <strong>VNode</strong>. “Virtual DOM” is what we call the entire tree of
    VNodes, built by a tree of Vue components.</p>
<h2 id="createElement-Arguments"><a href="#createElement-Arguments" class="headerlink" title="createElement Arguments"
        data-scroll=""><code>createElement</code> Arguments</a></h2>
<p>The next thing you’ll have to become familiar with is how to use template features in the <code>createElement</code>
    function. Here are the arguments that <code>createElement</code> accepts:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// @returns {VNode}</span><br><span class="hljs-title function_">createElement</span>(<br> <span class="hljs-comment">// {String | Object | Function}</span><br> <span class="hljs-comment">// An HTML tag name, component options, or async</span><br> <span class="hljs-comment">// function resolving to one of these. Required.</span><br> <span class="hljs-string">'div'</span>,<br><br> <span class="hljs-comment">// {Object}</span><br> <span class="hljs-comment">// A data object corresponding to the attributes</span><br> <span class="hljs-comment">// you would use in a template. Optional.</span><br> {<br> <span class="hljs-comment">// (see details in the next section below)</span><br> },<br><br> <span class="hljs-comment">// {String | Array}</span><br> <span class="hljs-comment">// Children VNodes, built using `createElement()`,</span><br> <span class="hljs-comment">// or using strings to get 'text VNodes'. Optional.</span><br> [<br> <span class="hljs-string">'Some text comes first.'</span>,<br> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'h1'</span>, <span class="hljs-string">'A headline'</span>),<br> <span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">MyComponent</span>, {<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">someProp</span>: <span class="hljs-string">'foobar'</span><br> }<br> })<br> ]<br>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="The-Data-Object-In-Depth"><a href="#The-Data-Object-In-Depth" class="headerlink"
        title="The Data Object In-Depth" data-scroll="">The Data Object In-Depth</a></h3>
<p>One thing to note: similar to how <code>v-bind:class</code> and <code>v-bind:style</code> have special treatment in
    templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal
    HTML attributes as well as DOM properties such as <code>innerHTML</code> (this would replace the <code>v-html</code>
    directive):</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-comment">// Same API as `v-bind:class`, accepting either</span><br> <span class="hljs-comment">// a string, object, or array of strings and objects.</span><br> <span class="hljs-attr">class</span>: {<br> <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span><br> },<br> <span class="hljs-comment">// Same API as `v-bind:style`, accepting either</span><br> <span class="hljs-comment">// a string, object, or array of objects.</span><br> <span class="hljs-attr">style</span>: {<br> <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,<br> <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'14px'</span><br> },<br> <span class="hljs-comment">// Normal HTML attributes</span><br> <span class="hljs-attr">attrs</span>: {<br> <span class="hljs-attr">id</span>: <span class="hljs-string">'foo'</span><br> },<br> <span class="hljs-comment">// Component props</span><br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">myProp</span>: <span class="hljs-string">'bar'</span><br> },<br> <span class="hljs-comment">// DOM properties</span><br> <span class="hljs-attr">domProps</span>: {<br> <span class="hljs-attr">innerHTML</span>: <span class="hljs-string">'baz'</span><br> },<br> <span class="hljs-comment">// Event handlers are nested under `on`, though</span><br> <span class="hljs-comment">// modifiers such as in `v-on:keyup.enter` are not</span><br> <span class="hljs-comment">// supported. You'll have to manually check the</span><br> <span class="hljs-comment">// keyCode in the handler instead.</span><br> <span class="hljs-attr">on</span>: {<br> <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickHandler</span><br> },<br> <span class="hljs-comment">// For components only. Allows you to listen to</span><br> <span class="hljs-comment">// native events, rather than events emitted from</span><br> <span class="hljs-comment">// the component using `vm.$emit`.</span><br> <span class="hljs-attr">nativeOn</span>: {<br> <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeClickHandler</span><br> },<br> <span class="hljs-comment">// Custom directives. Note that the `binding`'s</span><br> <span class="hljs-comment">// `oldValue` cannot be set, as Vue keeps track</span><br> <span class="hljs-comment">// of it for you.</span><br> <span class="hljs-attr">directives</span>: [<br> {<br> <span class="hljs-attr">name</span>: <span class="hljs-string">'my-custom-directive'</span>,<br> <span class="hljs-attr">value</span>: <span class="hljs-string">'2'</span>,<br> <span class="hljs-attr">expression</span>: <span class="hljs-string">'1 + 1'</span>,<br> <span class="hljs-attr">arg</span>: <span class="hljs-string">'foo'</span>,<br> <span class="hljs-attr">modifiers</span>: {<br> <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span><br> }<br> }<br> ],<br> <span class="hljs-comment">// Scoped slots in the form of</span><br> <span class="hljs-comment">// { name: props =&gt; VNode | Array&lt;VNode&gt; }</span><br> <span class="hljs-attr">scopedSlots</span>: {<br> <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, props.<span class="hljs-property">text</span>)<br> },<br> <span class="hljs-comment">// The name of the slot, if this component is the</span><br> <span class="hljs-comment">// child of another component</span><br> <span class="hljs-attr">slot</span>: <span class="hljs-string">'name-of-slot'</span>,<br> <span class="hljs-comment">// Other special top-level properties</span><br> <span class="hljs-attr">key</span>: <span class="hljs-string">'myKey'</span>,<br> <span class="hljs-attr">ref</span>: <span class="hljs-string">'myRef'</span>,<br> <span class="hljs-comment">// If you are applying the same ref name to multiple</span><br> <span class="hljs-comment">// elements in the render function. This will make `$refs.myRef` become an</span><br> <span class="hljs-comment">// array</span><br> <span class="hljs-attr">refInFor</span>: <span class="hljs-literal">true</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Complete-Example"><a href="#Complete-Example" class="headerlink" title="Complete Example"
        data-scroll="">Complete Example</a></h3>
<p>With this knowledge, we can now finish the component we started:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> getChildrenTextContent = <span class="hljs-keyword">function</span> (<span class="hljs-params">children</span>) {<br> <span class="hljs-keyword">return</span> children.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) {<br> <span class="hljs-keyword">return</span> node.<span class="hljs-property">children</span><br> ? <span class="hljs-title function_">getChildrenTextContent</span>(node.<span class="hljs-property">children</span>)<br> : node.<span class="hljs-property">text</span><br> }).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)<br>}<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'anchored-heading'</span>, {<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-comment">// create kebab-case id</span><br> <span class="hljs-keyword">var</span> headingId = <span class="hljs-title function_">getChildrenTextContent</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>)<br> .<span class="hljs-title function_">toLowerCase</span>()<br> .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\W+/g</span>, <span class="hljs-string">'-'</span>)<br> .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(^-|-$)/g</span>, <span class="hljs-string">''</span>)<br><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br> <span class="hljs-string">'h'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>,<br> [<br> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'a'</span>, {<br> <span class="hljs-attr">attrs</span>: {<br> <span class="hljs-attr">name</span>: headingId,<br> <span class="hljs-attr">href</span>: <span class="hljs-string">'#'</span> + headingId<br> }<br> }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>)<br> ]<br> )<br> },<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">level</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints" data-scroll="">Constraints</a></h3>
<h4 id="VNodes-Must-Be-Unique"><a href="#VNodes-Must-Be-Unique" class="headerlink"
        title="VNodes Must Be Unique"></a>VNodes Must Be Unique</h4>
<p>All VNodes in the component tree must be unique. That means the following render function is invalid:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">var</span> myParagraphVNode = <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'p'</span>, <span class="hljs-string">'hi'</span>)<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>, [<br> <span class="hljs-comment">// Yikes - duplicate VNodes!</span><br> myParagraphVNode, myParagraphVNode<br> ])<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you really want to duplicate the same element/component many times, you can do so with a factory function. For
    example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>,<br> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">20</span> }).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'p'</span>, <span class="hljs-string">'hi'</span>)<br> })<br> )<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Replacing-Template-Features-with-Plain-JavaScript"><a href="#Replacing-Template-Features-with-Plain-JavaScript"
        class="headerlink" title="Replacing Template Features with Plain JavaScript" data-scroll="">Replacing Template
        Features with Plain JavaScript</a></h2>
<h3 id="v-if-and-v-for"><a href="#v-if-and-v-for" class="headerlink" title="v-if and v-for"
        data-scroll=""><code>v-if</code> and <code>v-for</code></a></h3>
<p>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary
    alternative. For example, in a template using <code>v-if</code> and <code>v-for</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"items.length"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No items found.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This could be rewritten with JavaScript’s <code>if</code>/<code>else</code> and <code>map</code> in a render
    function:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'items'</span>],<br><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'ul'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'li'</span>, item.<span class="hljs-property">name</span>)<br> }))<br> } <span class="hljs-keyword">else</span> {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'p'</span>, <span class="hljs-string">'No items found.'</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model" data-scroll=""><code>v-model</code></a></h3>
<p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic
    yourself:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'value'</span>],<br><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'input'</span>, {<br> <span class="hljs-attr">domProps</span>: {<br> <span class="hljs-attr">value</span>: self.<span class="hljs-property">value</span><br> },<br> <span class="hljs-attr">on</span>: {<br> <span class="hljs-attr">input</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {<br> self.$emit(<span class="hljs-string">'input'</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br> }<br> }<br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared
    to <code>v-model</code>.</p>
<h3 id="Event-amp-Key-Modifiers"><a href="#Event-amp-Key-Modifiers" class="headerlink" title="Event &amp; Key Modifiers"
        data-scroll="">Event &amp; Key Modifiers</a></h3>
<p>For the <code>.passive</code>, <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that
    can be used with <code>on</code>:</p>
<table>
    <thead>
        <tr>
            <th>Modifier(s)</th>
            <th>Prefix</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>.passive</code></td>
            <td><code>&amp;</code></td>
        </tr>
        <tr>
            <td><code>.capture</code></td>
            <td><code>!</code></td>
        </tr>
        <tr>
            <td><code>.once</code></td>
            <td><code>~</code></td>
        </tr>
        <tr>
            <td><code>.capture.once</code> or<br><code>.once.capture</code></td>
            <td><code>~!</code></td>
        </tr>
    </tbody>
</table>
<p>For example:</p>
<figure class="highlight javascript">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs javascript"><span class="hljs-attr">on</span>: {<br> <span class="hljs-string">'!click'</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">doThisInCapturingMode</span>,<br> <span class="hljs-string">'~keyup'</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">doThisOnce</span>,<br> <span class="hljs-string">'~!mouseover'</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">doThisOnceInCapturingMode</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the
    handler:</p>
<table>
    <thead>
        <tr>
            <th>Modifier(s)</th>
            <th>Equivalent in Handler</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>.stop</code></td>
            <td><code>event.stopPropagation()</code></td>
        </tr>
        <tr>
            <td><code>.prevent</code></td>
            <td><code>event.preventDefault()</code></td>
        </tr>
        <tr>
            <td><code>.self</code></td>
            <td><code>if (event.target !== event.currentTarget) return</code></td>
        </tr>
        <tr>
            <td>Keys:<br><code>.enter</code>, <code>.13</code></td>
            <td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a target="_blank"
                    rel="noopener" href="http://keycode.info/">another key code</a> for other key modifiers)</td>
        </tr>
        <tr>
            <td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>
            <td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>,
                <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>
        </tr>
    </tbody>
</table>
<p>Here’s an example with all of these modifiers used together:</p>
<figure class="highlight javascript">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs javascript"><span class="hljs-attr">on</span>: {<br> <span class="hljs-attr">keyup</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {<br> <span class="hljs-comment">// Abort if the element emitting the event is not</span><br> <span class="hljs-comment">// the element the event is bound to</span><br> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span> !== event.<span class="hljs-property">currentTarget</span>) <span class="hljs-keyword">return</span><br> <span class="hljs-comment">// Abort if the key that went up is not the enter</span><br> <span class="hljs-comment">// key (13) and the shift key was not held down</span><br> <span class="hljs-comment">// at the same time</span><br> <span class="hljs-keyword">if</span> (!event.<span class="hljs-property">shiftKey</span> || event.<span class="hljs-property">keyCode</span> !== <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span><br> <span class="hljs-comment">// Stop event propagation</span><br> event.<span class="hljs-title function_">stopPropagation</span>()<br> <span class="hljs-comment">// Prevent the default keyup handler for this element</span><br> event.<span class="hljs-title function_">preventDefault</span>()<br> <span class="hljs-comment">// ...</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Slots"><a href="#Slots" class="headerlink" title="Slots" data-scroll="">Slots</a></h3>
<p>You can access static slot contents as Arrays of VNodes from <a href="../api/#vm-slots"><code>this.$slots</code></a>:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-comment">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>)<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>And access scoped slots as functions that return VNodes from <a
        href="../api/#vm-scopedSlots"><code>this.$scopedSlots</code></a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">'message'</span>],<br><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-comment">// `&lt;div&gt;&lt;slot :text="message"&gt;&lt;/slot&gt;&lt;/div&gt;`</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>, [<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$scopedSlots</span>.<span class="hljs-title function_">default</span>({<br> <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span><br> })<br> ])<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode
    data:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) {<br> <span class="hljs-comment">// `&lt;div&gt;&lt;child v-slot="props"&gt;&lt;span&gt;{{ props.text }}&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>, [<br> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'child'</span>, {<br> <span class="hljs-comment">// pass `scopedSlots` in the data object</span><br> <span class="hljs-comment">// in the form of { name: props =&gt; VNode | Array&lt;VNode&gt; }</span><br> <span class="hljs-attr">scopedSlots</span>: {<br> <span class="hljs-attr">default</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">props</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, props.<span class="hljs-property">text</span>)<br> }<br> }<br> })<br> ])<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX" data-scroll="">JSX</a></h2>
<p>If you’re writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title function_">createElement</span>(<br> <span class="hljs-string">'anchored-heading'</span>, {<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">level</span>: <span class="hljs-number">1</span><br> }<br> }, [<br> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, <span class="hljs-string">'Hello'</span>),<br> <span class="hljs-string">' world!'</span><br> ]<br>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Especially when the template version is so simple in comparison:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">anchored-heading</span> <span class="hljs-attr">:level</span>=<span class="hljs-string">"1"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> world!<br><span class="hljs-tag">&lt;/<span class="hljs-name">anchored-heading</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>That’s why there’s a <a target="_blank" rel="noopener" href="https://github.com/vuejs/jsx">Babel plugin</a> to use
    JSX with Vue, getting us back to a syntax that’s closer to templates:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AnchoredHeading</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./AnchoredHeading.vue'</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">h</span>) {<br> <span class="hljs-keyword">return</span> (<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AnchoredHeading</span> <span class="hljs-attr">level</span>=<span class="hljs-string">{1}</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> world!</span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">AnchoredHeading</span>&gt;</span></span><br> )<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">Aliasing <code>createElement</code> to <code>h</code> is a common convention you’ll see in the Vue
    ecosystem and is actually required for JSX. Starting with <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection">version 3.4.0</a> of the Babel
    plugin for Vue, we automatically inject <code>const h = this.$createElement</code> in any method and getter (not
    functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the <code>(h)</code>
    parameter. With prior versions of the plugin, your app would throw an error if <code>h</code> was not available in
    the scope.</p>
<p>For more on how JSX maps to JavaScript, see the <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/jsx#installation">usage docs</a>.</p>
<h2 id="Functional-Components"><a href="#Functional-Components" class="headerlink" title="Functional Components"
        data-scroll="">Functional Components</a></h2>
<p>The anchored heading component we created earlier is relatively simple. It doesn’t manage any state, watch any state
    passed to it, and it has no lifecycle methods. Really, it’s only a function with some props.</p>
<p>In cases like this, we can mark components as <code>functional</code>, which means that they’re stateless (no <a
        href="../api/#Options-Data">reactive data</a>) and instanceless (no <code>this</code> context). A
    <strong>functional component</strong> looks like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-component'</span>, {<br> <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-comment">// Props are optional</span><br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-comment">// ...</span><br> },<br> <span class="hljs-comment">// To compensate for the lack of an instance,</span><br> <span class="hljs-comment">// we are now provided a 2nd context argument.</span><br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement, context</span>) {<br> <span class="hljs-comment">// ...</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<blockquote>
    <p>Note: in versions before 2.3.0, the <code>props</code> option is required if you wish to accept props in a
        functional component. In 2.3.0+ you can omit the <code>props</code> option and all attributes found on the
        component node will be implicitly extracted as props.</p>
    <p>The reference will be HTMLElement when used with functional components because they’re stateless and
        instanceless.</p>
</blockquote>
<p>In 2.5.0+, if you are using <a href="single-file-components.html">single-file components</a>, template-based
    functional components can be declared with:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">functional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Everything the component needs is passed through <code>context</code>, which is an object containing:</p>
<ul>
    <li><code>props</code>: An object of the provided props</li>
    <li><code>children</code>: An array of the VNode children</li>
    <li><code>slots</code>: A function returning a slots object</li>
    <li><code>scopedSlots</code>: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as
        functions.</li>
    <li><code>data</code>: The entire <a href="#The-Data-Object-In-Depth">data object</a>, passed to the component as
        the 2nd argument of <code>createElement</code></li>
    <li><code>parent</code>: A reference to the parent component</li>
    <li><code>listeners</code>: (2.3.0+) An object containing parent-registered event listeners. This is an alias to
        <code>data.on</code></li>
    <li><code>injections</code>: (2.3.0+) if using the <a href="../api/#provide-inject"><code>inject</code></a> option,
        this will contain resolved injections.</li>
</ul>
<p>After adding <code>functional: true</code>, updating the render function of our anchored heading component would
    require adding the <code>context</code> argument, updating <code>this.$slots.default</code> to
    <code>context.children</code>, then updating <code>this.level</code> to <code>context.props.level</code>.</p>
<p>Since functional components are just functions, they’re much cheaper to render.</p>
<p>They’re also very useful as wrapper components. For example, when you need to:</p>
<ul>
    <li>Programmatically choose one of several other components to delegate to</li>
    <li>Manipulate children, props, or data before passing them on to a child component</li>
</ul>
<p>Here’s an example of a <code>smart-list</code> component that delegates to more specific components, depending on the
    props passed to it:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">EmptyList</span> = { <span class="hljs-comment">/* ... */</span> }<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">TableList</span> = { <span class="hljs-comment">/* ... */</span> }<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">OrderedList</span> = { <span class="hljs-comment">/* ... */</span> }<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">UnorderedList</span> = { <span class="hljs-comment">/* ... */</span> }<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'smart-list'</span>, {<br> <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">items</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br> },<br> <span class="hljs-attr">isOrdered</span>: <span class="hljs-title class_">Boolean</span><br> },<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement, context</span>) {<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">appropriateListComponent</span> () {<br> <span class="hljs-keyword">var</span> items = context.<span class="hljs-property">props</span>.<span class="hljs-property">items</span><br><br> <span class="hljs-keyword">if</span> (items.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">EmptyList</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> items[<span class="hljs-number">0</span>] === <span class="hljs-string">'object'</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">TableList</span><br> <span class="hljs-keyword">if</span> (context.<span class="hljs-property">props</span>.<span class="hljs-property">isOrdered</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">OrderedList</span><br><br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">UnorderedList</span><br> }<br><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br> <span class="hljs-title function_">appropriateListComponent</span>(),<br> context.<span class="hljs-property">data</span>,<br> context.<span class="hljs-property">children</span><br> )<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Passing-Attributes-and-Events-to-Child-Elements-Components"><a
        href="#Passing-Attributes-and-Events-to-Child-Elements-Components" class="headerlink"
        title="Passing Attributes and Events to Child Elements/Components" data-scroll="">Passing Attributes and Events
        to Child Elements/Components</a></h3>
<p>On normal components, attributes not defined as props are automatically added to the root element of the component,
    replacing or <a href="class-and-style.html">intelligently merging with</a> any existing attributes of the same name.
</p>
<p>Functional components, however, require you to explicitly define this behavior:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'my-functional-button'</span>, {<br> <span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement, context</span>) {<br> <span class="hljs-comment">// Transparently pass any attributes, event listeners, children, etc.</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'button'</span>, context.<span class="hljs-property">data</span>, context.<span class="hljs-property">children</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>By passing <code>context.data</code> as the second argument to <code>createElement</code>, we are passing down any
    attributes or event listeners used on <code>my-functional-button</code>. It’s so transparent, in fact, that events
    don’t even require the <code>.native</code> modifier.</p>
<p>If you are using template-based functional components, you will also have to manually add attributes and listeners.
    Since we have access to the individual context contents, we can use <code>data.attrs</code> to pass along any HTML
    attributes and <code>listeners</code> <em>(the alias for <code>data.on</code>)</em> to pass along any event
    listeners.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">functional</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"data.attrs"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"listeners"</span></span><br><span class="hljs-tag"> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="slots-vs-children"><a href="#slots-vs-children" class="headerlink" title="slots() vs children"
        data-scroll=""><code>slots()</code> vs <code>children</code></a></h3>
<p>You may wonder why we need both <code>slots()</code> and <code>children</code>. Wouldn’t <code>slots().default</code>
    be the same as <code>children</code>? In some cases, yes - but what if you have a functional component with the
    following children?</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-functional-component</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-slot:foo</span>&gt;</span><br> first<br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>second<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-functional-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For this component, <code>children</code> will give you both paragraphs, <code>slots().default</code> will give you
    only the second, and <code>slots().foo</code> will give you only the first. Having both <code>children</code> and
    <code>slots()</code> therefore allows you to choose whether this component knows about a slot system or perhaps
    delegates that responsibility to another component by passing along <code>children</code>.</p>
<h2 id="Template-Compilation"><a href="#Template-Compilation" class="headerlink" title="Template Compilation"
        data-scroll="">Template Compilation</a></h2>
<p>You may be interested to know that Vue’s templates actually compile to render functions. This is an implementation
    detail you usually don’t need to know about, but if you’d like to see how specific template features are compiled,
    you may find it interesting. Below is a little demo using <code>Vue.compile</code> to live-compile a template
    string:</p> <iframe
    src="https://codesandbox.io/embed/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light&amp;view=preview"
    style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation"
    allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
<div class="guide-links"> <span>← <a href="/v2/guide/custom-directive.html">Custom Directives</a></span> <span
        style="float: right"><a href="/v2/guide/plugins.html">Plugins</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Plugins</h1>
<p>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are
    typically several types of plugins:</p>
<ol>
    <li>
        <p>Add some global methods or properties. e.g. <a target="_blank" rel="noopener"
                href="https://github.com/karol-f/vue-custom-element">vue-custom-element</a></p>
    </li>
    <li>
        <p>Add one or more global assets: directives/filters/transitions etc. e.g. <a target="_blank" rel="noopener"
                href="https://github.com/vuejs/vue-touch">vue-touch</a></p>
    </li>
    <li>
        <p>Add some component options by global mixin. e.g. <a target="_blank" rel="noopener"
                href="https://github.com/vuejs/vue-router">vue-router</a></p>
    </li>
    <li>
        <p>Add some Vue instance methods by attaching them to Vue.prototype.</p>
    </li>
    <li>
        <p>A library that provides an API of its own, while at the same time injecting some combination of the above.
            e.g. <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router">vue-router</a></p>
    </li>
</ol>
<h2 id="Using-a-Plugin"><a href="#Using-a-Plugin" class="headerlink" title="Using a Plugin" data-scroll="">Using a
        Plugin</a></h2>
<p>Use plugins by calling the <code>Vue.use()</code> global method. This has to be done before you start your app by
    calling <code>new Vue()</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// calls `MyPlugin.install(Vue)`</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-comment">//... options</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can optionally pass in some options:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>, { <span class="hljs-attr">someOption</span>: <span class="hljs-literal">true</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p><code>Vue.use</code> automatically prevents you from using the same plugin more than once, so calling it multiple
    times on the same plugin will install the plugin only once.</p>
<p>Some plugins provided by Vue.js official plugins such as <code>vue-router</code> automatically calls
    <code>Vue.use()</code> if <code>Vue</code> is available as a global variable. However in a module environment such
    as CommonJS, you always need to call <code>Vue.use()</code> explicitly:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// When using CommonJS via Browserify or Webpack</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vue</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue'</span>)<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">VueRouter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-router'</span>)<br><br><span class="hljs-comment">// Don't forget to call this</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Checkout <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/awesome-vue#components--libraries">awesome-vue</a> for a huge collection of
    community-contributed plugins and libraries.</p>
<h2 id="Writing-a-Plugin"><a href="#Writing-a-Plugin" class="headerlink" title="Writing a Plugin" data-scroll="">Writing
        a Plugin</a></h2>
<p>A Vue.js plugin should expose an <code>install</code> method. The method will be called with the <code>Vue</code>
    constructor as the first argument, along with possible options:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) {<br> <span class="hljs-comment">// 1. add global method or property</span><br> <span class="hljs-title class_">Vue</span>.<span class="hljs-property">myGlobalMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// some logic ...</span><br> }<br><br> <span class="hljs-comment">// 2. add a global asset</span><br> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'my-directive'</span>, {<br> bind (el, binding, vnode, oldVnode) {<br> <span class="hljs-comment">// some logic ...</span><br> }<br> ...<br> })<br><br> <span class="hljs-comment">// 3. inject some component options</span><br> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>({<br> <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// some logic ...</span><br> }<br> ...<br> })<br><br> <span class="hljs-comment">// 4. add an instance method</span><br> <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) {<br> <span class="hljs-comment">// some logic ...</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/render-function.html">Render Functions &amp; JSX</a></span> <span
        style="float: right"><a href="/v2/guide/filters.html">Filters</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Filters</h1>
<p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two
    places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong> (the latter supported in
    2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- in mustaches --&gt;</span><br>{{ message | capitalize }}<br><br><span class="hljs-comment">&lt;!-- in v-bind --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">"rawId | formatId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can define local filters in a component’s options:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">filters</span>: {<br> <span class="hljs-attr">capitalize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {<br> <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span><br> value = value.<span class="hljs-title function_">toString</span>()<br> <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>or define a filter globally before creating the Vue instance:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">'capitalize'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {<br> <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span><br> value = value.<span class="hljs-title function_">toString</span>()<br> <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>})<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-comment">// ...</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>When the global filter has the same name as the local filter, the local filter will be preferred.</p>
<p>Below is an example of our <code>capitalize</code> filter being used:</p>
<div id="example_1" class="demo"><input type="text">
    <p>John</p>
</div>
<script> new Vue({ el: '#example_1', data: function () { return { message: 'john' } }, filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } })</script>
<p>The filter’s function always receives the expression’s value (the result of the former chain) as its first argument.
    In the above example, the <code>capitalize</code> filter function will receive the value of <code>message</code> as
    its argument.</p>
<p>Filters can be chained:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html">{{ message | filterA | filterB }}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In this case, <code>filterA</code>, defined with a single argument, will receive the value of <code>message</code>,
    and then the <code>filterB</code> function will be called with the result of <code>filterA</code> passed into
    <code>filterB</code>‘s single argument.</p>
<p>Filters are JavaScript functions, therefore they can take arguments:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html">{{ message | filterA('arg1', arg2) }}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Here <code>filterA</code> is defined as a function taking three arguments. The value of <code>message</code> will be
    passed into the first argument. The plain string <code>'arg1'</code> will be passed into the <code>filterA</code> as
    its second argument, and the value of expression <code>arg2</code> will be evaluated and passed in as the third
    argument.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/plugins.html">Plugins</a></span> <span style="float: right"><a
            href="/v2/guide/single-file-components.html">Single File Components</a> →</span> </div>

<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Single File Components</h1>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction" data-scroll="">Introduction</a>
</h2>
<div class="vueschool"><a href="https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs"
        target="_blank" rel="sponsored noopener" title="Free Vue.js Single File Components lesson">Watch a free video
        lesson on Vue School</a></div>
<p>In many Vue projects, global components will be defined using <code>Vue.component</code>, followed by
    <code>new Vue({ el: '#container' })</code> to target a container element in the body of every page.</p>
<p>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views.
    In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become
    apparent:</p>
<ul>
    <li><strong>Global definitions</strong> force unique names for every component</li>
    <li><strong>String templates</strong> lack syntax highlighting and require ugly slashes for multiline HTML</li>
    <li><strong>No CSS support</strong> means that while HTML and JavaScript are modularized into components, CSS is
        conspicuously left out</li>
    <li><strong>No build step</strong> restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug
        (formerly Jade) and Babel</li>
</ul>
<p>All of these are solved by <strong>single-file components</strong> with a <code>.vue</code> extension, made possible
    with build tools such as Webpack or Browserify.</p>
<p>Here’s an example of a file we’ll call <code>Hello.vue</code>:</p>
<p><a href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components"
        target="_blank" rel="noopener noreferrer"><img src="/images/vue-component.png"
            alt="Single-file component example (click for code as text)" style="display: block; margin: 30px auto;"></a>
</p>
<p>Now we get:</p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#source-code-editing">Complete
            syntax highlighting</a></li>
    <li><a target="_blank" rel="noopener"
            href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module">CommonJS modules</a></li>
    <li><a target="_blank" rel="noopener"
            href="https://vue-loader.vuejs.org/en/features/scoped-css.html">Component-scoped CSS</a></li>
</ul>
<p>As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more
    feature-rich components.</p>
<p><a href="https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587" target="_blank"
        rel="noopener noreferrer"><img src="/images/vue-component-with-preprocessors.png"
            alt="Single-file component example with preprocessors (click for code as text)"
            style="display: block; margin: 30px auto;"></a></p>
<p>These specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever
    other preprocessors that help you be productive. If using Webpack with <code>vue-loader</code>, it also has
    first-class support for CSS Modules.</p>
<h3 id="What-About-Separation-of-Concerns"><a href="#What-About-Separation-of-Concerns" class="headerlink"
        title="What About Separation of Concerns?" data-scroll="">What About Separation of Concerns?</a></h3>
<p>One important thing to note is that <strong>separation of concerns is not equal to separation of file types.</strong>
    In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave
    with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a
    component, its template, logic and styles are inherently coupled, and collocating them actually makes the component
    more cohesive and maintainable.</p>
<p>Even if you don’t like the idea of Single-File Components, you can still leverage its hot-reloading and
    pre-compilation features by separating your JavaScript and CSS into separate files:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!-- my-component.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This will be pre-compiled<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./my-component.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./my-component.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started" data-scroll="">Getting
        Started</a></h2>
<h3 id="Example-Sandbox"><a href="#Example-Sandbox" class="headerlink" title="Example Sandbox" data-scroll="">Example
        Sandbox</a></h3>
<p>If you want to dive right in and start playing with single-file components, check out <a target="_blank"
        rel="noopener" href="https://codesandbox.io/s/o29j95wx9">this simple todo app</a> on CodeSandbox.</p>
<h3 id="For-Users-New-to-Module-Build-Systems-in-JavaScript"><a
        href="#For-Users-New-to-Module-Build-Systems-in-JavaScript" class="headerlink"
        title="For Users New to Module Build Systems in JavaScript" data-scroll="">For Users New to Module Build Systems
        in JavaScript</a></h3>
<p>With <code>.vue</code> components, we’re entering the realm of advanced JavaScript applications. That means learning
    to use a few additional tools if you haven’t already:</p>
<ul>
    <li>
        <p><strong>Node Package Manager (NPM)</strong>: Read the <a target="_blank" rel="noopener"
                href="https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry">Getting Started
                guide</a> section about how to get packages from the registry.</p>
    </li>
    <li>
        <p><strong>Modern JavaScript with ES2015/16</strong>: Read through Babel’s <a target="_blank" rel="noopener"
                href="https://babeljs.io/docs/learn-es2015/">Learn ES2015 guide</a>. You don’t have to memorize every
            feature right now, but keep this page as a reference you can come back to.</p>
    </li>
</ul>
<p>After you’ve taken a day to dive into these resources, we recommend checking out <a target="_blank" rel="noopener"
        href="https://cli.vuejs.org/">Vue CLI 3</a>. Follow the instructions and you should have a Vue project with
    <code>.vue</code> components, ES2015, Webpack and hot-reloading in no time!</p>
<h3 id="For-Advanced-Users"><a href="#For-Advanced-Users" class="headerlink" title="For Advanced Users"
        data-scroll="">For Advanced Users</a></h3>
<p>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through
    its own <a target="_blank" rel="noopener" href="https://cli.vuejs.org/config/">config options</a>.</p>
<p>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with <a
        target="_blank" rel="noopener" href="https://vue-loader.vuejs.org">vue-loader</a>. To learn more about webpack
    itself, check out <a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/">their official
        docs</a> and <a target="_blank" rel="noopener"
        href="https://webpack-academy.teachable.com/p/the-core-concepts">Webpack Academy</a>.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/filters.html">Filters</a></span> <span style="float: right"><a
            href="/v2/guide/testing.html">Testing</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Testing</h1>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction" data-scroll="">Introduction</a>
</h2>
<p>When it comes to building reliable applications, tests can play a critical role in an individual or team’s ability to
    build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are
    three categories often discussed in the context of web applications:</p>
<ul>
    <li>Unit Testing</li>
    <li>Component Testing</li>
    <li>End-To-End (E2E) Testing</li>
</ul>
<p>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue
    application or component library.</p>
<h2 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing" data-scroll="">Unit Testing</a>
</h2>
<h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"
        data-scroll="">Introduction</a></h3>
<p>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide
    developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as
    new features are built or your code is refactored your application will remain functional and stable.</p>
<p>Unit testing a Vue application does not significantly differ from testing other types of applications.</p>
<h3 id="Choosing-Your-Framework"><a href="#Choosing-Your-Framework" class="headerlink" title="Choosing Your Framework"
        data-scroll="">Choosing Your Framework</a></h3>
<p>Since unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating
    which unit testing tool is best for your application.</p>
<h4 id="First-class-error-reporting"><a href="#First-class-error-reporting" class="headerlink"
        title="First-class error reporting"></a>First-class error reporting</h4>
<p>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the
    assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug
    the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a
    test fails, e.g., what is expected vs what was received.</p>
<p>Some unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install
    assertion libraries separately (usually Chai).</p>
<h4 id="Active-community-and-team"><a href="#Active-community-and-team" class="headerlink"
        title="Active community and team"></a>Active community and team</h4>
<p>Since the majority of unit testing frameworks are open-source, having a community that is active can be critical to
    some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be
    actively maintained. In addition, having an active community has the benefit of providing more support whenever you
    run into issues.</p>
<h3 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks" data-scroll="">Frameworks</a></h3>
<p>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the
    Vue.js ecosystem.</p>
<h4 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h4>
<p>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take
    snapshots of tests in order to provide an alternative means of verifying units of your application.</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://jestjs.io">Official Jest Website</a></li>
    <li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/core-plugins/unit-jest.html">Official Vue 2 CLI
            Plugin - Jest</a></li>
</ul>
<h4 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h4>
<p>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to
    choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g.,
    Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://mochajs.org">Official Mocha Website</a></li>
    <li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/core-plugins/unit-mocha.html">Official Vue CLI
            Plugin - Mocha</a></li>
</ul>
<h2 id="Component-Testing"><a href="#Component-Testing" class="headerlink" title="Component Testing"
        data-scroll="">Component Testing</a></h2>
<h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"
        data-scroll="">Introduction</a></h3>
<p>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that
    they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created
    to give users the ability to do this reliably while also providing Vue-specific conveniences such as integrations
    for Vuex, Vue Router, and other Vue plugins.</p>
<h3 id="Choosing-Your-Framework-1"><a href="#Choosing-Your-Framework-1" class="headerlink"
        title="Choosing Your Framework" data-scroll="">Choosing Your Framework</a></h3>
<p>The following section provides guidelines on things to keep in mind when evaluating which component testing framework
    is best for your application.</p>
<h4 id="Optimal-compatibility-with-the-Vue-ecosystem"><a href="#Optimal-compatibility-with-the-Vue-ecosystem"
        class="headerlink" title="Optimal compatibility with the Vue ecosystem"></a>Optimal compatibility with the Vue
    ecosystem</h4>
<p>It should be no surprise that one of the first criteria is that a component testing library should have is being as
    compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep
    in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your
    application relies on.</p>
<h4 id="First-class-error-reporting-1"><a href="#First-class-error-reporting-1" class="headerlink"
        title="First-class error reporting"></a>First-class error reporting</h4>
<p>When tests fail, it is critical that your component testing framework provides useful error logs that help to
    minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they
    should also provide context for why a test fails, e.g., what is expected vs what was received.</p>
<h3 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"
        data-scroll="">Recommendations</a></h3>
<h4 id="Vue-Testing-Library-testing-library-vue"><a href="#Vue-Testing-Library-testing-library-vue" class="headerlink"
        title="Vue Testing Library (@testing-library/vue)"></a>Vue Testing Library (@testing-library/vue)</h4>
<p>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built
    with accessibility in mind, its approach also makes refactoring a breeze.</p>
<p>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.
</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://testing-library.com/docs/vue-testing-library/intro">Official Vue
            Testing Library Website</a></li>
</ul>
<h4 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue Test Utils"></a>Vue Test Utils</h4>
<p>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue
    specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an
    abstraction over Vue Test Utils.</p>
<p><strong>Resources</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://vue-test-utils.vuejs.org">Official Vue Test Utils
            Documentation</a></li>
    <li><a target="_blank" rel="noopener"
            href="https://lmiller1990.github.io/vue-testing-handbook/#what-is-this-guide">Vue Testing Handbook</a> by
        Lachlan Miller</li>
    <li><a href="/v2/cookbook/unit-testing-vue-components.html">Cookbook: Unit Testing Vue Components</a></li>
</ul>
<h2 id="End-to-End-E2E-Testing"><a href="#End-to-End-E2E-Testing" class="headerlink" title="End-to-End (E2E) Testing"
        data-scroll="">End-to-End (E2E) Testing</a></h2>
<h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"
        data-scroll="">Introduction</a></h3>
<p>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their
    abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E)
    tests provide coverage on what is arguably the most important aspect of an application: what happens when users
    actually use your applications.</p>
<p>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code,
    but all associated backend services and infrastructure that are more representative of the environment that your
    users will be in. By testing how user actions impact your application, E2E tests are often the key to higher
    confidence in whether an application is functioning properly or not.</p>
<h3 id="Choosing-Your-Framework-2"><a href="#Choosing-Your-Framework-2" class="headerlink"
        title="Choosing Your Framework" data-scroll="">Choosing Your Framework</a></h3>
<p>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing
    down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and
    useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep
    in mind when choosing a testing framework for your application.</p>
<h4 id="Cross-browser-testing"><a href="#Cross-browser-testing" class="headerlink"
        title="Cross-browser testing"></a>Cross-browser testing</h4>
<p>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across
    multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that
    cross browser testing has diminishing returns on a team’s resources due the additional time and machine power
    required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the
    amount of cross-browser testing your application needs.</p>
<p class="tip">A recent development in E2E for catching browser-specific issues is using application monitoring and
    error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., &lt; IE11,
    older Safari versions, etc.).</p>
<h4 id="Faster-feedback-loops"><a href="#Faster-feedback-loops" class="headerlink"
        title="Faster feedback loops"></a>Faster feedback loops</h4>
<p>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long
    time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing
    frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to
    often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a
    single test for the page you are working on while also providing hot reloading of tests can help to boost a
    developer’s workflow and productivity.</p>
<h4 id="First-class-debugging-experience"><a href="#First-class-debugging-experience" class="headerlink"
        title="First class debugging experience"></a>First class debugging experience</h4>
<p>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in
    a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar
    with, e.g. browser developer tools.</p>
<h4 id="Visibility-in-headless-mode"><a href="#Visibility-in-headless-mode" class="headerlink"
        title="Visibility in headless mode"></a>Visibility in headless mode</h4>
<p>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless
    browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical
    feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or
    videos of your applications during various testing stages in order to provide insight into why errors are happening.
    Historically, it was tedious to maintain these integrations.</p>
<h3 id="Recommendations-1"><a href="#Recommendations-1" class="headerlink" title="Recommendations"
        data-scroll="">Recommendations</a></h3>
<p>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being
    used in the Vue.js ecosystem.</p>
<h4 id="Cypress-io"><a href="#Cypress-io" class="headerlink" title="Cypress.io"></a>Cypress.io</h4>
<p>Cypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test
    their applications while providing a first class developer experience.</p>
<p><strong>Resources</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://www.cypress.io">Cypress’ Official Website</a></li>
    <li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/core-plugins/e2e-cypress.html">Official Vue CLI
            Cypress Plugin</a></li>
    <li><a target="_blank" rel="noopener" href="https://github.com/testing-library/cypress-testing-library">Cypress
            Testing Library</a></li>
</ul>
<h4 id="Nightwatch-js"><a href="#Nightwatch-js" class="headerlink" title="Nightwatch.js"></a>Nightwatch.js</h4>
<p>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as
    Node.js unit and integration testing.</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://nightwatchjs.org">Nightwatch’s Official Website</a></li>
    <li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/core-plugins/e2e-nightwatch.html">Official Vue CLI
            Nightwatch Plugin</a></li>
</ul>
<h4 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h4>
<p>Puppeteer is a Node library that provides a high-level API to control the browser and can pair with other test
    runners (e.g., Jest) to test your application.</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://pptr.dev">Puppeteer’s Official Website</a></li>
</ul>
<h4 id="TestCafe"><a href="#TestCafe" class="headerlink" title="TestCafe"></a>TestCafe</h4>
<p>TestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on
    creating tests that are easy to write and reliable.</p>
<p><strong>Resources:</strong></p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://devexpress.github.io/testcafe/">TestCafe’s Official Website</a>
    </li>
</ul>
<div class="guide-links"> <span>← <a href="/v2/guide/single-file-components.html">Single File Components</a></span>
    <span style="float: right"><a href="/v2/guide/typescript.html">TypeScript Support</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>TypeScript Support</h1>
<blockquote>
    <p><a target="_blank" rel="noopener" href="https://cli.vuejs.org">Vue CLI</a> provides built-in TypeScript tooling
        support.</p>
</blockquote>
<h2 id="Official-Declaration-in-NPM-Packages"><a href="#Official-Declaration-in-NPM-Packages" class="headerlink"
        title="Official Declaration in NPM Packages" data-scroll="">Official Declaration in NPM Packages</a></h2>
<p>A static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue
    ships with <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/tree/dev/types">official type
        declarations</a> for <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/">TypeScript</a> -
    not only in Vue core, but also for <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-router/tree/dev/types">vue-router</a> and <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vuex/tree/dev/types">vuex</a> as well.</p>
<p>Since these are <a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/npm/vue@2/types/">published on
        NPM</a>, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when
    installed via NPM, you don’t need any additional tooling to use TypeScript with Vue.</p>
<h2 id="Recommended-Configuration"><a href="#Recommended-Configuration" class="headerlink"
        title="Recommended Configuration" data-scroll="">Recommended Configuration</a></h2>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// tsconfig.json</span><br>{<br> <span class="hljs-string">"compilerOptions"</span>: {<br> <span class="hljs-comment">// this aligns with Vue's browser support</span><br> <span class="hljs-string">"target"</span>: <span class="hljs-string">"es5"</span>,<br> <span class="hljs-comment">// this enables stricter inference for data properties on `this`</span><br> <span class="hljs-string">"strict"</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-comment">// if using webpack 2+ or rollup, to leverage tree shaking:</span><br> <span class="hljs-string">"module"</span>: <span class="hljs-string">"es2015"</span>,<br> <span class="hljs-string">"moduleResolution"</span>: <span class="hljs-string">"node"</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that you have to include <code>strict: true</code> (or at least <code>noImplicitThis: true</code> which is a
    part of <code>strict</code> flag) to leverage type checking of <code>this</code> in component methods otherwise it
    is always treated as <code>any</code> type.</p>
<p>See <a target="_blank" rel="noopener"
        href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">TypeScript compiler options docs</a>
    for more details.</p>
<h2 id="Development-Tooling"><a href="#Development-Tooling" class="headerlink" title="Development Tooling"
        data-scroll="">Development Tooling</a></h2>
<h3 id="Project-Creation"><a href="#Project-Creation" class="headerlink" title="Project Creation" data-scroll="">Project
        Creation</a></h3>
<p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli">Vue CLI 3</a> can generate new projects
    that use TypeScript. To get started:</p>
<figure class="highlight bash">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs bash"><span class="hljs-comment"># 1. Install Vue CLI, if it's not already installed</span><br>npm install --global @vue/cli<br><br><span class="hljs-comment"># 2. Create a new project, then choose the "Manually select features" option</span><br>vue create my-project-name<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Editor-Support"><a href="#Editor-Support" class="headerlink" title="Editor Support" data-scroll="">Editor
        Support</a></h3>
<p>For developing Vue applications with TypeScript, we strongly recommend using <a target="_blank" rel="noopener"
        href="https://code.visualstudio.com/">Visual Studio Code</a>, which provides great out-of-the-box support for
    TypeScript. If you are using <a href="./single-file-components.html">single-file components</a> (SFCs), get the
    awesome <a target="_blank" rel="noopener" href="https://github.com/vuejs/vetur">Vetur extension</a>, which provides
    TypeScript inference inside SFCs and many other great features.</p>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/webstorm/">WebStorm</a> also provides
    out-of-the-box support for both TypeScript and Vue.</p>
<h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage" data-scroll="">Basic Usage</a></h2>
<p>To let TypeScript properly infer types inside Vue component options, you need to define components with
    <code>Vue.component</code> or <code>Vue.extend</code>:</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>({<br> <span class="hljs-comment">// type inference enabled</span><br>})<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = {<br> <span class="hljs-comment">// this will NOT have type inference,</span><br> <span class="hljs-comment">// because TypeScript can't tell this is options for a Vue component.</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Class-Style-Vue-Components"><a href="#Class-Style-Vue-Components" class="headerlink"
        title="Class-Style Vue Components" data-scroll="">Class-Style Vue Components</a></h2>
<p>If you prefer a class-based API when declaring components, you can use the officially maintained <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vue-class-component">vue-class-component</a> decorator:</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Component</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-class-component'</span><br><br><span class="hljs-comment">// The @Component decorator indicates the class is a Vue component</span><br><span class="hljs-meta">@Component</span>({<br> <span class="hljs-comment">// All component options are allowed in here</span><br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;button @click="onClick"&gt;Click!&lt;/button&gt;'</span><br>})<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> {<br> <span class="hljs-comment">// Initial data can be declared as instance properties</span><br> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello!'</span><br><br> <span class="hljs-comment">// Component methods can be declared as instance methods</span><br> onClick (): <span class="hljs-built_in">void</span> {<br> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Augmenting-Types-for-Use-with-Plugins"><a href="#Augmenting-Types-for-Use-with-Plugins" class="headerlink"
        title="Augmenting Types for Use with Plugins" data-scroll="">Augmenting Types for Use with Plugins</a></h2>
<p>Plugins may add to Vue’s global/instance properties and component options. In these cases, type declarations are
    needed to make plugins compile in TypeScript. Fortunately, there’s a TypeScript feature to augment existing types
    called <a target="_blank" rel="noopener"
        href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation">module
        augmentation</a>.</p>
<p>For example, to declare an instance property <code>$myProperty</code> with type <code>string</code>:</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-comment">// 1. Make sure to import 'vue' before declaring augmented types</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><br><span class="hljs-comment">// 2. Specify a file with the types you want to augment</span><br><span class="hljs-comment">// Vue has the constructor type in types/vue.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'vue/types/vue'</span> {<br> <span class="hljs-comment">// 3. Declare augmentation for Vue</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vue</span> {<br> <span class="hljs-attr">$myProperty</span>: <span class="hljs-built_in">string</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>After including the above code as a declaration file (like <code>my-property.d.ts</code>) in your project, you can
    use <code>$myProperty</code> on a Vue instance.</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">$myProperty</span>) <span class="hljs-comment">// This should compile successfully</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can also declare additional global properties and component options:</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'vue/types/vue'</span> {<br> <span class="hljs-comment">// Global properties can be declared</span><br> <span class="hljs-comment">// on the `VueConstructor` interface</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VueConstructor</span> {<br> <span class="hljs-attr">$myGlobal</span>: <span class="hljs-built_in">string</span><br> }<br>}<br><br><span class="hljs-comment">// ComponentOptions is declared in types/options.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'vue/types/options'</span> {<br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComponentOptions</span>&lt;V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vue</span>&gt; {<br> myOption?: <span class="hljs-built_in">string</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The above declarations allow the following code to be compiled:</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-comment">// Global property</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property">$myGlobal</span>)<br><br><span class="hljs-comment">// Additional component option</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">myOption</span>: <span class="hljs-string">'Hello'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Annotating-Return-Types"><a href="#Annotating-Return-Types" class="headerlink" title="Annotating Return Types"
        data-scroll="">Annotating Return Types</a></h2>
<p>Because of the circular nature of Vue’s declaration files, TypeScript may have difficulties inferring the types of
    certain methods. For this reason, you may need to annotate the return type on methods like <code>render</code> and
    those in <code>computed</code>.</p>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span>, { <span class="hljs-title class_">VNode</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>({<br> data () {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">msg</span>: <span class="hljs-string">'Hello'</span><br> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-comment">// need annotation due to `this` in return type</span><br> greet (): <span class="hljs-built_in">string</span> {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> + <span class="hljs-string">' world'</span><br> }<br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-comment">// need annotation</span><br> <span class="hljs-title function_">greeting</span>(): <span class="hljs-built_in">string</span> {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">greet</span>() + <span class="hljs-string">'!'</span><br> }<br> },<br> <span class="hljs-comment">// `createElement` is inferred, but `render` needs return type</span><br> render (createElement): <span class="hljs-title class_">VNode</span> {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you find type inference or member completion isn’t working, annotating certain methods may help address these
    problems. Using the <code>--noImplicitAny</code> option will help find many of these unannotated methods.</p>
<h2 id="Annotating-Props"><a href="#Annotating-Props" class="headerlink" title="Annotating Props"
        data-scroll="">Annotating Props</a></h2>
<figure class="highlight ts">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span>, { <span class="hljs-title class_">PropType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComplexMessage</span> {<br> <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>,<br> <span class="hljs-attr">okMessage</span>: <span class="hljs-built_in">string</span>,<br> <span class="hljs-attr">cancelMessage</span>: <span class="hljs-built_in">string</span><br>}<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>({<br> <span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,<br> <span class="hljs-attr">success</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span> },<br> <span class="hljs-attr">callback</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">PropType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>&gt;<br> },<br> <span class="hljs-attr">message</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">PropType</span>&lt;<span class="hljs-title class_">ComplexMessage</span>&gt;,<br> <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br> validator (<span class="hljs-attr">message</span>: <span class="hljs-title class_">ComplexMessage</span>) {<br> <span class="hljs-keyword">return</span> !!message.<span class="hljs-property">title</span>;<br> }<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you find validator not getting type inference or member completion isn’t working, annotating the argument with the
    expected type may help address these problems.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/testing.html">Testing</a></span> <span style="float: right"><a
            href="/v2/guide/deployment.html">Production Deployment</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Production Deployment</h1>
<blockquote>
    <p>Most of the tips below are enabled by default if you are using <a target="_blank" rel="noopener"
            href="https://cli.vuejs.org">Vue CLI</a>. This section is only relevant if you are using a custom build
        setup.</p>
</blockquote>
<h2 id="Turn-on-Production-Mode"><a href="#Turn-on-Production-Mode" class="headerlink" title="Turn on Production Mode"
        data-scroll="">Turn on Production Mode</a></h2>
<p>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these
    warning strings become useless in production and bloat your app’s payload size. In addition, some of these warning
    checks have small runtime costs that can be avoided in production mode.</p>
<h3 id="Without-Build-Tools"><a href="#Without-Build-Tools" class="headerlink" title="Without Build Tools"
        data-scroll="">Without Build Tools</a></h3>
<p>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use
    the minified version (<code>vue.min.js</code>) for production. Both versions can be found in the <a
        href="installation.html#Direct-lt-script-gt-Include">Installation guide</a>.</p>
<h3 id="With-Build-Tools"><a href="#With-Build-Tools" class="headerlink" title="With Build Tools" data-scroll="">With
        Build Tools</a></h3>
<p>When using a build tool like Webpack or Browserify, the production mode will be determined by
    <code>process.env.NODE_ENV</code> inside Vue’s source code, and it will be in development mode by default. Both
    build tools provide ways to overwrite this variable to enable Vue’s production mode, and warnings will be stripped
    by minifiers during the build. All <code>vue-cli</code> templates have these pre-configured for you, but it would be
    beneficial to know how it is done:</p>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4>
<p>In Webpack 4+, you can use the <code>mode</code> option:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br> <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>But in Webpack 3 and earlier, you’ll need to use <a target="_blank" rel="noopener"
        href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">plugins</span>: [<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>({<br> <span class="hljs-string">'process.env.NODE_ENV'</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">'production'</span>)<br> })<br> ]<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h4>
<ul>
    <li>
        <p>Run your bundling command with the actual <code>NODE_ENV</code> environment variable set to
            <code>"production"</code>. This tells <code>vueify</code> to avoid including hot-reload and development
            related code.</p>
    </li>
    <li>
        <p>Apply a global <a target="_blank" rel="noopener" href="https://github.com/hughsk/envify">envify</a> transform
            to your bundle. This allows the minifier to strip out all the warnings in Vue’s source code wrapped in env
            variable conditional blocks. For example:</p>
        <figure class="highlight bash">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs bash">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p>Or, using <a target="_blank" rel="noopener" href="https://github.com/hughsk/envify">envify</a> with Gulp:</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-comment">// Use the envify custom module to specify environment variables</span><br><span class="hljs-keyword">var</span> envify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'envify/custom'</span>)<br><br><span class="hljs-title function_">browserify</span>(browserifyOptions)<br> .<span class="hljs-title function_">transform</span>(vueify)<br> .<span class="hljs-title function_">transform</span>(<br> <span class="hljs-comment">// Required in order to process node_modules files</span><br> { <span class="hljs-attr">global</span>: <span class="hljs-literal">true</span> },<br> <span class="hljs-title function_">envify</span>({ <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">'production'</span> })<br> )<br> .<span class="hljs-title function_">bundle</span>()<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p>Or, using <a target="_blank" rel="noopener" href="https://github.com/hughsk/envify">envify</a> with Grunt and
            <a target="_blank" rel="noopener" href="https://github.com/jmreidy/grunt-browserify">grunt-browserify</a>:
        </p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-comment">// Use the envify custom module to specify environment variables</span><br><span class="hljs-keyword">var</span> envify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'envify/custom'</span>)<br><br><span class="hljs-attr">browserify</span>: {<br> <span class="hljs-attr">dist</span>: {<br> <span class="hljs-attr">options</span>: {<br> <span class="hljs-comment">// Function to deviate from grunt-browserify's default order</span><br> <span class="hljs-attr">configure</span>: <span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> b<br> .<span class="hljs-title function_">transform</span>(<span class="hljs-string">'vueify'</span>)<br> .<span class="hljs-title function_">transform</span>(<br> <span class="hljs-comment">// Required in order to process node_modules files</span><br> { <span class="hljs-attr">global</span>: <span class="hljs-literal">true</span> },<br> <span class="hljs-title function_">envify</span>({ <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">'production'</span> })<br> )<br> .<span class="hljs-title function_">bundle</span>()<br> }<br> }<br>}<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
</ul>
<h4 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h4>
<p>Use <a target="_blank" rel="noopener"
        href="https://github.com/rollup/plugins/tree/master/packages/replace">@rollup/plugin-replace</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> replace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@rollup/plugin-replace'</span>)<br><br><span class="hljs-title function_">rollup</span>({<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">plugins</span>: [<br> <span class="hljs-title function_">replace</span>({<br> <span class="hljs-string">'process.env.NODE_ENV'</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-string">'production'</span> )<br> })<br> ]<br>}).<span class="hljs-title function_">then</span>(...)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Pre-Compiling-Templates"><a href="#Pre-Compiling-Templates" class="headerlink" title="Pre-Compiling Templates"
        data-scroll="">Pre-Compiling Templates</a></h2>
<p>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is
    performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is
    performance-sensitive.</p>
<p>The easiest way to pre-compile templates is using <a href="single-file-components.html">Single-File Components</a> -
    the associated build setups automatically performs pre-compilation for you, so the built code contains the already
    compiled render functions instead of raw template strings.</p>
<p>If you are using Webpack, and prefer separating JavaScript and template files, you can use <a target="_blank"
        rel="noopener" href="https://github.com/ktsn/vue-template-loader">vue-template-loader</a>, which also transforms
    the template files into JavaScript render functions during the build step.</p>
<h2 id="Extracting-Component-CSS"><a href="#Extracting-Component-CSS" class="headerlink"
        title="Extracting Component CSS" data-scroll="">Extracting Component CSS</a></h2>
<p>When using Single-File Components, the CSS inside components are injected dynamically as <code>&lt;style&gt;</code>
    tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a
    “flash of unstyled content”. Extracting the CSS across all components into the same file will avoid these issues,
    and also result in better CSS minification and caching.</p>
<p>Refer to the respective build tool documentations to see how it’s done:</p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/en/configurations/extract-css.html">Webpack
            + vue-loader</a> (the <code>vue-cli</code> webpack template has this pre-configured)</li>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vueify#css-extraction">Browserify + vueify</a>
    </li>
    <li><a target="_blank" rel="noopener"
            href="https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler">Rollup + rollup-plugin-vue</a>
    </li>
</ul>
<h2 id="Tracking-Runtime-Errors"><a href="#Tracking-Runtime-Errors" class="headerlink" title="Tracking Runtime Errors"
        data-scroll="">Tracking Runtime Errors</a></h2>
<p>If a runtime error occurs during a component’s render, it will be passed to the global
    <code>Vue.config.errorHandler</code> config function if it has been set. It might be a good idea to leverage this
    hook together with an error-tracking service like <a target="_blank" rel="noopener"
        href="https://sentry.io">Sentry</a>, which provides <a target="_blank" rel="noopener"
        href="https://sentry.io/for/vue/">an official integration</a> for Vue.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/typescript.html">TypeScript Support</a></span> <span
        style="float: right"><a href="/v2/guide/routing.html">Routing</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Routing</h1>
<h2 id="Official-Router"><a href="#Official-Router" class="headerlink" title="Official Router" data-scroll="">Official
        Router</a></h2>
<p>For most Single Page Applications, it’s recommended to use the officially-supported <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-router">vue-router library</a>. For more details, see vue-router’s <a
        target="_blank" rel="noopener" href="https://router.vuejs.org/">documentation</a>.</p>
<h2 id="Simple-Routing-From-Scratch"><a href="#Simple-Routing-From-Scratch" class="headerlink"
        title="Simple Routing From Scratch" data-scroll="">Simple Routing From Scratch</a></h2>
<p>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by
    dynamically rendering a page-level component like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NotFound</span> = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;Page not found&lt;/p&gt;'</span> }<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;home page&lt;/p&gt;'</span> }<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = { <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;about page&lt;/p&gt;'</span> }<br><br><span class="hljs-keyword">const</span> routes = {<br> <span class="hljs-string">'/'</span>: <span class="hljs-title class_">Home</span>,<br> <span class="hljs-string">'/about'</span>: <span class="hljs-title class_">About</span><br>}<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">currentRoute</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-title class_">ViewComponent</span> () {<br> <span class="hljs-keyword">return</span> routes[<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRoute</span>] || <span class="hljs-title class_">NotFound</span><br> }<br> },<br> render (h) { <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">ViewComponent</span>) }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Combined with the HTML5 History API, you can build a very basic but fully-functional client-side router. To see that
    in practice, check out <a target="_blank" rel="noopener"
        href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example">this example app</a>.</p>
<h2 id="Integrating-3rd-Party-Routers"><a href="#Integrating-3rd-Party-Routers" class="headerlink"
        title="Integrating 3rd-Party Routers" data-scroll="">Integrating 3rd-Party Routers</a></h2>
<p>If there’s a 3rd-party router you prefer to use, such as <a target="_blank" rel="noopener"
        href="https://github.com/visionmedia/page.js">Page.js</a> or <a target="_blank" rel="noopener"
        href="https://github.com/flatiron/director">Director</a>, integration is <a target="_blank" rel="noopener"
        href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs">similarly easy</a>.
    Here’s a <a target="_blank" rel="noopener"
        href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs">complete example</a> using
    Page.js.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/deployment.html">Production Deployment</a></span> <span
        style="float: right"><a href="/v2/guide/state-management.html">State Management</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>State Management</h1>
<h2 id="Official-Flux-Like-Implementation"><a href="#Official-Flux-Like-Implementation" class="headerlink"
        title="Official Flux-Like Implementation" data-scroll="">Official Flux-Like Implementation</a></h2>
<p>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and
    the interactions between them. To solve this problem, Vue offers <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vuex">vuex</a>: our own Elm-inspired state management library. It even integrates
    into <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">vue-devtools</a>, providing
    zero-setup access to <a target="_blank" rel="noopener"
        href="https://raw.githubusercontent.com/vuejs/v2.vuejs.org/master/src/images/devtools-timetravel.gif">time
        travel debugging</a>.</p>
<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/" target="_blank"
        rel="sponsored noopener" title="Vuex Tutorial">Watch a video explanation on Vue Mastery</a></div>
<h3 id="Information-for-React-Developers"><a href="#Information-for-React-Developers" class="headerlink"
        title="Information for React Developers" data-scroll="">Information for React Developers</a></h3>
<p>If you’re coming from React, you may be wondering how vuex compares to <a target="_blank" rel="noopener"
        href="https://github.com/reactjs/redux">redux</a>, the most popular Flux implementation in that ecosystem. Redux
    is actually view-layer agnostic, so it can easily be used with Vue via <a target="_blank" rel="noopener"
        href="https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;p=1">simple bindings</a>. Vuex is different in
    that it <em>knows</em> it’s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API
    and improved development experience.</p>
<h2 id="Simple-State-Management-from-Scratch"><a href="#Simple-State-Management-from-Scratch" class="headerlink"
        title="Simple State Management from Scratch" data-scroll="">Simple State Management from Scratch</a></h2>
<p>It is often overlooked that the source of truth in Vue applications is the raw <code>data</code> object - a Vue
    instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple
    instances, you can share it by identity:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> sourceOfTruth = {}<br><br><span class="hljs-keyword">var</span> vmA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: sourceOfTruth<br>})<br><br><span class="hljs-keyword">var</span> vmB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: sourceOfTruth<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Now whenever <code>sourceOfTruth</code> is mutated, both <code>vmA</code> and <code>vmB</code> will update their
    views automatically. Subcomponents within each of these instances would also have access via
    <code>this.$root.$data</code>. We have a single source of truth now, but debugging would be a nightmare. Any piece
    of data could be changed by any part of our app at any time, without leaving a trace.</p>
<p>To help solve this problem, we can adopt a <strong>store pattern</strong>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> store = {<br> <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,<br> <span class="hljs-attr">state</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello!'</span><br> },<br> setMessageAction (newValue) {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">debug</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'setMessageAction triggered with'</span>, newValue)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span> = newValue<br> },<br> clearMessageAction () {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">debug</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'clearMessageAction triggered'</span>)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span> = <span class="hljs-string">''</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Notice all actions that mutate the store’s state are put inside the store itself. This type of centralized state
    management makes it easier to understand what type of mutations could happen and how they are triggered. Now when
    something goes wrong, we’ll also have a log of what happened leading up to the bug.</p>
<p>In addition, each instance/component can still own and manage its own private state:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vmA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">privateState</span>: {},<br> <span class="hljs-attr">sharedState</span>: store.<span class="hljs-property">state</span><br> }<br>})<br><br><span class="hljs-keyword">var</span> vmB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">privateState</span>: {},<br> <span class="hljs-attr">sharedState</span>: store.<span class="hljs-property">state</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p><img src="/images/state.png" alt="State Management"></p>
<p class="tip">It’s important to note that you should never replace the original state object in your actions - the
    components and the store need to share reference to the same object in order for mutations to be observed.</p>
<p>As we continue developing the convention where components are never allowed to directly mutate state that belongs to
    a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the <a
        target="_blank" rel="noopener" href="https://facebook.github.io/flux/">Flux</a> architecture. The benefit of
    this convention is we can record all state mutations happening to the store and implement advanced debugging helpers
    such as mutation logs, snapshots, and history re-rolls / time travel.</p>
<p>This brings us full circle back to <a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex">vuex</a>,
    so if you’ve read this far it’s probably time to try it out!</p>
<div class="guide-links"> <span>← <a href="/v2/guide/routing.html">Routing</a></span> <span style="float: right"><a
            href="/v2/guide/ssr.html">Server-Side Rendering</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Server-Side Rendering</h1>
<h2 id="The-Complete-SSR-Guide"><a href="#The-Complete-SSR-Guide" class="headerlink" title="The Complete SSR Guide"
        data-scroll="">The Complete SSR Guide</a></h2>
<p>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for
    those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check
    it out at <a target="_blank" rel="noopener" href="https://v2.ssr.vuejs.org/">v2.ssr.vuejs.org</a>.</p>
<h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js" data-scroll="">Nuxt.js</a></h2>
<p>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task.
    Luckily, there is an excellent community project that aims to make all of this easier: <a target="_blank"
        rel="noopener" href="https://nuxtjs.org/">Nuxt.js</a>. Nuxt.js is a higher-level framework built on top of the
    Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications.
    Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We
    highly recommend giving it a try.</p>
<h2 id="Quasar-Framework-SSR-PWA"><a href="#Quasar-Framework-SSR-PWA" class="headerlink"
        title="Quasar Framework SSR + PWA" data-scroll="">Quasar Framework SSR + PWA</a></h2>
<p><a target="_blank" rel="noopener" href="https://quasar.dev">Quasar Framework</a> will generate an SSR app (with
    optional PWA handoff) that leverages its best-in-class build system, sensible configuration and developer
    extensibility to make designing and building your idea a breeze. With over one hundred specific “Material Design
    2.0”-compliant components, you can decide which ones to execute on the server, which are available in the browser -
    and even manage the <code>&lt;meta&gt;</code> tags of your site. Quasar is a node.js and webpack based development
    environment that supercharges and streamlines rapid development of SPA, PWA, SSR, Electron, Capacitor and Cordova
    apps - all from one codebase.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/state-management.html">State Management</a></span> <span
        style="float: right"><a href="/v2/guide/security.html">Security</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Security</h1>
<h2 id="Reporting-Vulnerabilities"><a href="#Reporting-Vulnerabilities" class="headerlink"
        title="Reporting Vulnerabilities" data-scroll="">Reporting Vulnerabilities</a></h2>
<p>When a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping
    everything to work on it. To report a vulnerability, please email <a
        href="mailto:security@vuejs.org">security@vuejs.org</a>.</p>
<p>While the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its
    official companion libraries to ensure your application remains as secure as possible.</p>
<h2 id="Rule-No-1-Never-Use-Non-trusted-Templates"><a href="#Rule-No-1-Never-Use-Non-trusted-Templates"
        class="headerlink" title="Rule No.1: Never Use Non-trusted Templates" data-scroll="">Rule No.1: Never Use
        Non-trusted Templates</a></h2>
<p>The most fundamental security rule when using Vue is <strong>never use non-trusted content as your component
        template</strong>. Doing so is equivalent to allowing arbitrary JavaScript execution in your application - and
    worse, could lead to server breaches if the code is executed during server-side rendering. An example of such usage:
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;`</span> + userProvidedString + <span class="hljs-string">`&lt;/div&gt;`</span> <span class="hljs-comment">// NEVER DO THIS</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Vue templates are compiled into JavaScript, and expressions inside templates will be executed as part of the
    rendering process. Although the expressions are evaluated against a specific rendering context, due to the
    complexity of potential global execution environments, it is impractical for a framework like Vue to completely
    shield you from potential malicious code execution without incurring unrealistic performance overhead. The most
    straightforward way to avoid this category of problems altogether is to make sure the contents of your Vue templates
    are always trusted and entirely controlled by you.</p>
<h2 id="What-Vue-Does-to-Protect-You"><a href="#What-Vue-Does-to-Protect-You" class="headerlink"
        title="What Vue Does to Protect You" data-scroll="">What Vue Does to Protect You</a></h2>
<h3 id="HTML-content"><a href="#HTML-content" class="headerlink" title="HTML content" data-scroll="">HTML content</a>
</h3>
<p>Whether using templates or render functions, content is automatically escaped. That means in this template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ userProvidedString }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>if <code>userProvidedString</code> contained:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-string">'&lt;script&gt;alert("hi")&lt;/script&gt;'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>then it would be escaped to the following HTML:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(<span class="hljs-symbol">&amp;quot;</span>hi<span class="hljs-symbol">&amp;quot;</span>)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>thus preventing the script injection. This escaping is done using native browser APIs, like <code>textContent</code>,
    so a vulnerability can only exist if the browser itself is vulnerable.</p>
<h3 id="Attribute-bindings"><a href="#Attribute-bindings" class="headerlink" title="Attribute bindings"
        data-scroll="">Attribute bindings</a></h3>
<p>Similarly, dynamic attribute bindings are also automatically escaped. That means in this template:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"userProvidedString"</span>&gt;</span><br> hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>if <code>userProvidedString</code> contained:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-string">'" onclick="alert(\'hi\')'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>then it would be escaped to the following HTML:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-symbol">&amp;quot;</span> onclick=<span class="hljs-symbol">&amp;quot;</span>alert('hi')<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>thus preventing the close of the <code>title</code> attribute to inject new, arbitrary HTML. This escaping is done
    using native browser APIs, like <code>setAttribute</code>, so a vulnerability can only exist if the browser itself
    is vulnerable.</p>
<h2 id="Potential-Dangers"><a href="#Potential-Dangers" class="headerlink" title="Potential Dangers"
        data-scroll="">Potential Dangers</a></h2>
<p>In any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is
    potentially dangerous, so should be avoided wherever possible. There are times when some risk be acceptable though.
</p>
<p>For example, services like CodePen and JSFiddle allow user-provided content to be executed, but it’s in a context
    where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature
    inherently requires some level of vulnerability, it’s up to your team to weigh the importance of the feature against
    the worst-case scenarios the vulnerability enables.</p>
<h3 id="Injecting-HTML"><a href="#Injecting-HTML" class="headerlink" title="Injecting HTML" data-scroll="">Injecting
        HTML</a></h3>
<p>As you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable
    HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML
    content:</p>
<ul>
    <li>
        <p>Using a template:</p>
        <figure class="highlight html">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">"userProvidedHtml"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p>Using a render function:</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, {<br> <span class="hljs-attr">domProps</span>: {<br> <span class="hljs-attr">innerHTML</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">userProvidedHtml</span><br> }<br>})<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p>Using a render function with JSX:</p>
        <figure class="highlight jsx">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs jsx">&lt;div domPropsInnerHTML={<span class="hljs-variable language_">this</span>.<span class="hljs-property">userProvidedHtml</span>}&gt;&lt;/div&gt;<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
</ul>
<p class="tip">Note that user-provided HTML can never be considered 100% safe unless it’s in a sandboxed iframe or in a
    part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to
    write their own Vue templates brings similar dangers.</p>
<h3 id="Injecting-URLs"><a href="#Injecting-URLs" class="headerlink" title="Injecting URLs" data-scroll="">Injecting
        URLs</a></h3>
<p>In a URL like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"userProvidedUrl"</span>&gt;</span><br> click me<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>There’s a potential security issue if the URL has not been “sanitized” to prevent JavaScript execution using
    <code>javascript:</code>. There are libraries such as <a target="_blank" rel="noopener"
        href="https://www.npmjs.com/package/@braintree/sanitize-url">sanitize-url</a> to help with this, but note:</p>
<p class="tip">If you’re ever doing URL sanitization on the frontend, you already have a security issue. User-provided
    URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided
    for <em>every</em> client connecting to your API, including native mobile apps. Also note that even with sanitized
    URLs, Vue cannot help you guarantee that they lead to safe destinations.</p>
<h3 id="Injecting-Styles"><a href="#Injecting-Styles" class="headerlink" title="Injecting Styles"
        data-scroll="">Injecting Styles</a></h3>
<p>Looking at this example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"sanitizedUrl"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"userProvidedStyles"</span></span><br><span class="hljs-tag">&gt;</span><br> click me<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>let’s assume that <code>sanitizedUrl</code> has been sanitized, so that it’s definitely a real URL and not
    JavaScript. With the <code>userProvidedStyles</code>, malicious users could still provide CSS to “click jack”, e.g.
    styling the link into a transparent box over the “Log in” button. Then if
    <code>https://user-controlled-website.com/</code> is built to resemble the login page of your application, they
    might have just captured a user’s real login information.</p>
<p>You may be able to imagine how allowing user-provided content for a <code>&lt;style&gt;</code> element would create
    an even greater vulnerability, giving that user full control over how to style the entire page. That’s why Vue
    prevents rendering of style tags inside templates, such as:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>{{ userProvidedStyles }}<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To keep your users fully safe from click jacking, we recommend only allowing full control over CSS inside a sandboxed
    iframe. Alternatively, when providing user control through a style binding, we recommend using its <a
        href="class-and-style.html#Object-Syntax-1">object syntax</a> and only allowing users to provide values for
    specific properties it’s safe for them to control, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"sanitizedUrl"</span></span><br><span class="hljs-tag"> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"{</span></span><br><span class="hljs-string"><span class="hljs-tag"> color: userProvidedColor,</span></span><br><span class="hljs-string"><span class="hljs-tag"> background: userProvidedBackground</span></span><br><span class="hljs-string"><span class="hljs-tag"> }"</span></span><br><span class="hljs-tag">&gt;</span><br> click me<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Injecting-JavaScript"><a href="#Injecting-JavaScript" class="headerlink" title="Injecting JavaScript"
        data-scroll="">Injecting JavaScript</a></h3>
<p>We strongly discourage ever rendering a <code>&lt;script&gt;</code> element with Vue, since templates and render
    functions should never have side effects. However, this isn’t the only way to include strings that would be
    evaluated as JavaScript at runtime.</p>
<p>Every HTML element has attributes with values accepting strings of JavaScript, such as <code>onclick</code>,
    <code>onfocus</code>, and <code>onmouseenter</code>. Binding user-provided JavaScript to any of these event
    attributes is a potential security risk, so should be avoided.</p>
<p class="tip">Note that user-provided JavaScript can never be considered 100% safe unless it’s in a sandboxed iframe or
    in a part of the app where only the user who wrote that JavaScript can ever be exposed to it.</p>
<p>Sometimes we receive vulnerability reports on how it’s possible to do cross-site scripting (XSS) in Vue templates. In
    general, we do not consider such cases to be actual vulnerabilities, because there’s no practical way to protect
    developers from the two scenarios that would allow XSS:</p>
<ol>
    <li>
        <p>The developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is
            inherently unsafe and there’s no way for Vue to know the origin.</p>
    </li>
    <li>
        <p>The developer is mounting Vue to an entire HTML page which happens to contain server-rendered and
            user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without
            realizing. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain
            HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain
            server-rendered and user-provided content.</p>
    </li>
</ol>
<h2 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices" data-scroll="">Best
        Practices</a></h2>
<p>The general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript,
    or even CSS), you might be opening yourself up to attacks. This advice actually holds true whether using Vue,
    another framework, or even no framework.</p>
<p>Beyond the recommendations made above for <a href="#Potential-Dangers">Potential Dangers</a>, we also recommend
    familiarizing yourself with these resources:</p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://html5sec.org/">HTML5 Security Cheat Sheet</a></li>
    <li><a target="_blank" rel="noopener"
            href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">OWASP’s
            Cross Site Scripting (XSS) Prevention Cheat Sheet</a></li>
</ul>
<p>Then use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if
    any of them include 3rd-party components or otherwise influence what’s rendered to the DOM.</p>
<h2 id="Backend-Coordination"><a href="#Backend-Coordination" class="headerlink" title="Backend Coordination"
        data-scroll="">Backend Coordination</a></h2>
<p>HTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI),
    are primarily addressed on the backend, so aren’t a concern of Vue’s. However, it’s still a good idea to communicate
    with your backend team to learn how to best interact with their API, e.g. by submitting CSRF tokens with form
    submissions.</p>
<h2 id="Server-Side-Rendering-SSR"><a href="#Server-Side-Rendering-SSR" class="headerlink"
        title="Server-Side Rendering (SSR)" data-scroll="">Server-Side Rendering (SSR)</a></h2>
<p>There are some additional security concerns when using SSR, so make sure to follow the best practices outlined
    throughout <a target="_blank" rel="noopener" href="https://v2.ssr.vuejs.org/">our SSR documentation</a> to avoid
    vulnerabilities.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/ssr.html">Server-Side Rendering</a></span> <span
        style="float: right"><a href="/v2/guide/reactivity.html">Reactivity in Depth</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Reactivity in Depth</h1>
<p>Now it’s time to take a deep dive! One of Vue’s most distinct features is the unobtrusive reactivity system. Models
    are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and
    intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are
    going to dig into some of the lower-level details of Vue’s reactivity system.</p>
<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system"
        target="_blank" rel="sponsored noopener" title="Vue Reactivity">Watch a video explanation on Vue Mastery</a>
</div>
<h2 id="How-Changes-Are-Tracked"><a href="#How-Changes-Are-Tracked" class="headerlink" title="How Changes Are Tracked"
        data-scroll="">How Changes Are Tracked</a></h2>
<p>When you pass a plain JavaScript object to a Vue instance as its <code>data</code> option, Vue will walk through all
    of its properties and convert them to <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters">getter/setters</a>
    using <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>.
    This is an ES5-only and un-shimmable feature, which is why Vue doesn’t support IE8 and below.</p>
<p>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and
    change-notification when properties are accessed or modified. One caveat is that browser consoles format
    getter/setters differently when converted data objects are logged, so you may want to install <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vue-devtools">vue-devtools</a> for a more inspection-friendly
    interface.</p>
<p>Every component instance has a corresponding <strong>watcher</strong> instance, which records any properties
    “touched” during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it
    notifies the watcher, which in turn causes the component to re-render.</p>
<p><img src="/images/data.png" alt="Reactivity Cycle"></p>
<h2 id="Change-Detection-Caveats"><a href="#Change-Detection-Caveats" class="headerlink"
        title="Change Detection Caveats" data-scroll="">Change Detection Caveats</a></h2>
<p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong>. However, there
    are ways to circumvent them to preserve reactivity.</p>
<h3 id="For-Objects"><a href="#For-Objects" class="headerlink" title="For Objects" data-scroll="">For Objects</a></h3>
<p>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during
    instance initialization, a property must be present in the <code>data</code> object in order for Vue to convert it
    and make it reactive. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br> }<br>})<br><span class="hljs-comment">// `vm.a` is now reactive</span><br><br>vm.<span class="hljs-property">b</span> = <span class="hljs-number">2</span><br><span class="hljs-comment">// `vm.b` is NOT reactive</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However,
    it’s possible to add reactive properties to a nested object using the
    <code>Vue.set(object, propertyName, value)</code> method:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">someObject</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can also use the <code>vm.$set</code> instance method, which is an alias to the global <code>Vue.set</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Sometimes you may want to assign a number of properties to an existing object, for example using
    <code>Object.assign()</code> or <code>_.extend()</code>. However, new properties added to the object will not
    trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin
    object:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// instead of `Object.assign(this.someObject, { a: 1, b: 2 })`</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, <span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>, { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> })<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="For-Arrays"><a href="#For-Arrays" class="headerlink" title="For Arrays" data-scroll="">For Arrays</a></h3>
<p>Vue cannot detect the following changes to an array:</p>
<ol>
    <li>When you directly set an item with the index, e.g. <code>vm.items[indexOfItem] = newValue</code></li>
    <li>When you modify the length of the array, e.g. <code>vm.items.length = newLength</code></li>
</ol>
<p>For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">items</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]<br> }<br>})<br>vm.<span class="hljs-property">items</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">'x'</span> <span class="hljs-comment">// is NOT reactive</span><br>vm.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// is NOT reactive</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To overcome caveat 1, both of the following will accomplish the same as
    <code>vm.items[indexOfItem] = newValue</code>, but will also trigger state updates in the reactivity system:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Vue.set</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">items</span>, indexOfItem, newValue)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Array.prototype.splice</span><br>vm.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(indexOfItem, <span class="hljs-number">1</span>, newValue)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can also use the <a href="/v2/api/#vm-set"><code>vm.$set</code></a> instance method, which is an alias for the
    global <code>Vue.set</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">vm.$set(vm.<span class="hljs-property">items</span>, indexOfItem, newValue)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>To deal with caveat 2, you can use <code>splice</code>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">vm.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(newLength)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Declaring-Reactive-Properties"><a href="#Declaring-Reactive-Properties" class="headerlink"
        title="Declaring Reactive Properties" data-scroll="">Declaring Reactive Properties</a></h2>
<p>Since Vue doesn’t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by
    declaring all root-level reactive data properties upfront, even with an empty value:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-comment">// declare message with an empty value</span><br> <span class="hljs-attr">message</span>: <span class="hljs-string">''</span><br> },<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{ message }}&lt;/div&gt;'</span><br>})<br><span class="hljs-comment">// set `message` later</span><br>vm.<span class="hljs-property">message</span> = <span class="hljs-string">'Hello!'</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you don’t declare <code>message</code> in the data option, Vue will warn you that the render function is trying to
    access a property that doesn’t exist.</p>
<p>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking
    system, and also makes Vue instances play nicer with type checking systems. But there is also an important
    consideration in terms of code maintainability: the <code>data</code> object is like the schema for your component’s
    state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later
    or read by another developer.</p>
<h2 id="Async-Update-Queue"><a href="#Async-Update-Queue" class="headerlink" title="Async Update Queue"
        data-scroll="">Async Update Queue</a></h2>
<p>In case you haven’t noticed yet, Vue performs DOM updates <strong>asynchronously</strong>. Whenever a data change is
    observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same
    watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is
    important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop “tick”, Vue
    flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native
    <code>Promise.then</code>, <code>MutationObserver</code>, and <code>setImmediate</code> for the asynchronous queuing
    and falls back to <code>setTimeout(fn, 0)</code>.</p>
<p>For example, when you set <code>vm.someData = 'new value'</code>, the component will not re-render immediately. It
    will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it
    can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally
    encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be
    necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change,
    you can use <code>Vue.nextTick(callback)</code> immediately after the data is changed. The callback will be called
    after the DOM has been updated. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#example'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'123'</span><br> }<br>})<br>vm.<span class="hljs-property">message</span> = <span class="hljs-string">'new message'</span> <span class="hljs-comment">// change data</span><br>vm.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span> === <span class="hljs-string">'new message'</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> vm.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span> === <span class="hljs-string">'new message'</span> <span class="hljs-comment">// true</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>There is also the <code>vm.$nextTick()</code> instance method, which is especially handy inside components, because
    it doesn’t need global <code>Vue</code> and its callback’s <code>this</code> context will be automatically bound to
    the current Vue instance:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">'example'</span>, {<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;span&gt;{{ message }}&lt;/span&gt;'</span>,<br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">message</span>: <span class="hljs-string">'not updated'</span><br> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">updateMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">'updated'</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; 'not updated'</span><br> <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; 'updated'</span><br> })<br> }<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Since <code>$nextTick()</code> returns a promise, you can achieve the same as the above using the new <a
        target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017
        async/await</a> syntax:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">updateMessage</span>: <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">'updated'</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; 'not updated'</span><br> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.$nextTick()<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; 'updated'</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="guide-links"> <span>← <a href="/v2/guide/security.html">Security</a></span> <span style="float: right"><a
            href="/v2/guide/migration.html">Migration from Vue 1.x</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Migration from Vue 1.x</h1>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ" data-scroll="">FAQ</a></h2>
<blockquote>
    <p>Woah - this is a super long page! Does that mean 2.0 is completely different, I’ll have to learn the basics all
        over again, and migrating will be practically impossible?</p>
</blockquote>
<p>I’m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven’t changed. It’s
    long because we like to offer very detailed explanations and include a lot of examples. Rest assured, <strong>this
        is not something you have to read from top to bottom!</strong></p>
<blockquote>
    <p>Where should I start in a migration?</p>
</blockquote>
<ol>
    <li>
        <p>Start by running the <a target="_blank" rel="noopener"
                href="https://github.com/vuejs/vue-migration-helper">migration helper</a> on a current project. We’ve
            carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they
            recognize an obsolete feature, they’ll let you know, offer suggestions, and provide links to more info.</p>
    </li>
    <li>
        <p>After that, browse through the table of contents for this page in the sidebar. If you see a topic you may be
            affected by, but the migration helper didn’t catch, check it out.</p>
    </li>
    <li>
        <p>If you have any tests, run them and see what still fails. If you don’t have tests, just open the app in your
            browser and keep an eye out for warnings or errors as you navigate around.</p>
    </li>
    <li>
        <p>By now, your app should be fully migrated. If you’re still hungry for more though, you can read the rest of
            this page - or dive in to the new and improved guide from <a href="index.html">the beginning</a>. Many parts
            will be skimmable, since you’re already familiar with the core concepts.</p>
    </li>
</ol>
<blockquote>
    <p>How long will it take to migrate a Vue 1.x app to 2.0?</p>
</blockquote>
<p>It depends on a few factors:</p>
<ul>
    <li>
        <p>The size of your app (small to medium-sized apps will probably be less than a day)</p>
    </li>
    <li>
        <p>How many times you get distracted and start playing with a cool new feature. 😉 &nbsp;Not judging, it also
            happened to us while building 2.0!</p>
    </li>
    <li>
        <p>Which obsolete features you’re using. Most can be upgraded with find-and-replace, but others might take a few
            minutes. If you’re not currently following best practices, Vue 2.0 will also try harder to force you to.
            This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.
        </p>
    </li>
</ul>
<blockquote>
    <p>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</p>
</blockquote>
<p>Only Vue Router 2 is compatible with Vue 2, so yes, you’ll have to follow the <a
        href="migration-vue-router.html">migration path for Vue Router</a> as well. Fortunately, most applications don’t
    have a lot of router code, so this likely won’t take more than an hour.</p>
<p>As for Vuex, even version 0.8 is compatible with Vue 2, so you’re not forced to upgrade. The only reason you may want
    to upgrade immediately is to take advantage of the new features in Vuex 2, such as modules and reduced boilerplate.
</p>
<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates" data-scroll="">Templates</a></h2>
<h3 id="Fragment-Instances-removed"><a href="#Fragment-Instances-removed" class="headerlink"
        title="Fragment Instances removed" data-scroll="">Fragment Instances <sup>removed</sup></a></h3>
<p>Every component must have exactly one root element. Fragment instances are no longer allowed. If you have a template
    like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>bar<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>It’s recommended to wrap the entire contents in a new element, like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>bar<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite or app after upgrading and look for <strong>console warnings</strong> about
        multiple root elements in a template.</p>
</div>
<h2 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks" data-scroll="">Lifecycle
        Hooks</a></h2>
<h3 id="beforeCompile-removed"><a href="#beforeCompile-removed" class="headerlink" title="beforeCompile removed"
        data-scroll=""><code>beforeCompile</code> <sup>removed</sup></a></h3>
<p>Use the <code>created</code> hook instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h3 id="compiled-replaced"><a href="#compiled-replaced" class="headerlink" title="compiled replaced"
        data-scroll=""><code>compiled</code> <sup>replaced</sup></a></h3>
<p>Use the new <code>mounted</code> hook instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h3 id="attached-removed"><a href="#attached-removed" class="headerlink" title="attached removed"
        data-scroll=""><code>attached</code> <sup>removed</sup></a></h3>
<p>Use a custom in-DOM check in other hooks. For example, to replace:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">attached</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">doSomething</span>()<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You could use:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">doSomething</span>()<br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h3 id="detached-removed"><a href="#detached-removed" class="headerlink" title="detached removed"
        data-scroll=""><code>detached</code> <sup>removed</sup></a></h3>
<p>Use a custom in-DOM check in other hooks. For example, to replace:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">detached</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">doSomething</span>()<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You could use:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">destroyed</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-title function_">doSomething</span>()<br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h3 id="init-renamed"><a href="#init-renamed" class="headerlink" title="init renamed" data-scroll=""><code>init</code>
        <sup>renamed</sup></a></h3>
<p>Use the new <code>beforeCreate</code> hook instead, which is essentially the same thing. It was renamed for
    consistency with other lifecycle methods.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h3 id="ready-replaced"><a href="#ready-replaced" class="headerlink" title="ready replaced"
        data-scroll=""><code>ready</code> <sup>replaced</sup></a></h3>
<p>Use the new <code>mounted</code> hook instead. It should be noted though that with <code>mounted</code>, there’s no
    guarantee to be in-document. For that, also include <code>Vue.nextTick</code>/<code>vm.$nextTick</code>. For
    example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// code that assumes this.$el is in-document</span><br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find all examples of this hook.</p>
</div>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for" data-scroll=""><code>v-for</code></a></h2>
<h3 id="v-for-Argument-Order-for-Arrays-changed"><a href="#v-for-Argument-Order-for-Arrays-changed" class="headerlink"
        title="v-for Argument Order for Arrays changed" data-scroll=""><code>v-for</code> Argument Order for Arrays
        <sup>changed</sup></a></h3>
<p>When including an <code>index</code>, the argument order for arrays used to be <code>(index, value)</code>. It is now
    <code>(value, index)</code> to be more consistent with JavaScript’s native array methods such as
    <code>forEach</code> and <code>map</code>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete argument order. Note that if you name your
        index arguments something unusual like <code>position</code> or <code>num</code>, the helper will not flag them.
    </p>
</div>
<h3 id="v-for-Argument-Order-for-Objects-changed"><a href="#v-for-Argument-Order-for-Objects-changed" class="headerlink"
        title="v-for Argument Order for Objects changed" data-scroll=""><code>v-for</code> Argument Order for Objects
        <sup>changed</sup></a></h3>
<p>When including a property name/key, the argument order for objects used to be <code>(name, value)</code>. It is now
    <code>(value, name)</code> to be more consistent with common object iterators such as lodash’s.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete argument order. Note that if you name your key
        arguments something like <code>name</code> or <code>property</code>, the helper will not flag them.</p>
</div>
<h3 id="index-and-key-removed"><a href="#index-and-key-removed" class="headerlink" title="$index and $key removed"
        data-scroll=""><code>$index</code> and <code>$key</code> <sup>removed</sup></a></h3>
<p>The implicitly assigned <code>$index</code> and <code>$key</code> variables have been removed in favor of explicitly
    defining them in <code>v-for</code>. This makes the code easier to read for developers less experienced with Vue and
    also results in much clearer behavior when dealing with nested loops.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of these removed variables. If you miss any, you should also
        see <strong>console errors</strong> such as: <code>Uncaught ReferenceError: $index is not defined</code></p>
</div>
<h3 id="track-by-replaced"><a href="#track-by-replaced" class="headerlink" title="track-by replaced"
        data-scroll=""><code>track-by</code> <sup>replaced</sup></a></h3>
<p><code>track-by</code> has been replaced with <code>key</code>, which works like any other attribute: without the
    <code>v-bind:</code> or <code>:</code> prefix, it is treated as a literal string. In most cases, you’d want to use a
    dynamic binding which expects a full expression instead of a key. For example, in place of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">track-by</span>=<span class="hljs-string">"id"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You would now write:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>track-by</code>.</p>
</div>
<h3 id="v-for-Range-Values-changed"><a href="#v-for-Range-Values-changed" class="headerlink"
        title="v-for Range Values changed" data-scroll=""><code>v-for</code> Range Values <sup>changed</sup></a></h3>
<p>Previously, <code>v-for="number in 10"</code> would have <code>number</code> starting at 0 and ending at 9. Now it
    starts at 1 and ends at 10.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Search your codebase for the regex <code>/\w+ in \d+/</code>. Wherever it appears in a <code>v-for</code>, check
        to see if you may be affected.</p>
</div>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props" data-scroll="">Props</a></h2>
<h3 id="coerce-Prop-Option-removed"><a href="#coerce-Prop-Option-removed" class="headerlink"
        title="coerce Prop Option removed" data-scroll=""><code>coerce</code> Prop Option <sup>removed</sup></a></h3>
<p>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">username</span>: {<br> <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br> <span class="hljs-attr">coerce</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {<br> <span class="hljs-keyword">return</span> value<br> .<span class="hljs-title function_">toLowerCase</span>()<br> .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/</span>, <span class="hljs-string">'-'</span>)<br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You could write:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">props</span>: {<br> <span class="hljs-attr">username</span>: <span class="hljs-title class_">String</span>,<br>},<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">normalizedUsername</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span><br> .<span class="hljs-title function_">toLowerCase</span>()<br> .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/</span>, <span class="hljs-string">'-'</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>There are a few advantages:</p>
<ul>
    <li>You still have access to the original value of the prop.</li>
    <li>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value
        passed in the prop.</li>
</ul>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>coerce</code> option.</p>
</div>
<h3 id="twoWay-Prop-Option-removed"><a href="#twoWay-Prop-Option-removed" class="headerlink"
        title="twoWay Prop Option removed" data-scroll=""><code>twoWay</code> Prop Option <sup>removed</sup></a></h3>
<p>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit
    an event instead of relying on implicit binding. For more information, see:</p>
<ul>
    <li><a href="components.html#Custom-Events">Custom component events</a></li>
    <li><a href="components.html#Form-Input-Components-using-Custom-Events">Custom input components</a> (using component
        events)</li>
    <li><a href="state-management.html">Global state management</a></li>
</ul>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>twoWay</code> option.</p>
</div>
<h3 id="once-and-sync-Modifiers-on-v-bind-removed"><a href="#once-and-sync-Modifiers-on-v-bind-removed"
        class="headerlink" title=".once and .sync Modifiers on v-bind removed" data-scroll=""><code>.once</code> and
        <code>.sync</code> Modifiers on <code>v-bind</code> <sup>removed</sup></a></h3>
<p>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit
    an event instead of relying on implicit binding. For more information, see:</p>
<ul>
    <li><a href="components.html#Custom-Events">Custom component events</a></li>
    <li><a href="components.html#Form-Input-Components-using-Custom-Events">Custom input components</a> (using component
        events)</li>
    <li><a href="state-management.html">Global state management</a></li>
</ul>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>.once</code> and <code>.sync</code> modifiers.</p>
</div>
<h3 id="Prop-Mutation-deprecated"><a href="#Prop-Mutation-deprecated" class="headerlink"
        title="Prop Mutation deprecated" data-scroll="">Prop Mutation <sup>deprecated</sup></a></h3>
<p>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting
    <code>this.myProp = 'someOtherValue'</code> in the component. Due to the new rendering mechanism, whenever the
    parent component re-renders, the child component’s local changes will be overwritten.</p>
<p>Most use cases of mutating a prop can be replaced by one of these options:</p>
<ul>
    <li>a data property, with the prop used to set its default value</li>
    <li>a computed property</li>
</ul>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite or app after upgrading and look for <strong>console warnings</strong> about prop
        mutations.</p>
</div>
<h3 id="Props-on-a-Root-Instance-replaced"><a href="#Props-on-a-Root-Instance-replaced" class="headerlink"
        title="Props on a Root Instance replaced" data-scroll="">Props on a Root Instance <sup>replaced</sup></a></h3>
<p>On root Vue instances (i.e. instances created with <code>new Vue({ ... })</code>), you must use
    <code>propsData</code> instead of <code>props</code>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite, if you have one. The <strong>failed tests</strong> should alert to you to the
        fact that props passed to root instances are no longer working.</p>
</div>
<h2 id="Computed-properties"><a href="#Computed-properties" class="headerlink" title="Computed properties"
        data-scroll="">Computed properties</a></h2>
<h3 id="cache-false-deprecated"><a href="#cache-false-deprecated" class="headerlink" title="cache: false deprecated"
        data-scroll=""><code>cache: false</code> <sup>deprecated</sup></a></h3>
<p>Caching invalidation of computed properties will be removed in future major versions of Vue. Replace any uncached
    computed properties with methods, which will have the same result.</p>
<p>For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;message: {{ timeMessage }}&lt;/p&gt;'</span>,<br><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">timeMessage</span>: {<br> <span class="hljs-attr">cache</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span><br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or with component methods:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;p&gt;message: {{ getTimeMessage() }}&lt;/p&gt;'</span>,<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">getTimeMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>cache: false</code> option.</p>
</div>
<h2 id="Built-In-Directives"><a href="#Built-In-Directives" class="headerlink" title="Built-In Directives"
        data-scroll="">Built-In Directives</a></h2>
<h3 id="Truthiness-Falsiness-with-v-bind-changed"><a href="#Truthiness-Falsiness-with-v-bind-changed" class="headerlink"
        title="Truthiness/Falsiness with v-bind changed" data-scroll="">Truthiness/Falsiness with <code>v-bind</code>
        <sup>changed</sup></a></h3>
<p>When used with <code>v-bind</code>, the only falsy values are now: <code>null</code>, <code>undefined</code>, and
    <code>false</code>. This means <code>0</code> and empty strings will render as truthy. So for example,
    <code>v-bind:draggable="''"</code> will render as <code>draggable="true"</code>.</p>
<p>For enumerated attributes, in addition to the falsy values above, the string <code>"false"</code> will also render as
    <code>attr="false"</code>.</p>
<p class="tip">Note that for other directives (e.g. <code>v-if</code> and <code>v-show</code>), JavaScript’s normal
    truthiness still applies.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite, if you have one. The <strong>failed tests</strong> should alert to you to any
        parts of your app that may be affected by this change.</p>
</div>
<h3 id="Listening-for-Native-Events-on-Components-with-v-on-changed"><a
        href="#Listening-for-Native-Events-on-Components-with-v-on-changed" class="headerlink"
        title="Listening for Native Events on Components with v-on changed" data-scroll="">Listening for Native Events
        on Components with <code>v-on</code> <sup>changed</sup></a></h3>
<p>When used on a component, <code>v-on</code> now only listens to custom events <code>$emit</code>ted by that
    component. To listen for a native DOM event on the root element, you can use the <code>.native</code> modifier. For
    example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-on:click.native</span>=<span class="hljs-string">"doSomething"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite, if you have one. The <strong>failed tests</strong> should alert to you to any
        parts of your app that may be affected by this change.</p>
</div>
<h3 id="debounce-Param-Attribute-for-v-model-removed"><a href="#debounce-Param-Attribute-for-v-model-removed"
        class="headerlink" title="debounce Param Attribute for v-model removed" data-scroll=""><code>debounce</code>
        Param Attribute for <code>v-model</code> <sup>removed</sup></a></h3>
<p>Debouncing is used to limit how often we execute Ajax requests and other expensive operations. Vue’s
    <code>debounce</code> attribute parameter for <code>v-model</code> made this easy for very simple cases, but it
    actually debounced <strong>state updates</strong> rather than the expensive operations themselves. It’s a subtle
    difference, but it comes with limitations as an application grows.</p>
<p>These limitations become apparent when designing a search indicator, like this one for example:</p>
<script src="https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js"></script>
<div id="debounce-search-demo" class="demo"><input placeholder="Type something"> <strong>✓ Done</strong></div>
<script> new Vue({ el: '#debounce-search-demo', data: { searchQuery: '', searchQueryIsDirty: false, isCalculating: false }, computed: { searchIndicator: function () { if (this.isCalculating) { return '⟳ Fetching new results' } else if (this.searchQueryIsDirty) { return '... Typing' } else { return '✓ Done' } } }, watch: { searchQuery: function () { this.searchQueryIsDirty = true this.expensiveOperation() } }, methods: { expensiveOperation: _.debounce(function () { this.isCalculating = true setTimeout(function () { this.isCalculating = false this.searchQueryIsDirty = false }.bind(this), 1000) }, 500) } })</script>
<p>Using the <code>debounce</code> attribute, there’d be no way to detect the “Typing” state, because we lose access to
    the input’s real-time state. By decoupling the debounce function from Vue however, we’re able to debounce only the
    operation we want to limit, removing the limits on features we can develop:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">By using the debounce function from lodash or another dedicated</span><br><span class="hljs-comment">utility library, we know the specific debounce implementation we</span><br><span class="hljs-comment">use will be best-in-class - and we can use it ANYWHERE. Not only</span><br><span class="hljs-comment">in our template.</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"debounce-search-demo"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"searchQuery"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Type something"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{{ searchIndicator }}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#debounce-search-demo'</span>,<br> <span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">searchQuery</span>: <span class="hljs-string">''</span>,<br> <span class="hljs-attr">searchQueryIsDirty</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">isCalculating</span>: <span class="hljs-literal">false</span><br> },<br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">searchIndicator</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isCalculating</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'⟳ Fetching new results'</span><br> } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">searchQueryIsDirty</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'... Typing'</span><br> } <span class="hljs-keyword">else</span> {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'✓ Done'</span><br> }<br> }<br> },<br> <span class="hljs-attr">watch</span>: {<br> <span class="hljs-attr">searchQuery</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchQueryIsDirty</span> = <span class="hljs-literal">true</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">expensiveOperation</span>()<br> }<br> },<br> <span class="hljs-attr">methods</span>: {<br> <span class="hljs-comment">// This is where the debounce actually belongs.</span><br> <span class="hljs-attr">expensiveOperation</span>: _.<span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isCalculating</span> = <span class="hljs-literal">true</span><br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isCalculating</span> = <span class="hljs-literal">false</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchQueryIsDirty</span> = <span class="hljs-literal">false</span><br> }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">1000</span>)<br> }, <span class="hljs-number">500</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Another advantage of this approach is there will be times when debouncing isn’t quite the right wrapper function. For
    example, when hitting an API for search suggestions, waiting to offer suggestions until after the user has stopped
    typing for a period of time isn’t an ideal experience. What you probably want instead is a
    <strong>throttling</strong> function. Now since you’re already using a utility library like lodash, refactoring to
    use its <code>throttle</code> function instead takes only a few seconds.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>debounce</code> attribute.</p>
</div>
<h3 id="lazy-or-number-Param-Attributes-for-v-model-replaced"><a
        href="#lazy-or-number-Param-Attributes-for-v-model-replaced" class="headerlink"
        title="lazy or number Param Attributes for v-model replaced" data-scroll=""><code>lazy</code> or
        <code>number</code> Param Attributes for <code>v-model</code> <sup>replaced</sup></a></h3>
<p>The <code>lazy</code> and <code>number</code> param attributes are now modifiers, to make it more clear what That
    means instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">lazy</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">number</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You would use:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"name"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the these param attributes.</p>
</div>
<h3 id="value-Attribute-with-v-model-removed"><a href="#value-Attribute-with-v-model-removed" class="headerlink"
        title="value Attribute with v-model removed" data-scroll=""><code>value</code> Attribute with
        <code>v-model</code> <sup>removed</sup></a></h3>
<p><code>v-model</code> no longer cares about the initial value of an inline <code>value</code> attribute. For
    predictability, it will instead always treat the Vue instance data as the source of truth.</p>
<p>That means this element:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"foo"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>backed by this data:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: {<br> <span class="hljs-attr">text</span>: <span class="hljs-string">'bar'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>will render with a value of “bar” instead of “foo”. The same goes for a <code>&lt;textarea&gt;</code> with existing
    content. Instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"text"</span>&gt;</span><br> hello world<br><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You should ensure your initial value for <code>text</code> is “hello world”.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite or app after upgrading and look for <strong>console warnings</strong> about inline
        value attributes with <code>v-model</code>.</p>
</div>
<h3 id="v-model-with-v-for-Iterated-Primitive-Values-removed"><a
        href="#v-model-with-v-for-Iterated-Primitive-Values-removed" class="headerlink"
        title="v-model with v-for Iterated Primitive Values removed" data-scroll=""><code>v-model</code> with
        <code>v-for</code> Iterated Primitive Values <sup>removed</sup></a></h3>
<p>Cases like this no longer work:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"str in strings"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"str"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The reason is this is the equivalent JavaScript that the <code>&lt;input&gt;</code> would compile to:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">strings.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">'input'</span>, ...)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>As you can see, <code>v-model</code>‘s two-way binding doesn’t make sense here. Setting <code>str</code> to another
    value in the iterator function will do nothing because it’s only a local variable in the function scope.</p>
<p>Instead, you should use an array of <strong>objects</strong> so that <code>v-model</code> can update the field on the
    object. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"obj in objects"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"obj.str"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your test suite, if you have one. The <strong>failed tests</strong> should alert to you to any parts of your
        app that may be affected by this change.</p>
</div>
<h3 id="v-bind-style-with-Object-Syntax-and-important-removed"><a
        href="#v-bind-style-with-Object-Syntax-and-important-removed" class="headerlink"
        title="v-bind:style with Object Syntax and !important removed" data-scroll=""><code>v-bind:style</code> with
        Object Syntax and <code>!important</code> <sup>removed</sup></a></h3>
<p>This will no longer work:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"{ color: myColor + ' !important' }"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you really need to override another <code>!important</code>, you must use the string syntax:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"'color: ' + myColor + ' !important'"</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of style bindings with <code>!important</code> in objects.</p>
</div>
<h3 id="v-el-and-v-ref-replaced"><a href="#v-el-and-v-ref-replaced" class="headerlink" title="v-el and v-ref replaced"
        data-scroll=""><code>v-el</code> and <code>v-ref</code> <sup>replaced</sup></a></h3>
<p>For simplicity, <code>v-el</code> and <code>v-ref</code> have been merged into the <code>ref</code> attribute,
    accessible on a component instance via <code>$refs</code>. That means <code>v-el:my-element</code> would become
    <code>ref="myElement"</code> and <code>v-ref:my-component</code> would become <code>ref="myComponent"</code>. When
    used on a normal element, the <code>ref</code> will be the DOM element, and when used on a component, the
    <code>ref</code> will be the component instance.</p>
<p>Since <code>v-ref</code> is no longer a directive, but a special attribute, it can also be dynamically defined. This
    is especially useful in combination with <code>v-for</code>. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:ref</span>=<span class="hljs-string">"'item' + item.id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Previously, <code>v-el</code>/<code>v-ref</code> combined with <code>v-for</code> would produce an array of
    elements/components, because there was no way to give each item a unique name. You can still achieve this behavior
    by giving each item the same <code>ref</code>:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Unlike in 1.x, these <code>$refs</code> are not reactive, because they’re registered/updated during the render
    process itself. Making them reactive would require duplicate renders for every change.</p>
<p>On the other hand, <code>$refs</code> are designed primarily for programmatic access in JavaScript - it is not
    recommended to rely on them in templates, because that would mean referring to state that does not belong to the
    instance itself. This would violate Vue’s data-driven view model.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>v-el</code> and <code>v-ref</code>.</p>
</div>
<h3 id="v-else-with-v-show-removed"><a href="#v-else-with-v-show-removed" class="headerlink"
        title="v-else with v-show removed" data-scroll=""><code>v-else</code> with <code>v-show</code>
        <sup>removed</sup></a></h3>
<p><code>v-else</code> no longer works with <code>v-show</code>. Use <code>v-if</code> with a negation expression
    instead. For example, instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"foo"</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"bar"</span>&gt;</span>Not foo, but bar<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can use:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"foo"</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!foo &amp;&amp; bar"</span>&gt;</span>Not foo, but bar<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>v-else</code> with <code>v-show</code>.</p>
</div>
<h2 id="Custom-Directives-simplified"><a href="#Custom-Directives-simplified" class="headerlink"
        title="Custom Directives simplified" data-scroll="">Custom Directives <sup>simplified</sup></a></h2>
<p>Directives have a greatly reduced scope of responsibility: they are now only used for applying low-level direct DOM
    manipulations. In most cases, you should prefer using components as the main code-reuse abstraction.</p>
<p>Some of the most notable differences include:</p>
<ul>
    <li>Directives no longer have instances. This means there’s no more <code>this</code> inside directive hooks.
        Instead, they receive everything they might need as arguments. If you really must persist state across hooks,
        you can do so on <code>el</code>.</li>
    <li>Options such as <code>acceptStatement</code>, <code>deep</code>, <code>priority</code>, etc have all been
        removed. To replace <code>twoWay</code> directives, see <a href="#Two-Way-Filters-replaced">this example</a>.
    </li>
    <li>Some of the current hooks have different behavior and there are also a couple new hooks.</li>
</ul>
<p>Fortunately, since the new directives are much simpler, you can master them more easily. Read the new <a
        href="custom-directive.html">Custom Directives guide</a> to learn more.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of defined directives. The helper will flag all of them, as
        it's likely in most cases that you'll want to refactor to a component.</p>
</div>
<h3 id="Directive-literal-Modifier-removed"><a href="#Directive-literal-Modifier-removed" class="headerlink"
        title="Directive .literal Modifier removed" data-scroll="">Directive <code>.literal</code> Modifier
        <sup>removed</sup></a></h3>
<p>The <code>.literal</code> modifier has been removed, as the same can be easily achieved by providing a string literal
    as the value.</p>
<p>For example, you can update:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-my-directive.literal</span>=<span class="hljs-string">"foo bar baz"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-my-directive</span>=<span class="hljs-string">"'foo bar baz'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the `.literal` modifier on a directive.</p>
</div>
<h2 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions" data-scroll="">Transitions</a></h2>
<h3 id="transition-Attribute-replaced"><a href="#transition-Attribute-replaced" class="headerlink"
        title="transition Attribute replaced" data-scroll=""><code>transition</code> Attribute <sup>replaced</sup></a>
</h3>
<p>Vue’s transition system has changed quite drastically and now uses <code>&lt;transition&gt;</code> and
    <code>&lt;transition-group&gt;</code> wrapper elements, rather than the <code>transition</code> attribute. It’s
    recommended to read the new <a href="transitions.html">Transitions guide</a> to learn more.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>transition</code> attribute.</p>
</div>
<h3 id="Vue-transition-for-Reusable-Transitions-replaced"><a href="#Vue-transition-for-Reusable-Transitions-replaced"
        class="headerlink" title="Vue.transition for Reusable Transitions replaced"
        data-scroll=""><code>Vue.transition</code> for Reusable Transitions <sup>replaced</sup></a></h3>
<p>With the new transition system, you can now <a href="transitions.html#Reusable-Transitions">use components for
        reusable transitions</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.transition</code>.</p>
</div>
<h3 id="Transition-stagger-Attribute-removed"><a href="#Transition-stagger-Attribute-removed" class="headerlink"
        title="Transition stagger Attribute removed" data-scroll="">Transition <code>stagger</code> Attribute
        <sup>removed</sup></a></h3>
<p>If you need to stagger list transitions, you can control timing by setting and accessing a <code>data-index</code>
    (or similar attribute) on an element. See <a href="transitions.html#Staggering-List-Transitions">an example
        here</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>transition</code> attribute. During your update,
        you can transition (pun very much intended) to the new staggering strategy as well.</p>
</div>
<h2 id="Events"><a href="#Events" class="headerlink" title="Events" data-scroll="">Events</a></h2>
<h3 id="events-option-removed"><a href="#events-option-removed" class="headerlink" title="events option removed"
        data-scroll=""><code>events</code> option <sup>removed</sup></a></h3>
<p>The <code>events</code> option has been removed. Event handlers should now be registered in the <code>created</code>
    hook instead. Check out the <a href="#dispatch-and-broadcast-replaced"><code>$dispatch</code> and
        <code>$broadcast</code> migration guide</a> for a detailed example.</p>
<h3 id="Vue-directive-39-on-39-keyCodes-replaced"><a href="#Vue-directive-39-on-39-keyCodes-replaced" class="headerlink"
        title="Vue.directive('on').keyCodes replaced" data-scroll=""><code>Vue.directive('on').keyCodes</code>
        <sup>replaced</sup></a></h3>
<p>The new, more concise way to configure <code>keyCodes</code> is through <code>Vue.config.keyCodes</code>. For
    example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// enable v-on:keyup.f1</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">keyCodes</span>.<span class="hljs-property">f1</span> = <span class="hljs-number">112</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the the old <code>keyCode</code> configuration syntax.</p>
</div>
<h3 id="dispatch-and-broadcast-replaced"><a href="#dispatch-and-broadcast-replaced" class="headerlink"
        title="$dispatch and $broadcast replaced" data-scroll=""><code>$dispatch</code> and <code>$broadcast</code>
        <sup>replaced</sup></a></h3>
<p><code>$dispatch</code> and <code>$broadcast</code> have been removed in favor of more explicitly cross-component
    communication and more maintainable state management solutions, such as <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vuex">Vuex</a>.</p>
<p>The problem is event flows that depend on a component’s tree structure can be hard to reason about and are very
    brittle when the tree becomes large. They don’t scale well and only set you up for pain later.
    <code>$dispatch</code> and <code>$broadcast</code> also do not solve communication between sibling components.</p>
<p>One of the most common uses for these methods is to communicate between a parent and its direct children. In these
    cases, you can actually <a href="components.html#Form-Input-Components-using-Custom-Events">listen to an
        <code>$emit</code> from a child with <code>v-on</code></a>. This allows you to keep the convenience of events
    with added explicitness.</p>
<p>However, when communicating between distant descendants/ancestors, <code>$emit</code> won’t help you. Instead, the
    simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to
    communicate between components no matter where they are in the component tree - even between siblings! Because Vue
    instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</p>
<p>For example, let’s say we have a todo app structured like this:</p>
<figure class="highlight plaintext">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs plaintext">Todos<br>├─ NewTodoInput<br>└─ Todo<br> └─ DeleteTodoButton<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>We could manage communication between components with this single event hub:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// This is the event hub we'll use in every</span><br><span class="hljs-comment">// component to communicate between them.</span><br><span class="hljs-keyword">var</span> eventHub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then in our components, we can use <code>$emit</code>, <code>$on</code>, <code>$off</code> to emit events, listen for
    events, and clean up event listeners, respectively:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// NewTodoInput</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">addTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> eventHub.$emit(<span class="hljs-string">'add-todo'</span>, { <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span> })<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTodoText</span> = <span class="hljs-string">''</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// DeleteTodoButton</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">deleteTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) {<br> eventHub.$emit(<span class="hljs-string">'delete-todo'</span>, id)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Todos</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> eventHub.$on(<span class="hljs-string">'add-todo'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodo</span>)<br> eventHub.$on(<span class="hljs-string">'delete-todo'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span>)<br>},<br><span class="hljs-comment">// It's good to clean up event listeners before</span><br><span class="hljs-comment">// a component is destroyed.</span><br><span class="hljs-attr">beforeDestroy</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> eventHub.$off(<span class="hljs-string">'add-todo'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTodo</span>)<br> eventHub.$off(<span class="hljs-string">'delete-todo'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">deleteTodo</span>)<br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">addTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newTodo</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(newTodo)<br> },<br> <span class="hljs-attr">deleteTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">todoId</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">todo</span>) {<br> <span class="hljs-keyword">return</span> todo.<span class="hljs-property">id</span> !== todoId<br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This pattern can serve as a replacement for <code>$dispatch</code> and <code>$broadcast</code> in simple scenarios,
    but for more complex cases, it’s recommended to use a dedicated state management layer such as <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vuex">Vuex</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>$dispatch</code> and <code>$broadcast</code>.</p>
</div>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters" data-scroll="">Filters</a></h2>
<h3 id="Filters-Outside-Text-Interpolations-removed"><a href="#Filters-Outside-Text-Interpolations-removed"
        class="headerlink" title="Filters Outside Text Interpolations removed" data-scroll="">Filters Outside Text
        Interpolations <sup>removed</sup></a></h3>
<p>Filters can now only be used inside text interpolations (<code>{{ }}</code> tags). In the past we’ve found using
    filters within directives such as <code>v-model</code>, <code>v-on</code>, etc led to more complexity than
    convenience. For list filtering on <code>v-for</code>, it’s also better to move that logic into JavaScript as
    computed properties, so that it can be reused throughout your component.</p>
<p>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax
    like filters to take care of the same concern. Here’s how you can replace Vue’s built-in directive filters:</p>
<h4 id="Replacing-the-debounce-Filter"><a href="#Replacing-the-debounce-Filter" class="headerlink"
        title="Replacing the debounce Filter"></a>Replacing the <code>debounce</code> Filter</h4>
<p>Instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup</span>=<span class="hljs-string">"doStuff | debounce 500"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">doStuff</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// ...</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Use <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.15.0#debounce">lodash’s
        <code>debounce</code></a> (or possibly <a target="_blank" rel="noopener"
        href="https://lodash.com/docs/4.15.0#throttle"><code>throttle</code></a>) to directly limit calling the
    expensive method. You can achieve the same as above like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup</span>=<span class="hljs-string">"doStuff"</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">doStuff</span>: _.<span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// ...</span><br> }, <span class="hljs-number">500</span>)<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For more on the advantages of this strategy, see <a href="#debounce-Param-Attribute-for-v-model-removed">the example
        here with <code>v-model</code></a>.</p>
<h4 id="Replacing-the-limitBy-Filter"><a href="#Replacing-the-limitBy-Filter" class="headerlink"
        title="Replacing the limitBy Filter"></a>Replacing the <code>limitBy</code> Filter</h4>
<p>Instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items | limitBy 10"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Use JavaScript’s built-in <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples"><code>.slice</code>
        method</a> in a computed property:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in filteredItems"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">filteredItems</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-filterBy-Filter"><a href="#Replacing-the-filterBy-Filter" class="headerlink"
        title="Replacing the filterBy Filter"></a>Replacing the <code>filterBy</code> Filter</h4>
<p>Instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in users | filterBy searchQuery in 'name'"</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Use JavaScript’s built-in <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples"><code>.filter</code>
        method</a> in a computed property:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in filteredUsers"</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">filteredUsers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br> <span class="hljs-keyword">return</span> self.<span class="hljs-property">users</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) {<br> <span class="hljs-keyword">return</span> user.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(self.<span class="hljs-property">searchQuery</span>) !== -<span class="hljs-number">1</span><br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>JavaScript’s native <code>.filter</code> can also manage much more complex filtering operations, because you have
    access to the full power of JavaScript within computed properties. For example, if you wanted to find all active
    users and case-insensitively match against both their name and email:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br>self.<span class="hljs-property">users</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) {<br> <span class="hljs-keyword">var</span> searchRegex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(self.<span class="hljs-property">searchQuery</span>, <span class="hljs-string">'i'</span>)<br> <span class="hljs-keyword">return</span> user.<span class="hljs-property">isActive</span> &amp;&amp; (<br> searchRegex.<span class="hljs-title function_">test</span>(user.<span class="hljs-property">name</span>) ||<br> searchRegex.<span class="hljs-title function_">test</span>(user.<span class="hljs-property">email</span>)<br> )<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-orderBy-Filter"><a href="#Replacing-the-orderBy-Filter" class="headerlink"
        title="Replacing the orderBy Filter"></a>Replacing the <code>orderBy</code> Filter</h4>
<p>Instead of:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in users | orderBy 'name'"</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Use <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.15.0#orderBy">lodash’s <code>orderBy</code></a>
    (or possibly <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.15.0#sortBy"><code>sortBy</code></a>)
    in a computed property:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in orderedUsers"</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">orderedUsers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> _.<span class="hljs-title function_">orderBy</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>, <span class="hljs-string">'name'</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can even order by multiple columns:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">_.<span class="hljs-title function_">orderBy</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'last_login'</span>], [<span class="hljs-string">'asc'</span>, <span class="hljs-string">'desc'</span>])<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of filters being used inside directives. If you miss any, you
        should also see <strong>console errors</strong>.</p>
</div>
<h3 id="Filter-Argument-Syntax-changed"><a href="#Filter-Argument-Syntax-changed" class="headerlink"
        title="Filter Argument Syntax changed" data-scroll="">Filter Argument Syntax <sup>changed</sup></a></h3>
<p>Filters’ syntax for arguments now better aligns with JavaScript function invocation. So instead of taking
    space-delimited arguments:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ date | formatDate 'YY-MM-DD' timeZone }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>We surround the arguments with parentheses and delimit the arguments with commas:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ date | formatDate('YY-MM-DD', timeZone) }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the old filter syntax. If you miss any, you should also see
        <strong>console errors</strong>.</p>
</div>
<h3 id="Built-In-Text-Filters-removed"><a href="#Built-In-Text-Filters-removed" class="headerlink"
        title="Built-In Text Filters removed" data-scroll="">Built-In Text Filters <sup>removed</sup></a></h3>
<p>Although filters within text interpolations are still allowed, all of the filters have been removed. Instead, it’s
    recommended to use more specialized libraries for solving problems in each domain (e.g. <a target="_blank"
        rel="noopener" href="https://date-fns.org/"><code>date-fns</code></a> to format dates and <a target="_blank"
        rel="noopener" href="http://openexchangerates.github.io/accounting.js/"><code>accounting</code></a> for
    currencies).</p>
<p>For each of Vue’s built-in text filters, we go through how you can replace them below. The example code could exist
    in custom helper functions, methods, or computed properties.</p>
<h4 id="Replacing-the-json-Filter"><a href="#Replacing-the-json-Filter" class="headerlink"
        title="Replacing the json Filter"></a>Replacing the <code>json</code> Filter</h4>
<p>You actually don’t need to for debugging anymore, as Vue will nicely format output for you automatically, whether
    it’s a string, number, array, or plain object. If you want the exact same functionality as JavaScript’s
    <code>JSON.stringify</code> though, then you can use that in a method or computed property.</p>
<h4 id="Replacing-the-capitalize-Filter"><a href="#Replacing-the-capitalize-Filter" class="headerlink"
        title="Replacing the capitalize Filter"></a>Replacing the <code>capitalize</code> Filter</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">text[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + text.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-uppercase-Filter"><a href="#Replacing-the-uppercase-Filter" class="headerlink"
        title="Replacing the uppercase Filter"></a>Replacing the <code>uppercase</code> Filter</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">text.<span class="hljs-title function_">toUpperCase</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-lowercase-Filter"><a href="#Replacing-the-lowercase-Filter" class="headerlink"
        title="Replacing the lowercase Filter"></a>Replacing the <code>lowercase</code> Filter</h4>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">text.<span class="hljs-title function_">toLowerCase</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-pluralize-Filter"><a href="#Replacing-the-pluralize-Filter" class="headerlink"
        title="Replacing the pluralize Filter"></a>Replacing the <code>pluralize</code> Filter</h4>
<p>The <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/pluralize">pluralize</a> package on NPM
    serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for
    cases like <code>0</code>, then you can also easily define your own pluralize functions. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pluralizeKnife</span> (count) {<br> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'no knives'</span><br> } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'1 knife'</span><br> } <span class="hljs-keyword">else</span> {<br> <span class="hljs-keyword">return</span> count + <span class="hljs-string">'knives'</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h4 id="Replacing-the-currency-Filter"><a href="#Replacing-the-currency-Filter" class="headerlink"
        title="Replacing the currency Filter"></a>Replacing the <code>currency</code> Filter</h4>
<p>For a very naive implementation, you could do something like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-string">'$'</span> + price.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>In many cases though, you’ll still run into strange behavior (e.g. <code>0.035.toFixed(2)</code> rounds up to
    <code>0.04</code>, but <code>0.045</code> rounds down to <code>0.04</code>). To work around these issues, you can
    use the <a target="_blank" rel="noopener"
        href="http://openexchangerates.github.io/accounting.js/"><code>accounting</code></a> library to more reliably
    format currencies.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete text filters. If you miss any, you should also
        see <strong>console errors</strong>.</p>
</div>
<h3 id="Two-Way-Filters-replaced"><a href="#Two-Way-Filters-replaced" class="headerlink"
        title="Two-Way Filters replaced" data-scroll="">Two-Way Filters <sup>replaced</sup></a></h3>
<p>Some users have enjoyed using two-way filters with <code>v-model</code> to create interesting inputs with very little
    code. While <em>seemingly</em> simple however, two-way filters can also hide a great deal of complexity - and even
    encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more
    explicit and feature-rich way of creating custom inputs.</p>
<p>As an example, we’ll now walk the migration of a two-way currency filter:</p> <iframe
    src="https://codesandbox.io/embed/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light"
    style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation"
    allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
<p>It mostly works well, but the delayed state updates can cause strange behavior. For example, try entering
    <code>9.999</code> into one of those inputs. When the input loses focus, its value will update to
    <code>$10.00</code>. When looking at the calculated total however, you’ll see that <code>9.999</code> is what’s
    stored in our data. The version of reality that the user sees is out of sync!</p>
<p>To start transitioning towards a more robust solution using Vue 2.0, let’s first wrap this filter in a new
    <code>&lt;currency-input&gt;</code> component:</p> <iframe
    src="https://codesandbox.io/embed/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter-v2?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light"
    style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation"
    allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
<p>This allows us add behavior that a filter alone couldn’t encapsulate, such as selecting the content of an input on
    focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into
    an external <a target="_blank" rel="noopener"
        href="https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e"><code>currencyValidator</code>
        object</a>:</p> <iframe
    src="https://codesandbox.io/embed/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter-v3?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light"
    style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation"
    allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
<p>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and
    formatting to be:</p>
<ul>
    <li>unit tested in isolation from your Vue code</li>
    <li>used by other parts of your application, such as to validate the payload to an API endpoint</li>
</ul>
<p>Having this validator extracted out, we’ve also more comfortably built it up into a more robust solution. The state
    quirks have been eliminated and it’s actually impossible for users to enter anything wrong, similar to what the
    browser’s native number input tries to do.</p>
<p>We’re still limited however, by filters and by Vue 1.0 in general, so let’s complete the upgrade to Vue 2.0:</p>
<iframe
    src="https://codesandbox.io/embed/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-two-way-currency-filter?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light"
    style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation"
    allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
<p>You may notice that:</p>
<ul>
    <li>Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior
        of two-way filters.</li>
    <li>We can now use <code>v-model</code> directly on our custom inputs, which is not only more consistent with normal
        inputs, but also means our component is Vuex-friendly.</li>
    <li>Since we’re no longer using filter options that require a value to be returned, our currency work could actually
        be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily
        refactor this logic into a shared microservice.</li>
</ul>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of filters used in directives like <code>v-model</code>. If you
        miss any, you should also see <strong>console errors</strong>.</p>
</div>
<h2 id="Slots"><a href="#Slots" class="headerlink" title="Slots" data-scroll="">Slots</a></h2>
<h3 id="Duplicate-Slots-removed"><a href="#Duplicate-Slots-removed" class="headerlink" title="Duplicate Slots removed"
        data-scroll="">Duplicate Slots <sup>removed</sup></a></h3>
<p>It is no longer supported to have <code>&lt;slot&gt;</code>s with the same name in the same template. When a slot is
    rendered it is “used up” and cannot be rendered elsewhere in the same render tree. If you must render the same
    content in multiple places, pass that content as a prop.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite or app after upgrading and look for <strong>console warnings</strong> about
        duplicate slots <code>v-model</code>.</p>
</div>
<h3 id="slot-Attribute-Styling-removed"><a href="#slot-Attribute-Styling-removed" class="headerlink"
        title="slot Attribute Styling removed" data-scroll=""><code>slot</code> Attribute Styling <sup>removed</sup></a>
</h3>
<p>Content inserted via named <code>&lt;slot&gt;</code> no longer preserves the <code>slot</code> attribute. Use a
    wrapper element to style them, or for advanced use cases, modify the inserted content programmatically using <a
        href="render-function.html">render functions</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find CSS selectors targeting named slots (e.g.
        <code>[slot="my-slot-name"]</code>).</p>
</div>
<h2 id="Special-Attributes"><a href="#Special-Attributes" class="headerlink" title="Special Attributes"
        data-scroll="">Special Attributes</a></h2>
<h3 id="keep-alive-Attribute-replaced"><a href="#keep-alive-Attribute-replaced" class="headerlink"
        title="keep-alive Attribute replaced" data-scroll=""><code>keep-alive</code> Attribute <sup>replaced</sup></a>
</h3>
<p><code>keep-alive</code> is no longer a special attribute, but rather a wrapper component, similar to
    <code>&lt;transition&gt;</code>. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This makes it possible to use <code>&lt;keep-alive&gt;</code> on multiple conditional children:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todos.length &gt; 0"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-list</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">no-todos-gif</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">no-todos-gif</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p class="tip">When <code>&lt;keep-alive&gt;</code> has multiple children, they should eventually evaluate to a single
    child. Any child other than the first one will be ignored.</p>
<p>When used together with <code>&lt;transition&gt;</code>, make sure to nest it inside:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">"view"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find <code>keep-alive</code> attributes.</p>
</div>
<h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"
        data-scroll="">Interpolation</a></h2>
<h3 id="Interpolation-within-Attributes-removed"><a href="#Interpolation-within-Attributes-removed" class="headerlink"
        title="Interpolation within Attributes removed" data-scroll="">Interpolation within Attributes
        <sup>removed</sup></a></h3>
<p>Interpolation within attributes is no longer valid. For example:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-{{ size }}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Should either be updated to use an inline expression:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"'btn btn-' + size"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or a data/computed property:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">"buttonClasses"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">computed</span>: {<br> <span class="hljs-attr">buttonClasses</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> <span class="hljs-string">'btn btn-'</span> + size<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of interpolation used within attributes.</p>
</div>
<h3 id="HTML-Interpolation-removed"><a href="#HTML-Interpolation-removed" class="headerlink"
        title="HTML Interpolation removed" data-scroll="">HTML Interpolation <sup>removed</sup></a></h3>
<p>HTML interpolations (<code>{{{ foo }}}</code>) have been removed in favor of the <a
        href="../api/#v-html"><code>v-html</code> directive</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find HTML interpolations.</p>
</div>
<h3 id="One-Time-Bindings-replaced"><a href="#One-Time-Bindings-replaced" class="headerlink"
        title="One-Time Bindings replaced" data-scroll="">One-Time Bindings <sup>replaced</sup></a></h3>
<p>One time bindings (<code>{{* foo }}</code>) have been replaced by the new <a
        href="../api/#v-once"><code>v-once</code> directive</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find one-time bindings.</p>
</div>
<h2 id="Reactivity"><a href="#Reactivity" class="headerlink" title="Reactivity" data-scroll="">Reactivity</a></h2>
<h3 id="vm-watch-changed"><a href="#vm-watch-changed" class="headerlink" title="vm.$watch changed"
        data-scroll=""><code>vm.$watch</code> <sup>changed</sup></a></h3>
<p>Watchers created via <code>vm.$watch</code> are now fired before the associated component rerenders. This gives you
    the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example,
    you can watch a component prop and update the component’s own data when the prop changes.</p>
<p>If you were previously relying on <code>vm.$watch</code> to do something with the DOM after a component updates, you
    can instead do so in the <code>updated</code> lifecycle hook.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite, if you have one. The <strong>failed tests</strong> should alert to you to the
        fact that a watcher was relying on the old behavior.</p>
</div>
<h3 id="vm-set-changed"><a href="#vm-set-changed" class="headerlink" title="vm.$set changed"
        data-scroll=""><code>vm.$set</code> <sup>changed</sup></a></h3>
<p><code>vm.$set</code> is now an alias for <a href="../api/#Vue-set"><code>Vue.set</code></a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete usage.</p>
</div>
<h3 id="vm-delete-changed"><a href="#vm-delete-changed" class="headerlink" title="vm.$delete changed"
        data-scroll=""><code>vm.$delete</code> <sup>changed</sup></a></h3>
<p><code>vm.$delete</code> is now an alias for <a href="../api/#Vue-delete"><code>Vue.delete</code></a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete usage.</p>
</div>
<h3 id="Array-prototype-set-removed"><a href="#Array-prototype-set-removed" class="headerlink"
        title="Array.prototype.$set removed" data-scroll=""><code>Array.prototype.$set</code> <sup>removed</sup></a>
</h3>
<p>Use <code>Vue.set</code> instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>.$set</code> on an array. If you miss any, you should
        see <strong>console errors</strong> from the missing method.</p>
</div>
<h3 id="Array-prototype-remove-removed"><a href="#Array-prototype-remove-removed" class="headerlink"
        title="Array.prototype.$remove removed" data-scroll=""><code>Array.prototype.$remove</code>
        <sup>removed</sup></a></h3>
<p>Use <code>Array.prototype.splice</code> instead. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">removeTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">todo</span>) {<br> <span class="hljs-keyword">var</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">indexOf</span>(todo)<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or better yet, pass removal methods an index:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">removeTodo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) {<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>.$remove</code> on an array. If you miss any, you
        should see <strong>console errors</strong> from the missing method.</p>
</div>
<h3 id="Vue-set-and-Vue-delete-on-Vue-instances-removed"><a href="#Vue-set-and-Vue-delete-on-Vue-instances-removed"
        class="headerlink" title="Vue.set and Vue.delete on Vue instances removed" data-scroll=""><code>Vue.set</code>
        and <code>Vue.delete</code> on Vue instances <sup>removed</sup></a></h3>
<p><code>Vue.set</code> and <code>Vue.delete</code> can no longer work on Vue instances. It is now mandatory to properly
    declare all top-level reactive properties in the data option. If you’d like to delete properties on a Vue instance
    or its <code>$data</code>, set it to null.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.set</code> or <code>Vue.delete</code> on a Vue
        instance. If you miss any, they'll trigger <strong>console warnings</strong>.</p>
</div>
<h3 id="Replacing-vm-data-removed"><a href="#Replacing-vm-data-removed" class="headerlink"
        title="Replacing vm.$data removed" data-scroll="">Replacing <code>vm.$data</code> <sup>removed</sup></a></h3>
<p>It is now prohibited to replace a component instance’s root $data. This prevents some edge cases in the reactivity
    system and makes the component state more predictable (especially with type-checking systems).</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of overwriting <code>vm.$data</code>. If you miss any,
        <strong>console warnings</strong> will be emitted.</p>
</div>
<h3 id="vm-get-removed"><a href="#vm-get-removed" class="headerlink" title="vm.$get removed"
        data-scroll=""><code>vm.$get</code> <sup>removed</sup></a></h3>
<p>Instead, retrieve reactive data directly.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$get</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h2 id="DOM-Focused-Instance-Methods"><a href="#DOM-Focused-Instance-Methods" class="headerlink"
        title="DOM-Focused Instance Methods" data-scroll="">DOM-Focused Instance Methods</a></h2>
<h3 id="vm-appendTo-removed"><a href="#vm-appendTo-removed" class="headerlink" title="vm.$appendTo removed"
        data-scroll=""><code>vm.$appendTo</code> <sup>removed</sup></a></h3>
<p>Use the native DOM API:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">myElement.<span class="hljs-title function_">appendChild</span>(vm.<span class="hljs-property">$el</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$appendTo</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h3 id="vm-before-removed"><a href="#vm-before-removed" class="headerlink" title="vm.$before removed"
        data-scroll=""><code>vm.$before</code> <sup>removed</sup></a></h3>
<p>Use the native DOM API:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">myElement.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(vm.<span class="hljs-property">$el</span>, myElement)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$before</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h3 id="vm-after-removed"><a href="#vm-after-removed" class="headerlink" title="vm.$after removed"
        data-scroll=""><code>vm.$after</code> <sup>removed</sup></a></h3>
<p>Use the native DOM API:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">myElement.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(vm.<span class="hljs-property">$el</span>, myElement.<span class="hljs-property">nextSibling</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or if <code>myElement</code> is the last child:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">myElement.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">appendChild</span>(vm.<span class="hljs-property">$el</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$after</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h3 id="vm-remove-removed"><a href="#vm-remove-removed" class="headerlink" title="vm.$remove removed"
        data-scroll=""><code>vm.$remove</code> <sup>removed</sup></a></h3>
<p>Use the native DOM API:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">vm.<span class="hljs-property">$el</span>.<span class="hljs-title function_">remove</span>()<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$remove</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h2 id="Meta-Instance-Methods"><a href="#Meta-Instance-Methods" class="headerlink" title="Meta Instance Methods"
        data-scroll="">Meta Instance Methods</a></h2>
<h3 id="vm-eval-removed"><a href="#vm-eval-removed" class="headerlink" title="vm.$eval removed"
        data-scroll=""><code>vm.$eval</code> <sup>removed</sup></a></h3>
<p>No real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on <a
        target="_blank" rel="noopener" href="https://forum.vuejs.org/">the forum</a> for ideas.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$eval</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h3 id="vm-interpolate-removed"><a href="#vm-interpolate-removed" class="headerlink" title="vm.$interpolate removed"
        data-scroll=""><code>vm.$interpolate</code> <sup>removed</sup></a></h3>
<p>No real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on <a
        target="_blank" rel="noopener" href="https://forum.vuejs.org/">the forum</a> for ideas.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$interpolate</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h3 id="vm-log-removed"><a href="#vm-log-removed" class="headerlink" title="vm.$log removed"
        data-scroll=""><code>vm.$log</code> <sup>removed</sup></a></h3>
<p>Use the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">Vue Devtools</a> for the
    optimal debugging experience.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>vm.$log</code>. If you miss any, you'll see
        <strong>console errors</strong>.</p>
</div>
<h2 id="Instance-DOM-Options"><a href="#Instance-DOM-Options" class="headerlink" title="Instance DOM Options"
        data-scroll="">Instance DOM Options</a></h2>
<h3 id="replace-false-removed"><a href="#replace-false-removed" class="headerlink" title="replace: false removed"
        data-scroll=""><code>replace: false</code> <sup>removed</sup></a></h3>
<p>Components now always replace the element they’re bound to. To simulate the behavior of <code>replace: false</code>,
    you can wrap your root component with an element similar to the one you’re replacing. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div id="app"&gt; ... &lt;/div&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or with a render function:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">h</span>) {<br> <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, {<br> <span class="hljs-attr">attrs</span>: {<br> <span class="hljs-attr">id</span>: <span class="hljs-string">'app'</span>,<br> }<br> }, <span class="hljs-comment">/* ... */</span>)<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>replace: false</code>.</p>
</div>
<h2 id="Global-Config"><a href="#Global-Config" class="headerlink" title="Global Config" data-scroll="">Global
        Config</a></h2>
<h3 id="Vue-config-debug-removed"><a href="#Vue-config-debug-removed" class="headerlink"
        title="Vue.config.debug removed" data-scroll=""><code>Vue.config.debug</code> <sup>removed</sup></a></h3>
<p>No longer necessary, since warnings come with stack traces by default now.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.config.debug</code>.</p>
</div>
<h3 id="Vue-config-async-removed"><a href="#Vue-config-async-removed" class="headerlink"
        title="Vue.config.async removed" data-scroll=""><code>Vue.config.async</code> <sup>removed</sup></a></h3>
<p>Async is now required for rendering performance.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.config.async</code>.</p>
</div>
<h3 id="Vue-config-delimiters-replaced"><a href="#Vue-config-delimiters-replaced" class="headerlink"
        title="Vue.config.delimiters replaced" data-scroll=""><code>Vue.config.delimiters</code> <sup>replaced</sup></a>
</h3>
<p>This has been reworked as a <a href="../api/#delimiters">component-level option</a>. This allows you to use
    alternative delimiters within your app without breaking 3rd-party components.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.config.delimiters</code>.</p>
</div>
<h3 id="Vue-config-unsafeDelimiters-removed"><a href="#Vue-config-unsafeDelimiters-removed" class="headerlink"
        title="Vue.config.unsafeDelimiters removed" data-scroll=""><code>Vue.config.unsafeDelimiters</code>
        <sup>removed</sup></a></h3>
<p>HTML interpolation has been <a href="#HTML-Interpolation-removed">removed in favor of <code>v-html</code></a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.config.unsafeDelimiters</code>. After this, the
        helper will also find instances of HTML interpolation so that you can replace them with `v-html`.</p>
</div>
<h2 id="Global-API"><a href="#Global-API" class="headerlink" title="Global API" data-scroll="">Global API</a></h2>
<h3 id="Vue-extend-with-el-removed"><a href="#Vue-extend-with-el-removed" class="headerlink"
        title="Vue.extend with el removed" data-scroll=""><code>Vue.extend</code> with <code>el</code>
        <sup>removed</sup></a></h3>
<p>The el option can no longer be used in <code>Vue.extend</code>. It’s only valid as an instance creation option.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run your end-to-end test suite or app after upgrading and look for <strong>console warnings</strong> about the
        <code>el</code> option with <code>Vue.extend</code>.</p>
</div>
<h3 id="Vue-elementDirective-removed"><a href="#Vue-elementDirective-removed" class="headerlink"
        title="Vue.elementDirective removed" data-scroll=""><code>Vue.elementDirective</code> <sup>removed</sup></a>
</h3>
<p>Use components instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.elementDirective</code>.</p>
</div>
<h3 id="Vue-partial-removed"><a href="#Vue-partial-removed" class="headerlink" title="Vue.partial removed"
        data-scroll=""><code>Vue.partial</code> <sup>removed</sup></a></h3>
<p>Partials have been removed in favor of more explicit data flow between components, using props. Unless you’re using a
    partial in a performance-critical area, the recommendation is to use a <a href="components.html">normal
        component</a> instead. If you were dynamically binding the <code>name</code> of a partial, you can use a <a
        href="components.html#Dynamic-Components">dynamic component</a>.</p>
<p>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to <a
        href="render-function.html#Functional-Components">functional components</a>. They must be in a plain JS/JSX file
    (rather than in a <code>.vue</code> file) and are stateless and instanceless, like partials. This makes rendering
    extremely fast.</p>
<p>A benefit of functional components over partials is that they can be much more dynamic, because they grant you access
    to the full power of JavaScript. There is a cost to this power however. If you’ve never used a component framework
    with render functions before, they may take a bit longer to learn.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>Vue.partial</code>.</p>
</div>
<div class="guide-links"> <span>← <a href="/v2/guide/reactivity.html">Reactivity in Depth</a></span> <span
        style="float: right"><a href="/v2/guide/migration-vue-router.html">Migration from Vue Router 0.7.x</a> →</span>
</div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Migration from Vue Router 0.7.x</h1>
<blockquote>
    <p>Only Vue Router 2 is compatible with Vue 2, so if you’re updating Vue, you’ll have to update Vue Router as well.
        That’s why we’ve included details on the migration path here in the main docs. For a complete guide on using the
        new Vue Router, see the <a target="_blank" rel="noopener" href="https://router.vuejs.org/en/">Vue Router
            docs</a>.</p>
</blockquote>
<h2 id="Router-Initialization"><a href="#Router-Initialization" class="headerlink" title="Router Initialization"
        data-scroll="">Router Initialization</a></h2>
<h3 id="router-start-replaced"><a href="#router-start-replaced" class="headerlink" title="router.start replaced"
        data-scroll=""><code>router.start</code> <sup>replaced</sup></a></h3>
<p>There is no longer a special API to initialize an app with Vue Router. That means instead of:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">start</span>({<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;router-view&gt;&lt;/router-view&gt;'</span><br>}, <span class="hljs-string">'#app'</span>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You pass a router property to a Vue instance:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">router</span>: router,<br> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;router-view&gt;&lt;/router-view&gt;'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Or, if you’re using the runtime-only build of Vue:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({<br> <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br> <span class="hljs-attr">router</span>: router,<br> <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">'router-view'</span>)<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.start</code> being called.</p>
</div>
<h2 id="Route-Definitions"><a href="#Route-Definitions" class="headerlink" title="Route Definitions"
        data-scroll="">Route Definitions</a></h2>
<h3 id="router-map-replaced"><a href="#router-map-replaced" class="headerlink" title="router.map replaced"
        data-scroll=""><code>router.map</code> <sup>replaced</sup></a></h3>
<p>Routes are now defined as an array on a <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/essentials/getting-started.html#javascript"><code>routes</code> option</a> at
    router instantiation. So these routes for example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">map</span>({<br> <span class="hljs-string">'/foo'</span>: {<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span><br> },<br> <span class="hljs-string">'/bar'</span>: {<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">Bar</span><br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Will instead be defined with:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({<br> <span class="hljs-attr">routes</span>: [<br> { <span class="hljs-attr">path</span>: <span class="hljs-string">'/foo'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span> },<br> { <span class="hljs-attr">path</span>: <span class="hljs-string">'/bar'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Bar</span> }<br> ]<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the
    same property order across browsers.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.map</code> being called.</p>
</div>
<h3 id="router-on-removed"><a href="#router-on-removed" class="headerlink" title="router.on removed"
        data-scroll=""><code>router.on</code> <sup>removed</sup></a></h3>
<p>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing
    definitions to a routes array. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-comment">// Normal base routes</span><br><span class="hljs-keyword">var</span> routes = [<br> <span class="hljs-comment">// ...</span><br>]<br><br><span class="hljs-comment">// Dynamically generated routes</span><br>marketingPages.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">page</span>) {<br> routes.<span class="hljs-title function_">push</span>({<br> <span class="hljs-attr">path</span>: <span class="hljs-string">'/marketing/'</span> + page.<span class="hljs-property">slug</span><br> <span class="hljs-attr">component</span>: {<br> <span class="hljs-attr">extends</span>: <span class="hljs-title class_">MarketingComponent</span><br> <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> { <span class="hljs-attr">page</span>: page }<br> }<br> }<br> })<br>})<br><br><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>({<br> <span class="hljs-attr">routes</span>: routes<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you need to add new routes after the router has been instantiated, you can replace the router’s matcher with a new
    one that includes the route you’d like to add:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-property">match</span> = <span class="hljs-title function_">createMatcher</span>(<br> [{<br> <span class="hljs-attr">path</span>: <span class="hljs-string">'/my/new/path'</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">MyComponent</span><br> }].<span class="hljs-title function_">concat</span>(router.<span class="hljs-property">options</span>.<span class="hljs-property">routes</span>)<br>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.on</code> being called.</p>
</div>
<h3 id="router-beforeEach-changed"><a href="#router-beforeEach-changed" class="headerlink"
        title="router.beforeEach changed" data-scroll=""><code>router.beforeEach</code> <sup>changed</sup></a></h3>
<p><code>router.beforeEach</code> now works asynchronously and takes a <code>next</code> function as its third argument.
</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">transition</span>) {<br> <span class="hljs-keyword">if</span> (transition.<span class="hljs-property">to</span>.<span class="hljs-property">path</span> === <span class="hljs-string">'/forbidden'</span>) {<br> transition.<span class="hljs-title function_">abort</span>()<br> } <span class="hljs-keyword">else</span> {<br> transition.<span class="hljs-title function_">next</span>()<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) {<br> <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">'/forbidden'</span>) {<br> <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>)<br> } <span class="hljs-keyword">else</span> {<br> <span class="hljs-title function_">next</span>()<br> }<br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="subRoutes-renamed"><a href="#subRoutes-renamed" class="headerlink" title="subRoutes renamed"
        data-scroll=""><code>subRoutes</code> <sup>renamed</sup></a></h3>
<p><a target="_blank" rel="noopener" href="https://router.vuejs.org/en/essentials/nested-routes.html">Renamed to
        <code>children</code></a> for consistency within Vue and with other routing libraries.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>subRoutes</code> option.</p>
</div>
<h3 id="router-redirect-replaced"><a href="#router-redirect-replaced" class="headerlink"
        title="router.redirect replaced" data-scroll=""><code>router.redirect</code> <sup>replaced</sup></a></h3>
<p>This is now an <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/essentials/redirect-and-alias.html">option on route definitions</a>. So for
    example, you will update:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">redirect</span>({<br> <span class="hljs-string">'/tos'</span>: <span class="hljs-string">'/terms-of-service'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to a definition like below in your <code>routes</code> configuration:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-attr">path</span>: <span class="hljs-string">'/tos'</span>,<br> <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/terms-of-service'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.redirect</code> being called.</p>
</div>
<h3 id="router-alias-replaced"><a href="#router-alias-replaced" class="headerlink" title="router.alias replaced"
        data-scroll=""><code>router.alias</code> <sup>replaced</sup></a></h3>
<p>This is now an <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/essentials/redirect-and-alias.html">option on the definition for the route</a>
    you’d like to alias to. So for example, you will update:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">router.<span class="hljs-title function_">alias</span>({<br> <span class="hljs-string">'/manage'</span>: <span class="hljs-string">'/admin'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to a definition like below in your <code>routes</code> configuration:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">AdminPanel</span>,<br> <span class="hljs-attr">alias</span>: <span class="hljs-string">'/manage'</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>If you need multiple aliases, you can also use an array syntax:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">alias</span>: [<span class="hljs-string">'/manage'</span>, <span class="hljs-string">'/administer'</span>, <span class="hljs-string">'/administrate'</span>]<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.alias</code> being called.</p>
</div>
<h3 id="Arbitrary-Route-Properties-replaced"><a href="#Arbitrary-Route-Properties-replaced" class="headerlink"
        title="Arbitrary Route Properties replaced" data-scroll="">Arbitrary Route Properties <sup>replaced</sup></a>
</h3>
<p>Arbitrary route properties must now be scoped under the new meta property, to avoid conflicts with future features.
    So for example, if you had defined:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-string">'/admin'</span>: {<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">AdminPanel</span>,<br> <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then you would now update it to:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">{<br> <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-title class_">AdminPanel</span>,<br> <span class="hljs-attr">meta</span>: {<br> <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then when later accessing this property on a route, you will still go through meta. For example:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">if</span> (route.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) {<br> <span class="hljs-comment">// ...</span><br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of arbitrary route properties not scoped under meta.</p>
</div>
<h3 id="Syntax-for-Arrays-in-Queries-removed"><a href="#Syntax-for-Arrays-in-Queries-removed" class="headerlink"
        title="[] Syntax for Arrays in Queries removed" data-scroll="">[] Syntax for Arrays in Queries
        <sup>removed</sup></a></h3>
<p>When passing arrays to query parameters the QueryString syntax is no longer
    <code>/foo?users[]=Tom&amp;users[]=Jerry</code>, instead, the new syntax is
    <code>/foo?users=Tom&amp;users=Jerry</code>. Internally, <code>$route.query.users</code> will still be an Array, but
    if there’s only one parameter in the query: <code>/foo?users=Tom</code>, when directly accessing this route, there’s
    no way for the router to know if we were expecting <code>users</code> to be an Array. Because of this, consider
    adding a computed property and replacing every reference of <code>$route.query.users</code> with it:</p>
<figure class="highlight javascript">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">computed</span>: {<br> <span class="hljs-comment">// users will always be an array</span><br> users () {<br> <span class="hljs-keyword">const</span> users = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>.<span class="hljs-property">users</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(users) ? users : [users]<br> }<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h2 id="Route-Matching"><a href="#Route-Matching" class="headerlink" title="Route Matching" data-scroll="">Route
        Matching</a></h2>
<p>Route matching now uses <a target="_blank" rel="noopener"
        href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a> under the hood, making it much more
    flexible than previously.</p>
<h3 id="One-or-More-Named-Parameters-changed"><a href="#One-or-More-Named-Parameters-changed" class="headerlink"
        title="One or More Named Parameters changed" data-scroll="">One or More Named Parameters <sup>changed</sup></a>
</h3>
<p>The syntax has changed slightly, so <code>/category/*tags</code> for example, should be updated to
    <code>/category/:tags+</code>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the obsolete route syntax.</p>
</div>
<h2 id="Links"><a href="#Links" class="headerlink" title="Links" data-scroll="">Links</a></h2>
<h3 id="v-link-replaced"><a href="#v-link-replaced" class="headerlink" title="v-link replaced"
        data-scroll=""><code>v-link</code> <sup>replaced</sup></a></h3>
<p>The <code>v-link</code> directive has been replaced with a new <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/api/router-link.html"><code>&lt;router-link&gt;</code> component</a>, as this
    sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link
    like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-link</span>=<span class="hljs-string">"'/about'"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You’ll need to update it like this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Note that <code>target="_blank"</code> is not supported on <code>&lt;router-link&gt;</code>, so if you need to open a
    link in a new tab, you have to use <code>&lt;a&gt;</code> instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>v-link</code> directive.</p>
</div>
<h3 id="v-link-active-replaced"><a href="#v-link-active-replaced" class="headerlink" title="v-link-active replaced"
        data-scroll=""><code>v-link-active</code> <sup>replaced</sup></a></h3>
<p>The <code>v-link-active</code> directive has also been replaced by the <code>tag</code> attribute on <a
        target="_blank" rel="noopener" href="https://router.vuejs.org/en/api/router-link.html">the
        <code>&lt;router-link&gt;</code> component</a>. So for example, you’ll update this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-link-active</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-link</span>=<span class="hljs-string">"'/about'"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to this:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">"li"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The <code>&lt;a&gt;</code> will be the actual link (and will get the correct href), but the active class will be
    applied to the outer <code>&lt;li&gt;</code>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>v-link-active</code> directive.</p>
</div>
<h2 id="Programmatic-Navigation"><a href="#Programmatic-Navigation" class="headerlink" title="Programmatic Navigation"
        data-scroll="">Programmatic Navigation</a></h2>
<h3 id="router-go-changed"><a href="#router-go-changed" class="headerlink" title="router.go changed"
        data-scroll=""><code>router.go</code> <sup>changed</sup></a></h3>
<p>For consistency with the <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">HTML5 History API</a>,
    <code>router.go</code> is now only used for <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/essentials/navigation.html#routergon">back/forward navigation</a>, while <a
        target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/essentials/navigation.html#routerpushlocation"><code>router.push</code></a> is
    used to navigate to a specific page.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>router.go</code> being used where
        <code>router.push</code> should be used instead.</p>
</div>
<h2 id="Router-Options-Modes"><a href="#Router-Options-Modes" class="headerlink" title="Router Options: Modes"
        data-scroll="">Router Options: Modes</a></h2>
<h3 id="hashbang-false-removed"><a href="#hashbang-false-removed" class="headerlink" title="hashbang: false removed"
        data-scroll=""><code>hashbang: false</code> <sup>removed</sup></a></h3>
<p>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for
    the hash strategy.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>hashbang: false</code> option.</p>
</div>
<h3 id="history-true-replaced"><a href="#history-true-replaced" class="headerlink" title="history: true replaced"
        data-scroll=""><code>history: true</code> <sup>replaced</sup></a></h3>
<p>All routing mode options have been condensed into a single <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/api/options.html#mode"><code>mode</code> option</a>. Update:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({<br> <span class="hljs-attr">history</span>: <span class="hljs-string">'true'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({<br> <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>history: true</code> option.</p>
</div>
<h3 id="abstract-true-replaced"><a href="#abstract-true-replaced" class="headerlink" title="abstract: true replaced"
        data-scroll=""><code>abstract: true</code> <sup>replaced</sup></a></h3>
<p>All routing mode options have been condensed into a single <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/api/options.html#mode"><code>mode</code> option</a>. Update:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({<br> <span class="hljs-attr">abstract</span>: <span class="hljs-string">'true'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>to:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({<br> <span class="hljs-attr">mode</span>: <span class="hljs-string">'abstract'</span><br>})<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>abstract: true</code> option.</p>
</div>
<h2 id="Route-Options-Misc"><a href="#Route-Options-Misc" class="headerlink" title="Route Options: Misc"
        data-scroll="">Route Options: Misc</a></h2>
<h3 id="saveScrollPosition-replaced"><a href="#saveScrollPosition-replaced" class="headerlink"
        title="saveScrollPosition replaced" data-scroll=""><code>saveScrollPosition</code> <sup>replaced</sup></a></h3>
<p>This has been replaced with a <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/advanced/scroll-behavior.html"><code>scrollBehavior</code> option</a> that
    accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new
    possibilities, but to replicate the old behavior of:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">saveScrollPosition</span>: <span class="hljs-literal">true</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>You can replace it with:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">scrollBehavior</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span>, savedPosition</span>) {<br> <span class="hljs-keyword">return</span> savedPosition || { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>saveScrollPosition: true</code> option.</p>
</div>
<h3 id="root-renamed"><a href="#root-renamed" class="headerlink" title="root renamed" data-scroll=""><code>root</code>
        <sup>renamed</sup></a></h3>
<p>Renamed to <code>base</code> for consistency with <a target="_blank" rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">the HTML <code>&lt;base&gt;</code>
        element</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>root</code> option.</p>
</div>
<h3 id="transitionOnLoad-removed"><a href="#transitionOnLoad-removed" class="headerlink"
        title="transitionOnLoad removed" data-scroll=""><code>transitionOnLoad</code> <sup>removed</sup></a></h3>
<p>This option is no longer necessary now that Vue’s transition system has explicit <a
        href="transitions.html#Transitions-on-Initial-Render"><code>appear</code> transition control</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>transitionOnLoad: true</code> option.</p>
</div>
<h3 id="suppressTransitionError-removed"><a href="#suppressTransitionError-removed" class="headerlink"
        title="suppressTransitionError removed" data-scroll=""><code>suppressTransitionError</code>
        <sup>removed</sup></a></h3>
<p>Removed due to hooks simplification. If you really must suppress transition errors, you can use <a target="_blank"
        rel="noopener"
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"><code>try</code>…<code>catch</code></a>
    instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>suppressTransitionError: true</code> option.</p>
</div>
<h2 id="Route-Hooks"><a href="#Route-Hooks" class="headerlink" title="Route Hooks" data-scroll="">Route Hooks</a></h2>
<h3 id="activate-replaced"><a href="#activate-replaced" class="headerlink" title="activate replaced"
        data-scroll=""><code>activate</code> <sup>replaced</sup></a></h3>
<p>Use <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards"><code>beforeRouteEnter</code></a>
    in the component instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>activate</code> hook.</p>
</div>
<h3 id="canActivate-replaced"><a href="#canActivate-replaced" class="headerlink" title="canActivate replaced"
        data-scroll=""><code>canActivate</code> <sup>replaced</sup></a></h3>
<p>Use <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard"><code>beforeEnter</code></a>
    in the route instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>canActivate</code> hook.</p>
</div>
<h3 id="deactivate-removed"><a href="#deactivate-removed" class="headerlink" title="deactivate removed"
        data-scroll=""><code>deactivate</code> <sup>removed</sup></a></h3>
<p>Use the component’s <a href="../api/#beforeDestroy"><code>beforeDestroy</code></a> or <a
        href="../api/#destroyed"><code>destroyed</code></a> hooks instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>deactivate</code> hook.</p>
</div>
<h3 id="canDeactivate-replaced"><a href="#canDeactivate-replaced" class="headerlink" title="canDeactivate replaced"
        data-scroll=""><code>canDeactivate</code> <sup>replaced</sup></a></h3>
<p>Use <a target="_blank" rel="noopener"
        href="https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards"><code>beforeRouteLeave</code></a>
    in the component instead.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>canDeactivate</code> hook.</p>
</div>
<h3 id="canReuse-false-removed"><a href="#canReuse-false-removed" class="headerlink" title="canReuse: false removed"
        data-scroll=""><code>canReuse: false</code> <sup>removed</sup></a></h3>
<p>There’s no longer a use case for this in the new Vue Router.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>canReuse: false</code> option.</p>
</div>
<h3 id="data-replaced"><a href="#data-replaced" class="headerlink" title="data replaced"
        data-scroll=""><code>data</code> <sup>replaced</sup></a></h3>
<p>The <code>$route</code> property is now reactive, so you can use a watcher to react to route changes, like this:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">watch</span>: {<br> <span class="hljs-string">'$route'</span>: <span class="hljs-string">'fetchData'</span><br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">fetchData</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-comment">// ...</span><br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>data</code> hook.</p>
</div>
<h3 id="loadingRouteData-removed"><a href="#loadingRouteData-removed" class="headerlink"
        title="$loadingRouteData removed" data-scroll=""><code>$loadingRouteData</code> <sup>removed</sup></a></h3>
<p>Define your own property (e.g. <code>isLoading</code>), then update the loading state in a watcher on the route. For
    example, if fetching data with <a target="_blank" rel="noopener"
        href="https://github.com/mzabriskie/axios">axios</a>:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">return</span> {<br> <span class="hljs-attr">posts</span>: [],<br> <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,<br> <span class="hljs-attr">fetchError</span>: <span class="hljs-literal">null</span><br> }<br>},<br><span class="hljs-attr">watch</span>: {<br> <span class="hljs-string">'$route'</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br> self.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">true</span><br> self.<span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> self.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">false</span><br> })<br> }<br>},<br><span class="hljs-attr">methods</span>: {<br> <span class="hljs-attr">fetchData</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br> <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/posts'</span>)<br> .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) {<br> self.<span class="hljs-property">posts</span> = response.<span class="hljs-property">data</span>.<span class="hljs-property">posts</span><br> })<br> .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {<br> self.<span class="hljs-property">fetchError</span> = error<br> })<br> }<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>$loadingRouteData</code> meta property.</p>
</div>
<div class="guide-links"> <span>← <a href="/v2/guide/migration.html">Migration from Vue 1.x</a></span> <span
        style="float: right"><a href="/v2/guide/migration-vuex.html">Migration from Vuex 0.6.x to 1.0</a> →</span>
</div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Migration from Vuex 0.6.x to 1.0</h1>
<blockquote>
    <p>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex
        1.0 and 2.0 were released simultaneously. What’s going on? Which one should I use and what’s compatible with Vue
        2.0?</p>
</blockquote>
<p>Both Vuex 1.0 and 2.0:</p>
<ul>
    <li>fully support both Vue 1.0 and 2.0</li>
    <li>will be maintained for the foreseeable future</li>
</ul>
<p>They have slightly different target users however.</p>
<p><strong>Vuex 2.0</strong> is a radical redesign and simplification of the API, for those who are starting new
    projects or want to be on the cutting edge of client-side state management. <strong>It is not covered by this
        migration guide</strong>, so you should check out <a target="_blank" rel="noopener"
        href="https://vuex.vuejs.org/en/index.html">the Vuex 2.0 docs</a> if you’d like to learn more about it.</p>
<p><strong>Vuex 1.0</strong> is mostly backwards-compatible, so requires very few changes to upgrade. It is recommended
    for those with large existing codebases or who want the smoothest possible upgrade path to Vue 2.0. This guide is
    dedicated to facilitating that process, but only includes migration notes. For the complete usage guide, see <a
        target="_blank" rel="noopener" href="https://github.com/vuejs/vuex/tree/1.0/docs/en">the Vuex 1.0 docs</a>.</p>
<h2 id="store-watch-with-String-Property-Path-replaced"><a href="#store-watch-with-String-Property-Path-replaced"
        class="headerlink" title="store.watch with String Property Path replaced"
        data-scroll=""><code>store.watch</code> with String Property Path <sup>replaced</sup></a></h2>
<p><code>store.watch</code> now only accept functions. So for example, you would have to replace:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">store.<span class="hljs-title function_">watch</span>(<span class="hljs-string">'user.notifications'</span>, callback)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>with:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js">store.<span class="hljs-title function_">watch</span>(<br> <span class="hljs-comment">// When the returned result changes...</span><br> <span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) {<br> <span class="hljs-keyword">return</span> state.<span class="hljs-property">user</span>.<span class="hljs-property">notifications</span><br> },<br> <span class="hljs-comment">// Run this callback</span><br> callback<br>)<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>This gives you more complete control over the reactive properties you’d like to watch.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>store.watch</code> with a string as the first
        argument.</p>
</div>
<h2 id="Store’s-Event-Emitter-removed"><a href="#Store’s-Event-Emitter-removed" class="headerlink"
        title="Store’s Event Emitter removed" data-scroll="">Store’s Event Emitter <sup>removed</sup></a></h2>
<p>The store instance no longer exposes the event emitter interface (<code>on</code>, <code>off</code>,
    <code>emit</code>). If you were previously using the store as a global event bus, <a
        href="migration.html#dispatch-and-broadcast-removed">see this section</a> for migration instructions.</p>
<p>Instead of using this interface to watch events emitted by the store itself (e.g.
    <code>store.on('mutation', callback)</code>), a new method <code>store.subscribe</code> is introduced. Typical usage
    inside a plugin would be:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">myPlugin</span> = store =&gt; {<br> store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">mutation, state</span>) {<br> <span class="hljs-comment">// Do something...</span><br> })<br>}<br><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>See example <a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md">the
        plugins docs</a> for more info.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of <code>store.on</code>, <code>store.off</code>, and
        <code>store.emit</code>.</p>
</div>
<h2 id="Middlewares-replaced"><a href="#Middlewares-replaced" class="headerlink" title="Middlewares replaced"
        data-scroll="">Middlewares <sup>replaced</sup></a></h2>
<p>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can
    listen to the mutation event on the store:</p>
<figure class="highlight js">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugins</span> = store =&gt; {<br> store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">'mutation'</span>, <span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {<br> <span class="hljs-comment">// Do something...</span><br> })<br>}<br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>For more details, see <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md">the plugins docs</a>.</p>
<div class="upgrade-path">
    <h4>Upgrade Path</h4>
    <p>Run the <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-migration-helper">migration
            helper</a> on your codebase to find examples of the <code>middlewares</code> option on a store.</p>
</div>
<div class="guide-links"> <span>← <a href="/v2/guide/migration-vue-router.html">Migration from Vue Router
            0.7.x</a></span> <span style="float: right"><a href="/v2/guide/migration-vue-2-7.html">Migration to Vue
            2.7</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Migration to Vue 2.7</h1>
<p>Vue 2.7 is the latest minor version of Vue 2. It provides built-in support for the <a target="_blank" rel="noopener"
        href="https://vuejs.org/guide/extras/composition-api-faq.html#composition-api-faq">Composition API</a>.</p>
<p>Despite Vue 3 now being the default version, we understand that there are still many users who have to stay on Vue 2
    due to dependency compatibility, browser support requirements, or simply not enough bandwidth to upgrade. In Vue
    2.7, we have backported some of the most important features from Vue 3 so that Vue 2 users can benefit from them as
    well.</p>
<h2 id="Backported-Features"><a href="#Backported-Features" class="headerlink" title="Backported Features"
        data-scroll="">Backported Features</a></h2>
<ul>
    <li><a target="_blank" rel="noopener" href="https://vuejs.org/guide/extras/composition-api-faq.html">Composition
            API</a></li>
    <li>SFC <a target="_blank" rel="noopener"
            href="https://vuejs.org/api/sfc-script-setup.html"><code>&lt;script setup&gt;</code></a></li>
    <li>SFC <a target="_blank" rel="noopener" href="https://vuejs.org/api/sfc-css-features.html#v-bind-in-css">CSS
            v-bind</a></li>
</ul>
<p>In addition, the following APIs are also supported:</p>
<ul>
    <li><code>defineComponent()</code> with improved type inference (compared to <code>Vue.extend</code>)</li>
    <li><code>h()</code>, <code>useSlot()</code>, <code>useAttrs()</code>, <code>useCssModules()</code></li>
    <li><code>set()</code>, <code>del()</code> and <code>nextTick()</code> are also provided as named exports in ESM
        builds.</li>
    <li>
        <p>The <code>emits</code> option is also supported, but only for type-checking purposes (does not affect runtime
            behavior)</p>
        <p>2.7 also supports using ESNext syntax in template expressions. When using a build system, the compiled
            template render function will go through the same loaders / plugins configured for normal JavaScript. This
            means if you have configured Babel for <code>.js</code> files, it will also apply to the expressions in your
            SFC templates.</p>
    </li>
</ul>
<h3 id="Notes-on-API-exposure"><a href="#Notes-on-API-exposure" class="headerlink" title="Notes on API exposure"
        data-scroll="">Notes on API exposure</a></h3>
<ul>
    <li>
        <p>In ESM builds, these APIs are provided as named exports (and named exports only):</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span>, { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">ref</span>; <span class="hljs-comment">// undefined, use named export instead</span><br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p>In UMD and CJS builds, these APIs are exposed as properties on the global <code>Vue</code> object.</p>
    </li>
    <li>
        <p>When bundling with CJS builds externalized, bundlers should be able to handle ESM interop when externalizing
            CJS builds.</p>
    </li>
</ul>
<h3 id="Behavior-Differences-from-Vue-3"><a href="#Behavior-Differences-from-Vue-3" class="headerlink"
        title="Behavior Differences from Vue 3" data-scroll="">Behavior Differences from Vue 3</a></h3>
<p>The Composition API is backported using Vue 2’s getter/setter-based reactivity system to ensure browser
    compatibility. This means there are some important behavior differences from Vue 3’s proxy-based system:</p>
<ul>
    <li>
        <p>All <a href="https://v2.vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">Vue 2 change detection
                caveats</a> still apply.</p>
    </li>
    <li>
        <p><code>reactive()</code>, <code>ref()</code>, and <code>shallowReactive()</code> will directly convert
            original objects instead of creating proxies. This means:</p>
        <figure class="highlight js">
            <table>
                <tbody>
                    <tr>
                        <td class="code">
                            <pre><code class="hljs js"><span class="hljs-comment">// true in 2.7, false in 3.x</span><br><span class="hljs-title function_">reactive</span>(foo) === foo;<br></code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </li>
    <li>
        <p><code>readonly()</code> <strong>does</strong> create a separate object, but it won’t track newly added
            properties and does not work on arrays.</p>
    </li>
    <li>
        <p>Avoid using arrays as root values in <code>reactive()</code> because without property access the array’s
            mutation won’t be tracked (this will result in a warning).</p>
    </li>
    <li>
        <p>Reactivity APIs ignore properties with symbol keys.</p>
    </li>
</ul>
<p>In addition, the following features are explicitly <strong>NOT</strong> ported:</p>
<ul>
    <li>❌ <code>createApp()</code> (Vue 2 doesn’t have isolated app scope)</li>
    <li>❌ Top-level <code>await</code> in <code>&lt;script setup&gt;</code> (Vue 2 does not support async component
        initialization)</li>
    <li>❌ TypeScript syntax in template expressions (incompatible w/ Vue 2 parser)</li>
    <li>❌ Reactivity transform (still experimental)</li>
    <li>❌ <code>expose</code> option is not supported for options components (but <code>defineExpose()</code> is
        supported in <code>&lt;script setup&gt;</code>).</li>
</ul>
<h2 id="Upgrade-Guide"><a href="#Upgrade-Guide" class="headerlink" title="Upgrade Guide" data-scroll="">Upgrade
        Guide</a></h2>
<h3 id="Vue-CLI-webpack"><a href="#Vue-CLI-webpack" class="headerlink" title="Vue CLI / webpack" data-scroll="">Vue CLI
        / webpack</a></h3>
<ol>
    <li>
        <p>Upgrade local <code>@vue/cli-xxx</code> dependencies the latest version in your major version range (if
            applicable):</p>
        <ul>
            <li><code>~4.5.18</code> for v4</li>
            <li><code>~5.0.6</code> for v5</li>
        </ul>
    </li>
    <li>
        <p>Upgrade <code>vue</code> to <code>^2.7.0</code>. You can also remove <code>vue-template-compiler</code> from
            the dependencies - it is no longer needed in 2.7.</p>
        <p>Note: if you are using <code>@vue/test-utils</code>, you will need to keep <code>vue-template-compiler</code>
            in the dependencies because test utils rely on some APIs only exposed in this package.</p>
    </li>
    <li>
        <p>Check your package manager lockfile to ensure the following dependencies meet the version requirements. They
            may be transitive dependencies not listed in <code>package.json</code>.</p>
        <ul>
            <li><code>vue-loader</code>: <code>^15.10.0</code></li>
            <li><code>vue-demi</code>: <code>^0.13.1</code></li>
        </ul>
        <p>If not, you will need to remove <code>node_modules</code> and the lockfile and perform a fresh install to
            ensure they are bumped to the latest version.</p>
    </li>
    <li>
        <p>If you were previously using <a target="_blank" rel="noopener"
                href="https://github.com/vuejs/composition-api"><code>@vue/composition-api</code></a>, update imports
            from it to <code>vue</code> instead. Note that some APIs exported by the plugin, e.g.
            <code>createApp</code>, are not ported in 2.7.</p>
    </li>
    <li>
        <p>Update <code>eslint-plugin-vue</code> to latest version (9+) if you run into unused variable lint errors when
            using <code>&lt;script setup&gt;</code>.</p>
    </li>
    <li>
        <p>The SFC compiler for 2.7 now uses PostCSS 8 (upgraded from 7). PostCSS 8 should be backwards compatible with
            most plugins, but the upgrade <strong>may</strong> cause issues if you were previously using a custom
            PostCSS plugin that can only work with PostCSS 7. In such cases, you will need to upgrade the relevant
            plugins to their PostCSS 8 compatible versions.</p>
    </li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite" data-scroll="">Vite</a></h3>
<p>2.7 support for Vite is provided via a new plugin: <a target="_blank" rel="noopener"
        href="https://github.com/vitejs/vite-plugin-vue2">@vitejs/plugin-vue2</a>. This new plugin requires Vue 2.7 or
    above and supersedes the existing <a target="_blank" rel="noopener"
        href="https://github.com/underfin/vite-plugin-vue2">vite-plugin-vue2</a>.</p>
<p>Note that the new plugin does not handle Vue-specific JSX / TSX transform, which is intentional. Vue 2 JSX / TSX
    transform for Vite is handled in a separate, dedicated plugin: <a target="_blank" rel="noopener"
        href="https://github.com/vitejs/vite-plugin-vue2-jsx">@vitejs/plugin-vue2-jsx</a>.</p>
<h3 id="Volar-Compatibility"><a href="#Volar-Compatibility" class="headerlink" title="Volar Compatibility"
        data-scroll="">Volar Compatibility</a></h3>
<p>2.7 ships improved type definitions so it is no longer necessary to install <code>@vue/runtime-dom</code> just for
    Volar template type inference support. All you need now is the following config in <code>tsconfig.json</code>:</p>
<figure class="highlight json">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs json"><span class="hljs-punctuation">{</span><br> <span class="hljs-comment">// ...</span><br> <span class="hljs-attr">"vueCompilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br> <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.7</span><br> <span class="hljs-punctuation">}</span><br><span class="hljs-punctuation">}</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<h3 id="Devtools-Support"><a href="#Devtools-Support" class="headerlink" title="Devtools Support"
        data-scroll="">Devtools Support</a></h3>
<p>Vue Devtools 6.2.0 has added support for inspecting 2.7 Composition API state, but the extensions may still need a
    few days to go through review on respective publishing platforms.</p>
<h2 id="Implications-of-the-2-7-Release"><a href="#Implications-of-the-2-7-Release" class="headerlink"
        title="Implications of the 2.7 Release" data-scroll="">Implications of the 2.7 Release</a></h2>
<p>As stated before, 2.7 is the final minor release of Vue 2.x. After this release, Vue 2 has entered LTS (long-term
    support) which lasts for 18 months from now, and will no longer receive new features.</p>
<p>This means <strong>Vue 2 will reach End of Life on December 31st, 2023</strong>. We believe this should provide
    plenty of time for most of the ecosystem to migrate over to Vue 3. However, we also understand that there could be
    teams or projects that cannot upgrade by this timeline while still need to fullfil security and compliance
    requirements. If your team expects to be using Vue 2 beyond end of 2023, make sure to plan head and understand your
    options: learn more about <a href="/lts/">Vue 2 LTS and Extended Support</a>.</p>
<div class="guide-links"> <span>← <a href="/v2/guide/migration-vuex.html">Migration from Vuex 0.6.x to 1.0</a></span>
    <span style="float: right"><a href="/v2/guide/comparison.html">Comparison with Other Frameworks</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Comparison with Other Frameworks</h1>
<p>This is definitely the most difficult page in the guide to write, but we do feel it’s important. Odds are, you’ve had
    problems you tried to solve and you’ve used another library to solve them. You’re here because you want to know if
    Vue can solve your specific problems better. That’s what we hope to answer for you.</p>
<p>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think
    it solves better than anything else out there. If we didn’t believe that, we wouldn’t be working on it. We do want
    to be fair and accurate though. Where other libraries offer significant advantages, such as React’s vast ecosystem
    of alternative renderers or Knockout’s browser support back to IE6, we try to list these as well.</p>
<p>We’d also like <strong>your</strong> help keeping this document up-to-date because the JavaScript world moves fast!
    If you notice an inaccuracy or something that doesn’t seem quite right, please let us know by <a target="_blank"
        rel="noopener"
        href="https://github.com/vuejs/v2.vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide">opening an
        issue</a>.</p>
<h2 id="React"><a href="#React" class="headerlink" title="React" data-scroll="">React</a></h2>
<p>React and Vue share many similarities. They both:</p>
<ul>
    <li>utilize a virtual DOM</li>
    <li>provide reactive and composable view components</li>
    <li>maintain focus in the core library, with concerns such as routing and global state management handled by
        companion libraries</li>
</ul>
<p>Being so similar in scope, we’ve put more time into fine-tuning this comparison than any other. We want to ensure not
    only technical accuracy, but also balance. We point out where React outshines Vue, for example in the richness of
    their ecosystem and abundance of their custom renderers.</p>
<p>With that said, it’s inevitable that the comparison would appear biased towards Vue to some React users, as many of
    the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and
    this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences
    happen to coincide with ours.</p>
<p>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to
    work with the React community to revamp this section in the near future.</p>
<h3 id="Runtime-Performance"><a href="#Runtime-Performance" class="headerlink" title="Runtime Performance"
        data-scroll="">Runtime Performance</a></h3>
<p>Both React and Vue are exceptionally and similarly fast, so speed is unlikely to be a deciding factor in choosing
    between them. For specific metrics though, check out this <a target="_blank" rel="noopener"
        href="https://stefankrause.net/js-frameworks-benchmark8/table.html">3rd party benchmark</a>, which focuses on
    raw render/update performance with very simple component trees.</p>
<h4 id="Optimization-Efforts"><a href="#Optimization-Efforts" class="headerlink"
        title="Optimization Efforts"></a>Optimization Efforts</h4>
<p>In React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at
    that component as root. To avoid unnecessary re-renders of child components, you need to either use
    <code>PureComponent</code> or implement <code>shouldComponentUpdate</code> whenever you can. You may also need to
    use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you
    may not be able to rely on such optimizations because <code>PureComponent/shouldComponentUpdate</code> assumes the
    entire sub tree’s render output is determined by the props of the current component. If that is not the case, then
    such optimizations may lead to inconsistent DOM state.</p>
<p>In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which
    components actually need to re-render when state changes. Each component can be considered to have
    <code>shouldComponentUpdate</code> automatically implemented for you, without the nested component caveats.</p>
<p>Overall this removes the need for a whole class of performance optimizations from the developer’s plate, and allows
    them to focus more on building the app itself as it scales.</p>
<h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS" data-scroll="">HTML &amp;
        CSS</a></h3>
<p>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend
    to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various
    trade-offs that may not seem worthwhile for every developer.</p>
<p>Vue embraces classic web technologies and builds on top of them. To show you what that means, we’ll dive into some
    examples.</p>
<h4 id="JSX-vs-Templates"><a href="#JSX-vs-Templates" class="headerlink" title="JSX vs Templates"></a>JSX vs Templates
</h4>
<p>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works
    within JavaScript.</p>
<p>Render functions with JSX have a few advantages:</p>
<ul>
    <li>
        <p>You can leverage the power of a full programming language (JavaScript) to build your view. This includes
            temporary variables, flow controls, and directly referencing JavaScript values in scope.</p>
    </li>
    <li>
        <p>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more
            advanced than what’s currently available for Vue templates.</p>
    </li>
</ul>
<p>In Vue, we also have <a href="render-function.html">render functions</a> and even <a
        href="render-function.html#JSX">support JSX</a>, because sometimes you do need that power. However, as the
    default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and
    this leads to a few advantages of its own:</p>
<ul>
    <li>
        <p>For many developers who have been working with HTML, templates feel more natural to read and write. The
            preference itself can be somewhat subjective, but if it makes the developer more productive then the benefit
            is objective.</p>
    </li>
    <li>
        <p>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of
            Vue’s reactivity features.</p>
    </li>
    <li>
        <p>It also makes it much easier for designers and less experienced developers to parse and contribute to the
            codebase.</p>
    </li>
    <li>
        <p>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</p>
    </li>
</ul>
<p>Some argue that you’d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we
    believe this difference is superficial at best. First, JSX doesn’t mean the user doesn’t need to learn anything -
    it’s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn,
    but saying it’s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML
    and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to
    help the user get more done with less code (e.g. <code>v-on</code> modifiers). The same task can involve a lot more
    code when using plain JSX or render functions.</p>
<p>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend
    using templates for presentational components and render function / JSX for logical ones. The percentage of these
    components depends on the type of app you are building, but in general we find presentational ones to be much more
    common.</p>
<h4 id="Component-Scoped-CSS"><a href="#Component-Scoped-CSS" class="headerlink"
        title="Component-Scoped CSS"></a>Component-Scoped CSS</h4>
<p>Unless you spread components out over multiple files (for example with <a target="_blank" rel="noopener"
        href="https://github.com/gajus/react-css-modules">CSS Modules</a>), scoping CSS in React is often done via
    CSS-in-JS solutions (e.g. <a target="_blank" rel="noopener"
        href="https://github.com/styled-components/styled-components">styled-components</a> and <a target="_blank"
        rel="noopener" href="https://github.com/emotion-js/emotion">emotion</a>). This introduces a new
    component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although
    there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will
    need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript
    while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</p>
<p>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. <a target="_blank"
        rel="noopener" href="https://github.com/styled-components/vue-styled-components">styled-components-vue</a> and
    <a target="_blank" rel="noopener" href="https://github.com/egoist/vue-emotion">vue-emotion</a>). The main difference
    between React and Vue here is that the default method of styling in Vue is through more familiar <code>style</code>
    tags in <a href="single-file-components.html">single-file components</a>.</p>
<p><a href="single-file-components.html">Single-file components</a> give you full access to CSS in the same file as the
    rest of your component code.</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"> <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">250px</span>) {</span><br><span class="language-css"> <span class="hljs-selector-class">.list-container</span><span class="hljs-selector-pseudo">:hover</span> {</span><br><span class="language-css"> <span class="hljs-attribute">background</span>: orange;</span><br><span class="language-css"> }</span><br><span class="language-css"> }</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>The optional <code>scoped</code> attribute automatically scopes this CSS to your component by adding a unique
    attribute (such as <code>data-v-21e5b78</code>) to elements and compiling <code>.list-container:hover</code> to
    something like <code>.list-container[data-v-21e5b78]:hover</code>.</p>
<p>Lastly, the styling in Vue’s single-file components is very flexible. Through <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-loader">vue-loader</a>, you can use any preprocessor, post-processor, and
    even deep integration with <a target="_blank" rel="noopener"
        href="https://vue-loader.vuejs.org/en/features/css-modules.html">CSS Modules</a> – all within the
    <code>&lt;style&gt;</code> element.</p>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale" data-scroll="">Scale</a></h3>
<h4 id="Scaling-Up"><a href="#Scaling-Up" class="headerlink" title="Scaling Up"></a>Scaling Up</h4>
<p>For large applications, both Vue and React offer robust routing solutions. The React community has also been very
    innovative in terms of state management solutions (e.g. Flux/Redux). These state management patterns and <a
        target="_blank" rel="noopener" href="https://yarnpkg.com/en/packages?q=redux%20vue&amp;p=1">even Redux
        itself</a> can be easily integrated into Vue applications. In fact, Vue has even taken this model a step further
    with <a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex">Vuex</a>, an Elm-inspired state
    management solution that integrates deeply into Vue that we think offers a superior development experience.</p>
<p>Another important difference between these offerings is that Vue’s companion libraries for state management and
    routing (among <a target="_blank" rel="noopener" href="https://github.com/vuejs">other concerns</a>) are all
    officially supported and kept up-to-date with the core library. React instead chooses to leave these concerns to the
    community, creating a more fragmented ecosystem. Being more popular though, React’s ecosystem is considerably richer
    than Vue’s.</p>
<p>Finally, Vue offers a <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli">CLI project
        generator</a> that makes it trivially easy to start a new project by featuring an interactive project
    scaffolding wizard. You can even use it for <a target="_blank" rel="noopener"
        href="https://cli.vuejs.org/guide/prototyping.html#instant-prototyping">instantly prototyping</a> a component.
    React is also making strides in this area with <a target="_blank" rel="noopener"
        href="https://github.com/facebookincubator/create-react-app">create-react-app</a>, but it currently has a few
    limitations:</p>
<ul>
    <li>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable
        runtime dependency that can be extended via <a target="_blank" rel="noopener"
            href="https://cli.vuejs.org/guide/plugins-and-presets.html#plugins">plugins</a>.</li>
    <li>It only offers a single template that assumes you’re building a single-page application, while Vue offers a wide
        variety of default options for various purposes and build systems.</li>
    <li>It cannot generate projects from user-built <a target="_blank" rel="noopener"
            href="https://cli.vuejs.org/guide/plugins-and-presets.html#presets">presets</a>, which can be especially
        useful for enterprise environments with pre-established conventions.</li>
</ul>
<p>It’s important to note that many of these limitations are intentional design decisions made by the create-react-app
    team and they do have their advantages. For example, as long as your project’s needs are very simple and you never
    need to “eject” to customize your build process, you’ll be able to update it as a dependency. You can read more
    about the <a target="_blank" rel="noopener"
        href="https://github.com/facebookincubator/create-react-app#philosophy">differing philosophy here</a>.</p>
<h4 id="Scaling-Down"><a href="#Scaling-Down" class="headerlink" title="Scaling Down"></a>Scaling Down</h4>
<p>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and
    probably ES2015+, since many examples use React’s class syntax. You also have to learn about build systems, because
    although you could technically use Babel Standalone to live-compile your code in the browser, it’s absolutely not
    suitable for production.</p>
<p>While Vue scales up just as well as React, it also scales down just as well as jQuery. That’s right - to get started,
    all you have to do is drop a single script tag into the page:</p>
<figure class="highlight html">
    <table>
        <tbody>
            <tr>
                <td class="code">
                    <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre>
                </td>
            </tr>
        </tbody>
    </table>
</figure>
<p>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having
    to worry about performance problems.</p>
<p>Since you don’t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes
    developers less than a day reading <a href="./">the guide</a> to learn enough to build non-trivial applications.</p>
<h3 id="Native-Rendering"><a href="#Native-Rendering" class="headerlink" title="Native Rendering" data-scroll="">Native
        Rendering</a></h3>
<p>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This
    is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this
    front, Vue has an official collaboration with <a target="_blank" rel="noopener"
        href="https://weex.apache.org/">Weex</a>, a cross-platform UI framework created by Alibaba Group and being
    incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author
    components that can not only be rendered in the browser, but also natively on iOS and Android!</p>
<p>At this moment, Weex is still in active development and is not as mature and battle-tested as React Native, but its
    development is driven by the production needs of the largest e-commerce business in the world, and the Vue team will
    also actively collaborate with the Weex team to ensure a smooth experience for Vue developers.</p>
<p>Another option is <a target="_blank" rel="noopener" href="https://nativescript-vue.org/">NativeScript-Vue</a>, a <a
        target="_blank" rel="noopener" href="https://www.nativescript.org/">NativeScript</a> plugin for building truly
    native applications using Vue.js.</p>
<h3 id="With-MobX"><a href="#With-MobX" class="headerlink" title="With MobX" data-scroll="">With MobX</a></h3>
<p>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to
    Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you’re using that
    combination and are enjoying it, jumping into Vue is probably the next logical step.</p>
<h3 id="Preact-and-Other-React-Like-Libraries"><a href="#Preact-and-Other-React-Like-Libraries" class="headerlink"
        title="Preact and Other React-Like Libraries" data-scroll="">Preact and Other React-Like Libraries</a></h3>
<p>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that
    reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a
    reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with
    everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear
    to work, they could break at any time unless your specific React-like library is officially supported on par with
    React.</p>
<h2 id="AngularJS-Angular-1"><a href="#AngularJS-Angular-1" class="headerlink" title="AngularJS (Angular 1)"
        data-scroll="">AngularJS (Angular 1)</a></h2>
<p>Some of Vue’s syntax will look very similar to AngularJS (e.g. <code>v-if</code> vs <code>ng-if</code>). This is
    because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its
    development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a
    significant improvement.</p>
<h3 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity" data-scroll="">Complexity</a></h3>
<p>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial
    applications typically takes less than a day, which is not true for AngularJS.</p>
<h3 id="Flexibility-and-Modularity"><a href="#Flexibility-and-Modularity" class="headerlink"
        title="Flexibility and Modularity" data-scroll="">Flexibility and Modularity</a></h3>
<p>AngularJS has strong opinions about how your applications should be structured, while Vue is a more flexible, modular
    solution. While this makes Vue more adaptable to a wide variety of projects, we also recognize that sometimes it’s
    useful to have some decisions made for you, so that you can just start coding.</p>
<p>That’s why we offer a full system for rapid Vue.js development. <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue-cli">Vue CLI</a> aims to be the standard tooling baseline for the Vue
    ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on
    writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the
    flexibility to tweak the configuration of each tool to specific needs.</p>
<h3 id="Data-binding"><a href="#Data-binding" class="headerlink" title="Data binding" data-scroll="">Data binding</a>
</h3>
<p>AngularJS uses two-way binding between scopes, while Vue enforces a one-way data flow between components. This makes
    the flow of data easier to reason about in non-trivial applications.</p>
<h3 id="Directives-vs-Components"><a href="#Directives-vs-Components" class="headerlink"
        title="Directives vs Components" data-scroll="">Directives vs Components</a></h3>
<p>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations
    only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do
    everything and components are just a specific kind of directive.</p>
<h3 id="Runtime-Performance-1"><a href="#Runtime-Performance-1" class="headerlink" title="Runtime Performance"
        data-scroll="">Runtime Performance</a></h3>
<p>Vue has better performance and is much, much easier to optimize because it doesn’t use dirty checking. AngularJS
    becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers
    need to be re-evaluated again. Also, the digest cycle may have to run multiple times to “stabilize” if some watcher
    triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle,
    and in some situations, there’s no way to optimize a scope with many watchers.</p>
<p>Vue doesn’t suffer from this at all because it uses a transparent dependency-tracking observation system with async
    queueing - all changes trigger independently unless they have explicit dependency relationships.</p>
<p>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</p>
<h2 id="Angular-Formerly-known-as-Angular-2"><a href="#Angular-Formerly-known-as-Angular-2" class="headerlink"
        title="Angular (Formerly known as Angular 2)" data-scroll="">Angular (Formerly known as Angular 2)</a></h2>
<p>We have a separate section for the new Angular because it really is a completely different framework from AngularJS.
    For example, it features a first-class component system, many implementation details have been completely rewritten,
    and the API has also changed quite drastically.</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript" data-scroll="">TypeScript</a></h3>
<p>Angular essentially requires using TypeScript, given that almost all its documentation and learning resources are
    TypeScript-based. TypeScript has its benefits - static type checking can be very useful for large-scale
    applications, and can be a big productivity boost for developers with backgrounds in Java and C#.</p>
<p>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result
    in more overhead than productivity gain. In those cases you’d be better off going with Vue instead, since using
    Angular without TypeScript can be challenging.</p>
<p>Finally, although not as deeply integrated with TypeScript as Angular is, Vue also offers <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vue/tree/dev/types">official typings</a> and <a target="_blank"
        rel="noopener" href="https://github.com/vuejs/vue-class-component">official decorator</a> for those who wish to
    use TypeScript with Vue. We are also actively collaborating with the TypeScript and VSCode teams at Microsoft to
    improve the TS/IDE experience for Vue + TS users.</p>
<h3 id="Runtime-Performance-2"><a href="#Runtime-Performance-2" class="headerlink" title="Runtime Performance"
        data-scroll="">Runtime Performance</a></h3>
<p>Both frameworks are exceptionally fast, with very similar metrics on benchmarks. You can <a target="_blank"
        rel="noopener" href="https://stefankrause.net/js-frameworks-benchmark8/table.html">browse specific metrics</a>
    for a more granular comparison, but speed is unlikely to be a deciding factor.</p>
<h3 id="Size"><a href="#Size" class="headerlink" title="Size" data-scroll="">Size</a></h3>
<p>Recent versions of Angular, with <a target="_blank" rel="noopener"
        href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT compilation</a> and <a target="_blank"
        rel="noopener" href="https://en.wikipedia.org/wiki/Tree_shaking">tree-shaking</a>, have been able to get its
    size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is
    still significantly lighter than an out-of-the-box, AOT-compiled application generated by <code>angular-cli</code>
    (~65KB gzipped).</p>
<h3 id="Flexibility"><a href="#Flexibility" class="headerlink" title="Flexibility" data-scroll="">Flexibility</a></h3>
<p>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no
    restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having
    only one Right Way to build any application.</p>
<h3 id="Learning-Curve"><a href="#Learning-Curve" class="headerlink" title="Learning Curve" data-scroll="">Learning
        Curve</a></h3>
<p>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these
    basic skills, you can start building non-trivial applications within less than a day of reading <a href="./">the
        guide</a>.</p>
<p>Angular’s learning curve is much steeper. The API surface of the framework is huge and as a user you will need to
    familiarize yourself with a lot more concepts before getting productive. The complexity of Angular is largely due to
    its design goal of targeting only large, complex applications - but that does make the framework a lot more
    difficult for less-experienced developers to pick up.</p>
<h2 id="Ember"><a href="#Ember" class="headerlink" title="Ember" data-scroll="">Ember</a></h2>
<p>Ember is a full-featured framework that is designed to be highly opinionated. It provides a lot of established
    conventions and once you are familiar enough with them, it can make you very productive. However, it also means the
    learning curve is high and flexibility suffers. It’s a trade-off when you try to pick between an opinionated
    framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom
    but also requires you to make more architectural decisions.</p>
<p>That said, it would probably make a better comparison between Vue core and Ember’s <a target="_blank" rel="noopener"
        href="https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/">templating</a> and <a target="_blank"
        rel="noopener" href="https://guides.emberjs.com/v2.10.0/object-model/">object model</a> layers:</p>
<ul>
    <li>
        <p>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In
            Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed
            properties.</p>
    </li>
    <li>
        <p>Vue’s template syntax harnesses the full power of JavaScript expressions, while Handlebars’ expression and
            helper syntax is intentionally quite limited in comparison.</p>
    </li>
    <li>
        <p>Performance-wise, Vue outperforms Ember <a target="_blank" rel="noopener"
                href="https://stefankrause.net/js-frameworks-benchmark8/table.html">by a fair margin</a>, even after the
            latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to
            manually manage run loops in performance-critical situations.</p>
    </li>
</ul>
<h2 id="Knockout"><a href="#Knockout" class="headerlink" title="Knockout" data-scroll="">Knockout</a></h2>
<p>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue’s.
    Its <a target="_blank" rel="noopener" href="http://knockoutjs.com/documentation/browser-support.html">browser
        support</a> is also very impressive considering everything it does, with support back to IE6! Vue on the other
    hand only supports IE9+.</p>
<p>Over time though, Knockout development has slowed and it’s begun to show its age a little. For example, its component
    system lacks a full set of lifecycle hooks and although it’s a very common use case, the interface for passing
    children to a component feels a little clunky compared to <a
        href="components.html#Content-Distribution-with-Slots">Vue’s</a>.</p>
<p>There also seem to be philosophical differences in the API design which if you’re curious, can be demonstrated by how
    each handles the creation of a <a target="_blank" rel="noopener"
        href="https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89">simple todo list</a>. It’s
    definitely somewhat subjective, but many consider Vue’s API to be less complex and better structured.</p>
<h2 id="Polymer"><a href="#Polymer" class="headerlink" title="Polymer" data-scroll="">Polymer</a></h2>
<p>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue’s components
    can be loosely compared to Polymer’s custom elements and both provide a very similar development style. The biggest
    difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to
    work (with degraded performance) in browsers that don’t support those features natively. In contrast, Vue works
    without any dependencies or polyfills down to IE9.</p>
<p>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance.
    For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its
    computed property implementation is also not very flexible.</p>
<h2 id="Riot"><a href="#Riot" class="headerlink" title="Riot" data-scroll="">Riot</a></h2>
<p>Riot 3.0 provides a similar component-based development model (which is called a “tag” in Riot), with a minimal and
    beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit
    heavier than Riot, Vue does offer some significant advantages:</p>
<ul>
    <li>Better performance. Riot <a target="_blank" rel="noopener"
            href="https://v3.riotjs.now.sh/compare/#virtual-dom-vs-expressions-binding">traverses a DOM tree</a> rather
        than using a virtual DOM, so suffers from the same performance issues as AngularJS.</li>
    <li>More mature tooling support. Vue provides official support for <a target="_blank" rel="noopener"
            href="https://github.com/vuejs/vue-loader">webpack</a> and <a target="_blank" rel="noopener"
            href="https://github.com/vuejs/vueify">Browserify</a>, while Riot relies on community support for build
        system integration.</li>
</ul>
<div class="guide-links"> <span>← <a href="/v2/guide/migration-vue-2-7.html">Migration to Vue 2.7</a></span> <span
        style="float: right"><a href="/v2/guide/join.html">Join the Vue.js Community!</a> →</span> </div>


<div id="ad">
    <script async="" type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&amp;placement=vuejsorg"
        id="_carbonads_js"> </script>
</div>
<h1>Join the Vue.js Community!</h1>
<p>Vue’s community is growing incredibly fast and if you’re reading this, there’s a good chance you’re ready to join it.
    So… welcome!</p>
<p>Now we’ll answer both what the community can do for you and what you can do for the community.</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources" data-scroll="">Resources</a></h2>
<h3 id="Code-of-Conduct"><a href="#Code-of-Conduct" class="headerlink" title="Code of Conduct" data-scroll="">Code of
        Conduct</a></h3>
<p>Our <a href="/coc">Code of Conduct</a> is a guide to make it easier to enrich all of us and the technical communities
    in which we participate.</p>
<h3 id="Get-Support"><a href="#Get-Support" class="headerlink" title="Get Support" data-scroll="">Get Support</a></h3>
<ul>
    <li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/">Forum</a>: The best place to ask questions and
        get answers about Vue and its ecosystem.</li>
    <li><a target="_blank" rel="noopener" href="https://chat.vuejs.org/">Chat</a>: A place for Vue devs to meet and chat
        in real time.</li>
    <li><a target="_blank" rel="noopener" href="https://events.vuejs.org/meetups">Meetups</a>: Want to find local Vue.js
        enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need
        right here!</li>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs">GitHub</a>: If you have a bug to report or
        feature to request, that’s what the GitHub issues are for. We also welcome pull requests!</li>
</ul>
<h3 id="Explore-the-Ecosystem"><a href="#Explore-the-Ecosystem" class="headerlink" title="Explore the Ecosystem"
        data-scroll="">Explore the Ecosystem</a></h3>
<ul>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue">The Awesome Vue Page</a>: See what
        other awesome resources have been published by other awesome people.</li>
    <li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/c/show-and-tell">The “Show and Tell”
            Subforum</a>: Another great place to check out what others have built with and for the growing Vue
        ecosystem.</li>
</ul>
<h2 id="What-You-Can-Do"><a href="#What-You-Can-Do" class="headerlink" title="What You Can Do" data-scroll="">What You
        Can Do</a></h2>
<h3 id="Contribute-Code"><a href="#Contribute-Code" class="headerlink" title="Contribute Code" data-scroll="">Contribute
        Code</a></h3>
<p>As with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as
    quickly as possible, please read <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md">the contributing guide</a>.</p>
<p>After that, you’ll be ready to contribute to Vue’s core repositories:</p>
<ul>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue">vue</a>: the core library</li>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex">vuex</a>: Flux-inspired state management
    </li>
    <li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router">vue-router</a>: a routing system
        for SPAs</li>
</ul>
<p>…as well as many smaller official <a target="_blank" rel="noopener" href="https://github.com/vuejs">companion
        libraries</a>.</p>
<h3 id="Share-and-Build-Your-Experience"><a href="#Share-and-Build-Your-Experience" class="headerlink"
        title="Share (and Build) Your Experience" data-scroll="">Share (and Build) Your Experience</a></h3>
<p>Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways
    to share and expand what you know:</p>
<ul>
    <li><strong>Develop learning materials.</strong> It’s often said that the best way to learn is to teach. If there’s
        something interesting you’re doing with Vue, strengthen your expertise by writing a blog post, developing a
        workshop, or even publishing a gist that you share on social media.</li>
    <li><strong>Watch a repo you care about.</strong> This will send you notifications whenever there’s activity in that
        repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way
        to build expertise so that you’re eventually able to help address issues and pull requests.</li>
</ul>
<h3 id="Translate-Docs"><a href="#Translate-Docs" class="headerlink" title="Translate Docs" data-scroll="">Translate
        Docs</a></h3>
<p>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. <a
        target="_blank" rel="noopener" href="https://forum.vuejs.org/">The forum</a> includes 7 languages and counting
    and many of our docs have <a target="_blank" rel="noopener"
        href="https://github.com/vuejs?utf8=%E2%9C%93&amp;q=vuejs.org">actively-maintained translations</a>. We’re very
    proud of Vue’s international reach, but we can do even better.</p>
<p>I hope that right now, you’re reading this sentence in your preferred language. If not, would you like to help us get
    there?</p>
<p>If so, please feel free to fork the repo for <a target="_blank" rel="noopener"
        href="https://github.com/vuejs/v2.vuejs.org/">these docs</a> or for any other officially maintained
    documentation, then start translating. Once you’ve made some progress, open an issue or pull request in the main
    repo and we’ll put out a call for more contributors to help you out.</p>
<h3 id="Become-a-Community-Leader"><a href="#Become-a-Community-Leader" class="headerlink"
        title="Become a Community Leader" data-scroll="">Become a Community Leader</a></h3>
<p>There’s a lot you can do to help Vue grow in your community:</p>
<ul>
    <li><strong>Present at your local meetup.</strong> Whether it’s giving a talk or running a workshop, you can bring a
        lot of value to your community by helping both new and experienced Vue developers continue to grow.</li>
    <li><strong>Start your own meetup.</strong> If there’s not already a Vue meetup in your area, you can start your
        own! Use the <a target="_blank" rel="noopener"
            href="https://events.vuejs.org/resources/#getting-started">resources at events.vuejs.org</a> to help you
        succeed!</li>
    <li><strong>Help meetup organizers.</strong> There can never be too much help when it comes to running an event, so
        offer a hand to help out local organizers to help make every event a success.</li>
</ul>
<p>If you have any questions on how you can get more involved with your local Vue community, reach out at <a
        target="_blank" rel="noopener" href="https://www.twitter.com/vuejs_events">@Vuejs_Events</a>!</p>
<div class="guide-links"> <span>← <a href="/v2/guide/comparison.html">Comparison with Other Frameworks</a></span> <span
        style="float: right"><a href="/v2/guide/team.html">Meet the Team</a> →</span> </div>

